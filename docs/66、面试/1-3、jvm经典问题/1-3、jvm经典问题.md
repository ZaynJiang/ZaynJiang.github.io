## 说明

​	实际面试时，因为时间有限，不可能所有问题都问一遍。

## 简单

* 什么是JVM？

  JVM全称是 Java Virtual Machine ，中文称为 Java虚拟机 。 

  JVM是Java程序运行的底层平台，与Java支持库一起构成了Java程序的执行环境。 
  分为JVM规范和JVM实现两个部分。简单来说，Java虚拟机就是指能执行标准Java字
  节码的虚拟计算机

  

* 请问JDK与JVM有什么区别？

  现在的JDK、JRE和JVM一般是整套出现的。 
  JDK = JRE + 开发调试诊断工具 
  JRE = JVM + Java标准库

  

* 你认识哪些JVM厂商?

  * Oracle公司，包括 Hotspot虚拟机、GraalVM；分为OpenJDK和OracleJDK两种
    版本。
  * IBM 公司，J9虚拟机， 用在IBM的产品套件中
  * Azul Systems公司，高性能的Zing和开源的Zulu
  * 阿里巴巴，Dragonwell 是阿里开发的OpenJDK定制版
  * 亚马逊，Corretto OpenJDK
  * Red Hat公司的OpenJDK
  * Adopt OpenJDK

  

* OracleJDK与OpenJDK有什么区别?

  * 两种JDK提供的工具套件略有差别，比如jmc等有版权的工具。

  * 某些协议或配置不一样，比如美国限制出口的加密算法。

  * 其他细微差别，比如JRE中某些私有的API不一样

    

* 什么是Java字节码？

  ​	Java 中的字节码，是值 Java 源代码编译后的中间代码格式，一般称为字节码文件。

  

* 字节码文件中包含哪些内容?

  字节码文件中，一般包含以下部分：

  * 版本号信息
  * 静态常量池（符号常量）
  * 类相关的信息
  * 字段相关的信息
  * 方法相关的信息
  * 调试相关的信息

  大部分信息都是通过常量池中的符号常量来表述的

  

* 什么是常量?怎么理解常量池?

  ​	常量是指不变的量，字母 'K'  或者数字 1024  在UTF8编码中对应到对应的二进制格式都是不变的。同样地，字符串在Java中的二进制表示也是不变的, 比如 "KK"  。 在Java中需要注意的是， final  关键字修饰的字段和变量，表示最终变量，只能赋值1次，不允许再次修改，由编译器和执行引擎共同保证

  在Java中，常量池包括两层含义：

  * 静态常量池，class文件中的一个部分，里面保存的是类相关的各种符号常量。
  * 运行时常量池， 其内容主要由静态常量池解析得到，但也可以由程序添加

  

* 开发中使用哪个版本的JDK？生产环境呢? 为什么这么选？

  ​	选择哪个版本需要考虑研发团队的具体情况：比如机器的操作系统，团队成员的掌握情况，兼顾遗留项目等等。 
  ​	Java最受欢迎的长期维护版本是Java8和Java11。

  ​	Java8是经典LTS版本，性能优秀，系统稳定，良好支持各种CPU架构和操作系统平台。
  ​	Java11是新的长期支持版，性能更强，支持更多新特性，而且经过几年的维护已
  经很稳定。
  ​	有的企业在开发环境使用OracleJDK，在生产环境使用OpenJDK。也有的企业恰好相反，在开发环境使用OpenJDK，在生产环境使用OracleJDK。 也有的公司使用同样的打包版本。开发和部署时只要进行过测试就没问题。 
  ​	一般来说。 测试环境、预上线环境的JDK配置需要和生产环境一致

  

## 中等

* JVM的运行时数据区有哪些?

  根据 JVM规范，标准的JVM运行时数据区包括以下部分：

  * 程序计数器
  * Java虚拟机栈
  * 堆内存
  * 方法区
  * 运行时常量池
  * 本地方法栈

  具体的JVM实现可根据实际情况进行优化或者合并，满足规范的要求即可

  

* 什么是堆内存？

  ​	堆内存是指由程序代码自由分配的内存，与栈内存作区分。 

  ​	在Java中，堆内存主要用于分配对象的存储空间，只要拿到对象引用，所有线程都可
  以访问堆内存

  

* 堆内存包括哪些部分？

  以Hotspot为例，堆内存（HEAP）主要由GC模块进行分配和管理， 可分为以下部
  分：

  * 新生代
  * 存活区
  * 老年代

  其中，新生代和存活区一般称为年轻代

  

* 什么是非堆内存?

  除堆内存之外，JVM的内存池还包括非堆（NON_HEAP），对应于JVM规范中的方法
  区，常量池等部分

  * MetaSpace

  * CodeCache

  * Compressed Class Space

    

* 什么是年轻代？

  年轻代是分来垃圾收集算法中的一个概念，相对于老年代而言，年轻代一般包括：新生代，Eden区。存活区，执行年轻代GC时，用存活区来保存活下来的对象。 存活区也是年轻代的一部分，但一般有2个存活区，所以可以来回倒腾

  

* 为什么有年轻代和老年代

  基于一个分代假说：

  * 绝大多数对象都是朝生夕死的

  * 熬过越多次垃圾回收的对象越难死亡



* 什么是内存溢出？

  内存溢出（OOM）是指可用内存不足。 程序运行需要使用的内存超出最大可用值，如果不进行处理就会影响到其他进程，所
  以现在操作系统的处理办法是：只要超出立即报错，比如抛出 内存溢出错误 。就像杯子装不下，满了要溢出来一样，比如一个杯子只有500ml的容量，却倒进去600ml，于是水就溢出造成破坏

  

* 什么是内存泄漏?

  ​	内存泄漏（Memory Leak）是指本来无用的对象却继续占用内存，没有再恰当的时机释放占用的内存。不使用的内存，却没有被释放，称为 内存泄漏 。 也就是该释放的没释放，该回收的没回收。 

  ​	比较典型的场景是： 每一个请求进来，或者每一次操作处理，都分配了内存，却有一部分不能回收（或未释放），那么随着处理的请求越来越多，内存泄漏也就越来越严重

  ​	在Java中一般是指无用的对象却因为错误的引用关系，不能被GC回收清理

  

* 内存泄漏和内存溢出有什么关系?

  如果存在严重的内存泄漏问题，随着时间的推移，则必然会引起内存溢出。 内存泄漏一般是资源管理问题和程序BUG，内存溢出则是内存空间不足和内存泄漏的最终结果

  

* 常用的JVM启动参数有哪些?

  JVM可配置参数已经达到1000多个，其中GC和内存配置相关的JVM参数就有600多个。但在绝大部分业务场景下，常用的JVM配置参数也就10来个：

  启动参数：

  ```
  # JVM启动参数不换行
  # 设置堆内存
  ‐Xmx4g ‐Xms4g
  # 指定GC算法
  ‐XX:+UseG1GC ‐XX:MaxGCPauseMillis=50
  # 指定GC并行线程数
  ‐XX:ParallelGCThreads=4
  # 打印GC日志
  ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps
  # 指定GC日志文件
  ‐Xloggc:gc.log
  # 指定Meta区的最大值
  ‐XX:MaxMetaspaceSize=2g
  # 设置单个线程栈的大小
  ‐Xss1m
  # 指定堆内存溢出时自动进行Dump
  ‐XX:+HeapDumpOnOutOfMemoryError
  ‐XX:HeapDumpPath=/usr/local/
  ```

  属性配置参数：

  ```
  # 指定默认的连接超时时间
  ‐Dsun.net.client.defaultConnectTimeout=2000
  ‐Dsun.net.client.defaultReadTimeout=2000
  # 指定时区
  ‐Duser.timezone=GMT+08
  # 设置默认的文件编码为UTF‐8
  ‐Dfile.encoding=UTF‐8
  # 指定随机数熵源(Entropy Source)
  ‐Djava.security.egd=file:/dev/./urandom
  ```



* 设置堆内存XMX应该考虑哪些因素？

  需要根据系统的配置来确定，要给操作系统和JVM本身留下一定的剩余空间。 推荐配置系统或容器里可用内存的 70­80% 最好。



* 假设物理内存是8G，设置多大堆内存比较合适?

  比如说系统有 8G 物理内存，系统自己可能会用掉一点，大概还有 7.5G 可以用，那么建议配置 ‐Xmx6g 。

  说明： 7.5G*0.8 = 6G ，如果知道系统里有明确使用堆外内存的地方，还需要进一步降低这个值



* ‐Xmx  设置的值与JVM进程所占用的内存有什么关系?

​		JVM总内存=栈+堆+非堆+堆外+Native



* 怎样开启GC日志？

  JDK8及以下版本通过以下参数来开启GC日志：

  ```
  ‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐Xloggc:gc.log
  ```



* 常见的垃圾收集器有哪些? 都有什么特点？

  常见的垃圾收集器包括：

  * 串行垃圾收集器： ‐XX:+UseSerialGC

    只有单个worker线程来执行GC工作。

  * 并行垃圾收集器： ‐XX:+UseParallelGC

    并行垃圾收集，是指使用多个GC worker 线程并行地执行垃圾收集，能充分利用多核CPU的能力，缩短垃圾收集的暂停时间。 
    除了单线程的GC，其他的垃圾收集器，比如 PS，CMS， G1等新的垃圾收集器都使用了多个线程来并行执行GC工作。

  * CMS垃圾收集器： ‐XX:+UseConcMarkSweepGC

    并发垃圾收集器，是指在应用程序在正常执行时，有一部分GC任务，由GC线程在应用线程一起并发执行。 例如 CMS/G1的各种并发阶段

  * G1垃圾收集器： ‐XX:+UseG1GC

    首先， G1的堆内存不再单纯划分为年轻代和老年代，而是划分为多个（通常是 2048个）可以存放对象的小块堆区域（smaller heap regions）。 每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。 这样划分之后，使得 G1 不必每次都去回收整个堆空间，而是以增量的方式来进行处理： 每次只处理一部分内存块，称为此次 GC 的回收集（collection set）。 下一次GC时在本次的基础上，再选定一定的区域来进行回收。增量式垃圾收集的好处是大大降低了单次GC暂停的时间



* Java8默认使用的垃圾收集器是什么?

  Java8版本的Hotspot JVM，默认情况下使用的是并行垃圾收集器（Parallel GC）。其
  他厂商提供的JDK8基本上也默认使用并行垃圾收集器。Java9之后，官方JDK默认使用的垃圾收集器是G1。



* 什么是GC停顿(GC pause)？GC停顿与STW停顿有什么区别？

  因为GC过程中，有一部分操作需要等所有应用线程都到达安全点，暂停之后才能执行，这时候就叫做GC停顿，或者叫做GC暂停。GC停顿与STW停顿两者一般可以认为就是同一个意思

  

* 如果CPU使用率突然飙升，你会怎么排查？

  针对当前问题，往往需要使用不同的工具来收集信息：

  * 收集不同的指标（CPU，内存，磁盘IO，网络等等）

  * 分析应用日志

  * 分析GC日志

  * 获取jstack日志并分析

  * 获取堆快照进行分析

    

* 系统性能一般怎么衡量？

  可量化的3个性能指标：

  * 系统容量：比如硬件配置，设计容量；
  * 吞吐量：最直观的指标是TPS；
  * 响应时间：也就是系统延迟，包括服务端延时和网络延迟。

  这些指标。可以具体拓展到单机并发，总体并发，数据量，用户数，预算成本等等



* 使用过哪些JVM相关的工具？

  根据实际情况回答，如果jstat、jmap、jstack命令，还有一些jmc等工具



* 内存Dump时有哪些注意事项?

  根据实际情况来看，获取内存快照可能会让系统暂停或阻塞一段时间，根据内存量决
  定。使用jmap时，如果指定 live  参数，则会触发一次FullGC，需要注意

## 困难

* 给定一个具体的类，请分析对象的内存占用大小

  ```
  public class Order{
    private long orderId;
    private long empId;
    private byte state;
    private long createTime;
  }
  ```

  一般来说，Order类的每个对象会占用40个字节。

  因为不同的类型在内存中的占用字节是不一样的。对象的占用内存：对象头+实例数据+补齐填充，该class的计算过程如下：

  * 对象头占用12字节。

    对象头中一般包含两个部分：

    * 标记字，占用一个机器字，也就是8字节。

    * 类型指针，占用一个机器字，也就是8个字节

      如果堆内存小于32GB，JVM默认会开启指针压缩，则只占用4个字节

    所以对象头占用12字节，如果是数组，对象头中还会多出一个部分数组长度， 为int值，占用4字节

  * 每个long类型的字段占用8字节，3个long字段占用24字节。

  * byte 字段占用1个字节。

  * 以上合计 37字节，加上以3字节对齐，则实际占用40个字节

    因为实例数据是由实际的数据+内存补齐构成，这样是为了内存的对接。使得最终的内存的占用满足8N/

    

* cms垃圾回收器的回收过程是什么？它有什么特点？

  ​	并行GC，在GC的时候会全心全意的进行GC，当扫描的对象特别多的时候，stw时间还是很长的，系统会有明显的卡顿。如果应用对卡顿很敏感，那么这种就不可被接受，那么cms就是因为这个被设计出来的。
  ​	因为卡顿主要是老年代回收比较慢，所以尽可能加快老年代的回收速度，因为它从这两方面进行改进：

  * 它在老年代执行的是标记清除算法，并没有整理。
  * 采用了空闲列表来管理内存。这一切都是为了降低回收的卡顿，它清除回收对象的时候是和业务线程并发执行的

  它将回收的过程拆分了很多步骤，其中大部分是和业务线程并发执行的，所以延迟较低。CMS回收分为6步：

  * 初始标记(STW initial mark)
  * 并发标记(Concurrent marking)
  * 并发预清理(Concurrent precleaning)
  * 重新标记(STW remark)
  * 并发清理(Concurrent sweeping)
  * 并发重置(Concurrent reset) 

  带有Concurrent字样的都是和业务线程并发运行的，所以它的能尽可能减少gc的时候停顿时间。适用老年代对象比较多，延迟容忍度低，内存和cpu配置高的系统。

  ​	CMS有很多好处，但是需要额外空间作为缓冲空间，以便标记时能够继续分配对象，一般不会满的时候进行回收，占一定比例后就触发垃圾回收；老年代内存不会进行内存整理，是使用可用列表，实际使用的时候对象大小不一，存在一定的浪费。



* jvm如何标记存活的对象?

  标记算法一般有引用计数和可达性分析算法

  * 引用计数

    给对象添加一个计数器，每当有地方引用它计数器就+1，反之引用失效时就-1，那么计数器值为0的对象就是可以回收的对象，但是有一个问题就是循环引用的话无法解决

  * 可达性分析(引用跟踪算法)

    对于现在的虚拟机来说，主要用的算法是可达性分析算法

    * 定义GC ROOTS根对象集合
    * 通过GC ROOTS向下搜索，搜索的过程走过的路径称作引用链
    * 如果某个对象到GC ROOTS没有任何引用链，那么就是对象不可达，是可以被回收的对象
    * 不可达对象需要进行两次标记，第一次发现没有引用链相连，会被第一次标记
      * 如果需要执行finalize()方法，之后这个对象会被放进队列中等待执行finalize()
      * 如果在finalize()中成功和引用链上的其他对象关联，就会被移出可回收对象集合。

  ​	

* jvm如何解决跨代引用的问题？

  ​	在回收新生代的时候，有可能有老年代的对象引用了新生代对象，所以老年代也需要作为根，但是如果扫描整个老年代的话效率就又降低了。所以就搞了个叫记忆集（Remembered Set）的东西，来记录跨代之间的引用而避免扫描整体非收集区域

  ​	记忆集是一种用于记录从非收集区域指向收集区域的指针集合的数据结构，假如所有的老年代对象都有指针指向了新生代，那么我们需要维护整个老年代大小的记忆集，毫无疑问这种方法是不可取的。因此我们引入了卡表的数据结构

  ​	卡表就是映射了一块块的内存地址，这些内存地址块称为卡页。如果该区域中有引用指向了待回收区域的对象，卡表数组对应的元素将被置为1，没有则置为0

  ​	卡表使用原理：

  * 只要一个卡页内的对象存在一个或者多个跨代对象指针，就将该位置的卡表数组元素修改为1，表示这个位置为脏，没有则为0。

  * 在GC的时候，就直接把值为1对应的卡页对象指针加入GC Roots一起扫描即可。

  * 我们就不需要去在发生MinorGC的时候扫描整个老年代了，性能得到了极大的提升

    卡表的数组元素要修改成1，也就是脏的状态，对于HotSpot来说是通过写屏障来实现的，就是在其他分代引用了当前分代的对象时候，在对引用进行赋值的时候进行更新，更新的方式类似AOP的切面思想



* 什么是三色标记？它解决了什么问题？

  卡表解决了跨代收集和根节点枚举的性能问题，但是GC Roots开始遍历，怎么才能高效的标记这些对象，这就是三色标记法的作用	了。因为如果堆内的对象越多，那么显然标记产生的停顿时间就越长。三色标记主要是解决和用户线程并发的时候标记的问题。三色标记的过程：

  * 白色，在刚开始遍历的时候，所有的对象都是白色的
  * 灰色，被垃圾回收器扫描过，但是至少还有一个引用没有被扫描
  * 黑色，被垃圾回收器扫描过，并且这个对象的引用也全部都被扫描过，是安全存活的对象

  三色标记并发标记的时候，有两个问题：

  * 有些对象在开始阶段是存活，但是后来又变成垃圾了。应该要清理的对象标记成存活，这样本次GC就无法清理这个对象，这个被称作为浮动垃圾，解决方案就是等下次GC的时候再清理

  * 如果把存活对象标记成需要清理，那么就有点麻烦了，这样你的程序就该出问题了

    只有同时满足两个条件才会发生这种对象消失的问题：

    * 插入了一条或者多条黑色到白色对象的引用
    * 删除了全部从灰色到白色对象的引用

  针对这个问题也有两种解决方案

  * 增量更新

    会把这些新插入的引用记录下来，扫描结束之后，再以黑色对象为根重新扫描一次。这样看起来不就是增量更新吗，新插入的记录再扫一次！CMS使用的是增量更新

  * 原始快照

    把这个要删除的引用记录下来，扫描结束之后，以灰色对象为根重新扫描一次。所以就像是快照一样，不管你删没删，其实最终还是会按照之前的关系重新来一次。G1则是使用原始快照。

    

* 你碰到过哪些JVM问题？这个问题是怎么分析和解决的？这个过程中有哪些值得分享的经验?

  开放性问题，举一个实际的例子