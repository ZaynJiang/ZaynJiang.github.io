## 1. 概述

### 1.1. 数据类型

Redis 数据结构并不是指 string（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Zset（有序集合），因为这些是 Redis 键值对中值的数据类型，并不是数据结构。这些数据类型的底层实现的方式，才是数据结构.

![](redis的数据类型和数据结构.png) 

### 1.2. 数据结构

![](redis的数据结构.png) 

## 2. SDS

​	字符串在 Redis 中是很常用的，键值对中的键是字符串，值有时也是字符串。

​	redis没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS

### 2.1. c语言字符串缺陷

C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。

对字符串操作时，char * 指针只是指向字符数组的起始位置，而**字符数组的结尾位置就用“\0”表示，意思是指字符串的结束**

C 语言标准库中字符串的操作函数，就通过判断字符是不是“\0”，如果不是说明字符串还没结束，可以继续操作，如果是则说明字符串结束了，停止操作。

如图所示：

![](c语言字符串结构.png) 

这就会导致两个问题：

* **C 语言获取字符串长度操作的时间复杂度是 O（N）**

* 字符串中不能 “\0” 字符外，用 char* 字符串中的字符必须符合某种编码（比如ASCII）。

  限制使得 C 语言的字符串只能保存文本数据，**不能保存像图片、音频、视频文化这样的二进制数据**

* 字符串操作函数不高效且不安全，比如可能会发生缓冲区溢出，从而造成程序运行终止

  比如将 src 字符串拼接到 dest 字符串后面 char *strcat(char *dest, const char* src);

  strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止

### 2.2. redis字符串实现

![](redis的sds结构.png) 

* **len**

  SDS 所保存的字符串长度。获取字符串的长度的

* **alloc**

  分配给字符数组的空间长度

* **flags**

  SDS 类型，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64

* **buf[]**

  字节数组，用来保存实际数据

#### 2.2.1. redis字符串改进点

* 可以保存二进制数据

  不需要用 “\0” 字符来标识字符串结尾了，而是直接将其作为二进制数据处理，可以用来保存图片等二进制数据。它即可以保存文本数据，也可以保存二进制数据

* 获取保存字符串长度o(n)

* 无缓冲区溢出风险了

  SDS API 通过 `alloc - len` 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用：

  * 当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小，以满足修改所需的大小
  * SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」
  * 下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，有效的减少内存分配次数

  **相当于之前c语言拼接字符串没去校验溢出风险，redis封装了拼接字符串方法，先校验，不行就扩容。**

#### 2.2.2. 空间优化

**1）数据类型优化：**

SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间

SDS 结构中有个 flags 成员变量，表示的是 SDS 类型：

* sdshdr5
* sdshdr8
* sdshdr16
* sdshdr32 
* sdshdr64

**区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同**

如：

```
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc; 
    unsigned char flags; 
    char buf[];
};


struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc; 
    unsigned char flags;
    char buf[];
};
```

- sdshdr16 

  数组长度和分配空间大小不能超过 2 的 16 次方。

- sdshdr32 

  字符数组长度和分配空间大小不能超过 2 的 32 次方

**2）字节对齐优化**

​	Redis 在编程上还**使用了专门的编译优化来节省内存空间**，即在 struct 声明了 `__attribute__ ((packed))` ，它的作用是：**告诉编译器取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐**

* c语言字节对齐

  默认情况下，sdshdr16 类型的 SDS，编译器会按照 16 字节对其的方式给变量分配内存，这意味着，即使一个变量的大小不到 16 个字节，编译器也会给它分配 16 个字节。

  例如：

  ```
  #include <stdio.h>
  
   struct test1 {
      char a;
      int b;
   } test1;
  
  int main() {
       printf("%lu\n", sizeof(test1));
       return 0;
  }
  ```

  虽然char是1个字节，但是int是4个字节，为了对齐。结构体大小计算出来是 8。其中3 个字节被浪费掉了

  ![](c语言字节对齐.png)

* redis的`__attribute__ ((packed))` 

  采用了 `__attribute__ ((packed))` 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间.

  ```
  #include <stdio.h>
  
  struct __attribute__((packed)) test2  {
      char a;
      int b;
   } test2;
  
  int main() {
       printf("%lu\n", sizeof(test2));
       return 0;
  }
  ```

  ![](redis紧凑排列.png)

  

## 3. 链表

Redis 的 list 数据类型的底层实现之一就是链表。C 语言本身也是没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。

![](双向链表.png) 

Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，链表结构如下：

```
typedef struct list {
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
} list;
```

- listNode 链表节点带有 prev 和 next 指针

  **获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表**；

- list 结构因为提供了表头指针 head 和表尾节点 tail

  所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**

- list 结构因为提供了链表节点数量 len

  所以**获取链表中的节点数量的时间复杂度只需O(1)**

- listNode 链表节使用 void* 指针保存节点值

  并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此链表节点可以保存各种不同类型的值；

**链表的缺陷：**

​	链表的缺陷也是有的，链表每个节点之间的内存都是不连续的，意味着无法很好利用 CPU 缓存。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。

​	因此，Redis 的 list 数据类型在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，压缩列表就是由数组实现的

## 4. 压缩列表

### 4.1. 使用场景

- 当一个列表键（list）只包含少量的列表项，并且每个列表项都是小整数值，或者长度比较短的字符串，那么 Redis 就会使用压缩列表作为列表键（list）的底层实现。
- 当一个哈希键（hash）只包含少量键值对，并且每个键值对的键和值都是小整数值，或者长度比较短的字符串，那么 Redis 就会使用压缩列表作为哈希键（hash）的底层实现。

### 4.2. 结构设计

#### 4.2.1.  整体结构

**由连续内存块组成的顺序型数据结构**。

![](压缩列表结构设计.png) 

压缩列表在表头有三个字段：

- **zlbytes**，记录整个压缩列表占用对内存字节数；
- **zltail**，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；
- **zllen**，记录压缩列表包含的节点数量；
- **zlend**，标记压缩列表的结束点，特殊值 OxFF（十进制255）。

这种设计查找头部和尾部都将是o(1)，但是查找其它元素都将是o(n)

#### 4.2.2.  节点结构

![](压缩列表节点结构.png) 

压缩列表节点包含三部分内容：

* prevlen

  记录了前一个节点的长度；

* encoding

  记录了当前节点实际数据的类型以及长度；

* data

  记录了当前节点的实际数据

当我们往压缩列表中插入数据时，压缩列表 就会根据数据是字符串还是整数，以及它们的大小会在 prevlen 和 encoding 这两个元素里保存不同的信息，这种根据数据大小进行对应信息保存的设计思想，正是 Redis 为了节省内存而采用

#### 4.2.3.  连锁更新

​	压缩列表除了查找复杂度高的问题，压缩列表在插入元素时，如果内存空间不够了，压缩列表还需要重新分配一块连续的内存空间，而这可能会引发**连锁更新**的问题。因此，**压缩列表只会用于保存的节点数量不多的场景**，只要节点数量足够小，即使发生连锁更新，也是能接受的。

连锁更新的过程：

* 如果前一个**节点的长度小于 254 字节**，那么 prevlen 属性需要用 **1 字节的空间**来保存这个长度值
* 如果前一个**节点的长度大于等于 254 字节**，那么 prevlen 属性需要用 **5 字节的空间**来保存这个长度值
* 假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点
* 因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值
* 如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即第一个数据节点
* 因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小
* 多米诺牌的效应，需要从前往后全部更新

**这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」**

**连锁更新一旦发生，就会导致压缩列表 占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能**

## 5. hash表

哈希表是一种保存键值对（key-value）的数据结构

Hash 表优点在于，它**能以 O(1) 的复杂度快速查询数据**。主要是通过 Hash 函数的计算，就能定位数据在表中的位置，紧接着可以对数据进行操作，这就使得数据操作非常快

但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么**哈希冲突**的可能性也会越高

### 5.1. 链式哈希

​	**Redis 采用了链式哈希**，在不扩容哈希表的前提下，将具有相同哈希值的数据链接起来，以便这些数据在表中仍然可以被查询到。

​	实现的方式就是每个哈希表节点都有一个 next 指针，多个哈希表节点可以用 next 指针构成一个单项链表，**被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来**，这样就解决了哈希冲突。

![](链式hash.png) 

### 5.2. rehash

​	随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O（n)。要想解决这一问题，就需要进行 rehash，就是对哈希表的大小进行扩展。

Redis 会使用了两个全局哈希表进行 rehash：

* 在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。
* 随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：
  - 给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；
  - 将「哈希表 1 」的数据迁移到「哈希表 2」 中；
  - 迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。

![](hash表rehash图.png) 

### 5.3. 渐进式 rehash

​	如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求。

​	为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了**渐进式 rehash**，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移

渐进式 rehash 步骤如下：

- 给「哈希表 2」 分配空间；
- **在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上**；
- 随着处理客户端发起的哈希表操作请求数量越多，最终会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。

这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。

**因此总结下来：**

进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。

比如，查找一个 key 的值的话，先会在哈希表 1 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。

另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。

### 5.4. rehash阈值

rehash 的触发条件跟**负载因子（load factor）**有关系：

负载因此=保存的节点数量/hash表的大小。

触发 rehash 操作的条件，主要有两个：

- 当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。
- 当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。