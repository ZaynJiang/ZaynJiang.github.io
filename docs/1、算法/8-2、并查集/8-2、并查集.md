## 1. 开头

## 2. 经典题目

* 【990】等式方程的可满足性
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。
  * 适用并查集
```
   int[] uf = new int[26];

    public boolean equationsPossible(String[] equations) {
        for (int i = 0; i < 26; i++) {
            uf[i] = i;
        }
        for (String equation : equations) {
            if (equation.charAt(1) == '=') {
                uf[find(equation.charAt(0) - 'a')] = find(equation.charAt(3) - 'a');
            }
        }
        for (String equation : equations) {
            if (equation.charAt(1) == '!' && find(equation.charAt(0) - 'a') == find(equation.charAt(3) - 'a')) {
                return false;
            }
        }
        return true;
    }

    public int find(int val) {
        if (val != uf[val]) {
            uf[val] = find(uf[val]);
        }
        return uf[val];
    }
```


* 【765】. 情侣牵手
N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。

人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。

这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的
  * 并查集
  * 「首尾相连」这件事情可以使用 并查集 表示，将输入数组相邻位置的两个 编号 在并查集中进行合并。编写代码基于了下面的事实：
如果一对情侣恰好坐在了一起，并且坐在了成组的座位上，其中一个下标一定是偶数，另一个一定是奇数，并且「偶数的值 + 1 = 奇数的值」。例如编号数对 [2, 3]、[9, 8]，这些数对的特点是除以 22（下取整）得到的数相等
```
    public int minSwapsCouples(int[] row) {
        int n = row.length / 2;
        Uf uf = new Uf(n);
        for (int i = 0; i < row.length; i += 2) {
            uf.union(row[i] / 2, row[i + 1] / 2);
        }
        return n - uf.getCount();
    }

    public class Uf {
        int[] uf;
        int count = 0;

        public Uf(int n) {
            uf = new int[n];
            count = n;
            for (int i = 0; i < n; i++) {
                uf[i] = i;
            }
        }

        public int getCount() {
            return count;
        }

        public int find(int val) {
            if (val != uf[val]) {
                uf[val] = find(uf[val]);
            }
            return uf[val];
        }

        public void union(int x1, int x2) {
            int v1 = find(x1), v2 = find(x2);
            if (v1 == v2) {
                return;
            }
            count--;
            uf[v1] = v2;
        }
    }
```