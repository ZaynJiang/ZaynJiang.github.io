## 1. 概述

## 2. 经典题目 

* 【295】数据流的中位数
* 可以将数据分为左右两边，一边以最大堆的形式实现，可以快速获得左侧最大数， 另一边则以最小堆的形式实现。其中需要注意的一点就是左右侧数据的长度差不能超过1。 这种实现方式的效率与AVL平衡二叉搜索树的效率相近，但编写更快
```
    PriorityQueue<Integer> min;
    PriorityQueue<Integer> max;
    public MedianFinder() {
        max = new PriorityQueue<>((o1, o2) -> o2 - o1); // 大顶堆
        min = new PriorityQueue<>(); // 小顶堆
    }

    public void addNum(int num) {
        if (min.size() >= max.size()) {
            min.offer(num);// 往小顶堆加元素，一定会有一个更小的元素冒出来，需要平衡以下
            max.offer(min.poll());
        } else {
            max.offer(num);
            min.offer(max.poll());
        }
    }

    public double findMedian() {
        if (max.size() == min.size()) {
            return (max.peek() + min.peek()) / 2.0;
        } else if (max.size() > min.size()) {
            return max.peek();
        } else {
            return min.peek();
        }
    }
```

* 【1353】给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi.你可以在满足 startDayi <= d <= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。请你返回你可以参加的 最大 会议数目。
   * 所有开始时间相同的会议中，我们尽量的去选择结束时间最小的会议，因为结束时间更大的会议的选择天数更多
   * 这里我们需要能快速的选择结束时间最小的会议，而且这个最小的结束时间是动态变化的，因为参加了一个会议，就应该排除这个会议高效的维护动态数据的最小值，我们想到了小顶堆了
   * 首先，对会议按照开始时间升序排列，排序的目的是为了可以方便的一起选择开始时间相同的会议
   * 然后从第 1 天开始，依次判断每一天是否可以参加会议，记当天为 currDay ，从第 1 天开始
   * 顺序遍历会议，将开始时间等于 currDay 的会议的结束时间放入小顶堆
   * 将堆顶结束时间小于 currDay 的会议从堆中删除，这些会议都是过时的，参加不到的会议
   * 如果堆不为空，则选择会议结束时间最小的会议参加，表示 currDay 这一天可以参加会议
   * currDay 往后走一天，判断下一天是否可以参加会议
```
    public int maxEvents(int[][] events) {
        Arrays.sort(events, Comparator.comparingInt(o -> o[0]));
        //开始时间相同的会议中，我们尽量的去选择结束时间最小的会议，因为结束时间更大的会议的选择天数更多
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        int days = 1, i = 0, res = 0;
        while (i < events.length || !queue.isEmpty()) {
            //将起始时间一样的结束事件一起放到队列中
            while (i < events.length && events[i][0] == days) {
                queue.add(events[i][1]);
                i++;
            }
            //去除无效无法参加的会议
            while (!queue.isEmpty() && queue.peek() < days) {
                queue.remove();
            }
            if (!queue.isEmpty()) {
                queue.remove();
                res++;
            }
            days++;
        }
        return res;
    }
```
//先参加最早结束的会议，贪心思想
```
    public int maxEvents(int[][] events) {
        Set<Integer> set = new HashSet<>();
        Arrays.sort(events, (first, second) -> first[1]==second[1]?
                first[0]-second[0]:first[1]-second[1]);
        
        for(int[] event: events) {
            for(int i = event[0]; i<=event[1]; i++)
                if(set.add(i)) break;
        }
        return set.size();
    }
```

* 【703】设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。  

```
    public KthLargest(int k, int[] nums) {
        priorityQueue = new PriorityQueue<>(k);
        size = k;
        for (int num : nums) {
            add(num);
        }
    }

    PriorityQueue<Integer> priorityQueue;
    int size = 0;

    public int add(int val) {
        if (priorityQueue.size() < size) {
            priorityQueue.add(val);
        } else if (priorityQueue.peek() < val) {
            priorityQueue.poll();
            priorityQueue.add(val);
        }
        return priorityQueue.peek();
    }
```

* 【786】. 第 K 个最小的素数分数
给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数  组成，且其中所有整数互不相同。

对于每对满足 0 <= i < j < arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。

那么第 k 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 
  * 使用大顶堆

```
    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> Double.compare(b[0]*1.0/b[1],a[0]*1.0/a[1]));
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (priorityQueue.size() < k || priorityQueue.peek()[0] * 1.0/ priorityQueue.peek()[1] > arr[i]*1.0/arr[j]) {
                    if (priorityQueue.size() == k) {
                        priorityQueue.poll();
                    }
                    priorityQueue.offer(new int[]{arr[i], arr[j]});
                }
            }
        }
        return priorityQueue.peek();
    }
```