## 1. 概述

## 2. 经典题目 

* 【295】数据流的中位数
* 可以将数据分为左右两边，一边以最大堆的形式实现，可以快速获得左侧最大数， 另一边则以最小堆的形式实现。其中需要注意的一点就是左右侧数据的长度差不能超过1。 这种实现方式的效率与AVL平衡二叉搜索树的效率相近，但编写更快
```
    PriorityQueue<Integer> min;
    PriorityQueue<Integer> max;
    public MedianFinder() {
        max = new PriorityQueue<>((o1, o2) -> o2 - o1); // 大顶堆
        min = new PriorityQueue<>(); // 小顶堆
    }

    public void addNum(int num) {
        if (min.size() >= max.size()) {
            min.offer(num);// 往小顶堆加元素，一定会有一个更小的元素冒出来，需要平衡以下
            max.offer(min.poll());
        } else {
            max.offer(num);
            min.offer(max.poll());
        }
    }

    public double findMedian() {
        if (max.size() == min.size()) {
            return (max.peek() + min.peek()) / 2.0;
        } else if (max.size() > min.size()) {
            return max.peek();
        } else {
            return min.peek();
        }
    }
```