## 1. 概念  

## 2. 经典题目

* 【105】从前序与中序遍历序列构造二叉树
  * 使用Map保存前序遍历得值和下标映射关系
  * 利用中序遍历找到left的长度
  * 通过前序遍历的root+left找到下一个子树的位置
  * |root|--------------
  * ---------|root|----
  *         
  *         
```
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++) {
            inMap.put(inorder[i], i);
        }
        return buildTree(preorder, 0, preorder.length - 1, 0);
    }
    Map<Integer, Integer> inMap = new HashMap<>();
    private TreeNode buildTree(int[] preorder, int preLeft, int preRight, int inLeft) {
        if (preLeft > preRight) {
            return null;
        }
        int rootVal = preorder[preLeft], inRootIdx = inMap.get(rootVal);
        TreeNode rootNode = new TreeNode(rootVal);
        rootNode.left = buildTree(preorder, preLeft + 1, preLeft + inRootIdx - inLeft, inLeft);
        rootNode.right = buildTree(preorder, preLeft + inRootIdx - inLeft + 1, preRight, inRootIdx + 1);
        return rootNode;
    }
```

* 【98】给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 
  * 此题需要非常注意，二叉树时左子树的所有节点比它的根节点小，而不是左孩子节点和右孩子节点，所以需要不断的传入最小值或最大值
  * 或者全局记录一个中序遍历值，不断比较中序遍历的结果即可。

```
    //模拟法
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    public boolean isValidBST(TreeNode root, long lower, long upper) {
        if (root == null) {
            return true;
        }
        if (root.val <= lower) {
            return false;
        }
        if (root.val >= upper) {
            return false;
        }
        return isValidBST(root.left, lower, root.val) && isValidBST(root.right, root.val, upper);
    }
    //中序遍历法

       //中序遍历，增序， 优化
    Integer pre = null;
    public boolean isValidBST3(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST3(root.left) || (pre != null && pre >= root.val)) {
            return false;
        }
        pre = root.val;
        return isValidBST3(root.right);
    }
```

* 【958】给定一个二叉树，确定它是否是一个完全二叉树
  * 层序遍历
  * 如果遇到空的节点，说明后面和下面都不能再遇到非空节点了，否则为false
```
   public boolean isCompleteTree(TreeNode root) {
        if (root == null) {
            return true;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        boolean readNull = false;
        while (!deque.isEmpty()) {
            TreeNode node = deque.poll();
            if (node == null) {
                readNull = true;
            } else {
                if (readNull == true) {
                    return false;
                }
                deque.offer(node.left);
                deque.offer(node.right);
            }
        }
        return true;
    }
```

* 【243】给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点
  * 分治
  * 每个节点的左最大高度加上右边的最大高度，就是当前经过这个节点的宽度
  * 注意边界条件

```
    public int diameterOfBinaryTree(TreeNode root) {
        getMaxDeep(root);
        return max;
    }
    int max = 0;
    private int getMaxDeep(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMaxDeep = getMaxDeep(root.left), rightMaxDeep = getMaxDeep(root.right);
        max = Math.max(leftMaxDeep + rightMaxDeep, max);
        return Math.max(leftMaxDeep, rightMaxDeep) + 1;
    }
```

* 【110】给定一个二叉树，判断它是否是高度平衡的二叉树。 
```
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return Math.abs(getDeep(root.left) - getDeep(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }

    public int getDeep(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return Math.max(getDeep(root.left), getDeep(root.right)) +1;
    }
```

* 【208】Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查
  * 建立node的class
  * node持有26长度的数组
  * node持有是否为leaf
  * 每次word插入，遍历字符，如果字符对应的数组存在，说明有该字母，node指针指向新的node索引，以供下一个字符遍历插入
  * 不存在就创建新的，一共下一次遍历插入。
```
   public Trie() {
        root = new TrieNode();
    }
    class TrieNode {

        public char cur;

        public boolean isLeaf;

        public TrieNode[] children;

        public TrieNode(){
            children = new TrieNode[26];
        }
    }

    TrieNode root;

    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                node = new TrieNode();
                tries[c - 'a'] = node;
            }
        }
        node.isLeaf = true;
    }

    public boolean search(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                return false;
            }
        }
        return node.isLeaf;
    }

    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                return false;
            }
        }
        return true;
    }
```
* 【100】给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 
```
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p != null && q != null) {
            return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
        return false;
    }
```

* 【1302】给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和
  * 层序遍历
```
   public int deepestLeavesSum(TreeNode root) {
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.push(root);
        int num = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            num = 0;
            while (size-- > 0) {
                TreeNode node = deque.poll();
                num += node.val;
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return num;
    }
```
* 【Offer33】. 二叉搜索树的后序遍历序列
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

 
```
    public boolean verifyPostorder(int[] postorder) {
        return dfs(postorder, 0, postorder.length - 1);
    }

    private boolean dfs(int[] postorder, int i, int j) {
        if (i >= j) {
            return true;
        }
        int k = i;
        while (postorder[k] < postorder[j]) {
            k++;
        }
        int mid = k;
        while (postorder[k] > postorder[j]) {
            k++;
        }
        return k == j && dfs(postorder, i, mid - 1) && dfs(postorder, mid, j - 1);
    }
```


* 【701】二叉搜索树中的插入操作
给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果
```
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        if (root.val > val) {
            root.left = insertIntoBST(root.left, val);
        } else {
            root.right = insertIntoBST(root.right, val);
        }
        return root;
    }
```

* 【Offer 17】打印从1到最大的n位数  
  输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999
  * 考察了多叉树遍历
  * 层序打印
  * 大数不太可能使用int来进行存储会产生角标越界。
```
   public int[] printNumbers(int n) {
        ans = new int[(int) Math.pow(10, n) - 1];
        //从1到n位进行遍历输出。
        for (int i = 1; i <= n; i++) {
            dfs("", i);
        }
        return ans;
    }
    int[] ans;
    int idx;

    private void dfs(String s, int n) {
        if (n == 0) {
            ans[idx++] = Integer.parseInt(s);
            return;
        }
        for (int i = s.length() == 0 ? 1 : 0; i < 10; i++) {
            dfs(s + i, n - 1);
        }
    }
```

* 【108】给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树
  * BST的中序遍历是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树
  * 我们可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树
  * 以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树啦
  * 本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点
  * int mid = left + ((right - left) / 2)，这么些不容易int越界数值越，例如left和right都是最大int，(left + right) / 2这么操作就越界了
```
   public TreeNode sortedArrayToBST(int[] nums) {
        return buildTree(nums, 0, nums.length - 1);
    }
    private TreeNode buildTree(int[] nums, int i, int j) {
        if (i > j) {
            return null;
        }
        int mid = i + (j - i) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildTree(nums, i, mid - 1);
        root.right = buildTree(nums, mid + 1, j);
        return root;
    }
```


* 【951】翻转等价二叉树
我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。

只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。

编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。
```
   public boolean flipEquiv(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) {
            return true;
        }
        if (root1 == null || root2 == null) {
            return false;
        }
        if (root1.val == root2.val) {
            return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));
        }
        return false;
    }
```


* 【669】给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变

```
   public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) {
            return null;
        }
        if (root.val < low) {//小于下边界，说明左树已经没希望了
            return trimBST(root.right, low, high);
        }
        if (root.val > high) {//大于上边界，说明右边界已经没希望了
            return trimBST(root.left, low, high);
        }
        root.left = trimBST(root.left, low, high);//正常的节点
        root.right = trimBST(root.right, low, high);//正常的节点
        return root;
    }
```

* 【450】. 删除二叉搜索树中的节点
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它
  * 很巧妙，找到右边的最小值，然后指向左边节点即可

```
   public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) {
            return null;
        }
        if (root.val > key) {
            root.left = deleteNode(root.left, key);
        } else if (root.val < key) {
            root.right = deleteNode(root.right, key);
        } else {
            if (root.right == null) {
                return root.left;
            } else if (root.left == null) {
                return root.right;
            }
            TreeNode smaller = root.right;
            while (smaller.left != null) {
                smaller = smaller.left;
            }
            smaller.left = root.left;
            return root.right;
        }
        return root;
    }
```