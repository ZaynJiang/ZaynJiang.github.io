## 1. 概念  

## 2. 经典题目
* 【958】给定一个二叉树，确定它是否是一个完全二叉树
  * 层序遍历
  * 如果遇到空的节点，说明后面和下面都不能再遇到非空节点了，否则为false
```
   public boolean isCompleteTree(TreeNode root) {
        if (root == null) {
            return true;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        boolean readNull = false;
        while (!deque.isEmpty()) {
            TreeNode node = deque.poll();
            if (node == null) {
                readNull = true;
            } else {
                if (readNull == true) {
                    return false;
                }
                deque.offer(node.left);
                deque.offer(node.right);
            }
        }
        return true;
    }
```
* 【208】Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查
  * 建立node的class
  * node持有26长度的数组
  * node持有是否为leaf
  * 每次word插入，遍历字符，如果字符对应的数组存在，说明有该字母，node指针指向新的node索引，以供下一个字符遍历插入
  * 不存在就创建新的，一共下一次遍历插入。
```
   public Trie() {
        root = new TrieNode();
    }
    class TrieNode {

        public char cur;

        public boolean isLeaf;

        public TrieNode[] children;

        public TrieNode(){
            children = new TrieNode[26];
        }
    }

    TrieNode root;

    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                node = new TrieNode();
                tries[c - 'a'] = node;
            }
        }
        node.isLeaf = true;
    }

    public boolean search(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                return false;
            }
        }
        return node.isLeaf;
    }

    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                return false;
            }
        }
        return true;
    }
```
* 【100】给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 
```
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p != null && q != null) {
            return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
        return false;
    }
```

* 【1302】给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和
  * 层序遍历
```
   public int deepestLeavesSum(TreeNode root) {
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.push(root);
        int num = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            num = 0;
            while (size-- > 0) {
                TreeNode node = deque.poll();
                num += node.val;
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return num;
    }
```
* 【Offer33】. 二叉搜索树的后序遍历序列
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

 
```
    public boolean verifyPostorder(int[] postorder) {
        return dfs(postorder, 0, postorder.length - 1);
    }

    private boolean dfs(int[] postorder, int i, int j) {
        if (i >= j) {
            return true;
        }
        int k = i;
        while (postorder[k] < postorder[j]) {
            k++;
        }
        int mid = k;
        while (postorder[k] > postorder[j]) {
            k++;
        }
        return k == j && dfs(postorder, i, mid - 1) && dfs(postorder, mid, j - 1);
    }
```


* 【701】二叉搜索树中的插入操作
给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果
```
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        if (root.val > val) {
            root.left = insertIntoBST(root.left, val);
        } else {
            root.right = insertIntoBST(root.right, val);
        }
        return root;
    }
```