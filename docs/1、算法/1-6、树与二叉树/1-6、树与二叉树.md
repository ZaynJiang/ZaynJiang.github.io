## 1. 概念  

## 2. 经典题目
* 【958】给定一个二叉树，确定它是否是一个完全二叉树
  * 层序遍历
  * 如果遇到空的节点，说明后面和下面都不能再遇到非空节点了，否则为false
```
   public boolean isCompleteTree(TreeNode root) {
        if (root == null) {
            return true;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        boolean readNull = false;
        while (!deque.isEmpty()) {
            TreeNode node = deque.poll();
            if (node == null) {
                readNull = true;
            } else {
                if (readNull == true) {
                    return false;
                }
                deque.offer(node.left);
                deque.offer(node.right);
            }
        }
        return true;
    }
```
* 【208】Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查
  * 建立node的class
  * node持有26长度的数组
  * node持有是否为leaf
  * 每次word插入，遍历字符，如果字符对应的数组存在，说明有该字母，node指针指向新的node索引，以供下一个字符遍历插入
  * 不存在就创建新的，一共下一次遍历插入。
```
   public Trie() {
        root = new TrieNode();
    }
    class TrieNode {

        public char cur;

        public boolean isLeaf;

        public TrieNode[] children;

        public TrieNode(){
            children = new TrieNode[26];
        }
    }

    TrieNode root;

    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                node = new TrieNode();
                tries[c - 'a'] = node;
            }
        }
        node.isLeaf = true;
    }

    public boolean search(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                return false;
            }
        }
        return node.isLeaf;
    }

    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            TrieNode[] tries = node.children;
            node = tries[c - 'a'];
            if (node == null) {
                return false;
            }
        }
        return true;
    }
```
* 【100】给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 
```
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p != null && q != null) {
            return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
        }
        return false;
    }
```