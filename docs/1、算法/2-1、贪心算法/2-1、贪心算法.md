## 1. 概念


## 2. 经典题目
* 【3】给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度
  * 双指针
  * 最开始两个指针都指向0
  * 右指针开始一步步移动
  * 如果右指针发现数组存在该元素，则选取i和存在的作为最大树最为左指针
  * abc -> a[b]c[b] 第二个b作为左指针了
  * abc[b]  -> abc[b]ef[a] ，如果出现了a，即使a存在，左指针依然不 变，因为取i是取最大的
  * abcbef[a]xy[a]，，如果后面又出现了a则需要更新i了，因为i比位置比以前的远
```
public int lengthOfLongestSubstring(String s) {
    int[] check = new int[128];
    int res = 0;
    for (int i = 0, j = 0; j < s.length(); j++) {
        //说明当前j出现过
        i = check[s.charAt(j)] > 0 ? Math.max(check[s.charAt(j)], i) : i;
        check[s.charAt(j)] = j + 1;
        res = Math.max(res, j - i + 1);
    }
    return res;
}
  ```
* 【31】实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）
  * 贪心的思想，只有前面比后面小才可能交换成大的，找到这个小的后，需要找到最刚刚大的，然后交换，再排个序就好了
  * 从后往前找，找到刚刚比上一个小的元素记作下标i
  * 从后往前找，找到刚刚比i大的元素，交换
  * 将i+1后的元素升序，即是最小的

```
    public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        while (i >= 0) {
            if (i < nums.length - 1 && nums[i] < nums[i + 1]) {
                break;
            }
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j > i && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i+1, nums.length-1);
    }

    public void reverse(int[] nums, int lo, int hi) {
        while (lo < hi) {
            swap(nums, lo++, hi--);
        }
    }

    public void swap(int[] nums, int lo, int hi){
        if (lo == hi) {
            return;
        }
        int temp = nums[lo];
        nums[lo] = nums[hi];
        nums[hi] = temp;
    }
```


* 【76】给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串
  * 贪心算法、滚动窗口
  * 两个指针，右指针右移动，直到t中的字符全部覆盖
  * 左值针右移，直到停在第一个补全的位置
  * 记录较小的窗口大小和起始位置
  * 左值针右移一位，触发右指针移动
```
    public String minWindow(String s, String t) {
        int[] check = new int[128];
        for (int i = 0; i < t.length(); i++) {
            check[t.charAt(i)]++;
        }
        int left = 0, right = 0, count = t.length(), start = 0, windowLength = Integer.MAX_VALUE;
        while (right < s.length()) {
            if (check[s.charAt(right)] > 0) {
                count--;
            }
            check[s.charAt(right)]--;
            if (count == 0) {
                //左值针右移动，直到遇到包含的第一个的t字符
                while (left < right && check[s.charAt(left)] < 0) {
                    check[s.charAt(left)]++;
                    left++;
                }
                if (right - left + 1 < windowLength) {
                    windowLength = right - left + 1;
                    start = left;
                }
                check[s.charAt(left)]++;
                left++;
                count++;
            }
            right++;
        }
        return windowLength == Integer.MAX_VALUE ? "" : s.substring(start, start + windowLength);

    }
```