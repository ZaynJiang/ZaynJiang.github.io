## 1. 概念


## 2. 经典题目
* 【3】给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度
  * 双指针
  * 最开始两个指针都指向0
  * 右指针开始一步步移动
  * 如果右指针发现数组存在该元素，则选取i和存在的作为最大树最为左指针
  * abc -> a[b]c[b] 第二个b作为左指针了
  * abc[b]  -> abc[b]ef[a] ，如果出现了a，即使a存在，左指针依然不 变，因为取i是取最大的
  * abcbef[a]xy[a]，，如果后面又出现了a则需要更新i了，因为i比位置比以前的远
```
public int lengthOfLongestSubstring(String s) {
    int[] check = new int[128];
    int res = 0;
    for (int i = 0, j = 0; j < s.length(); j++) {
        //说明当前j出现过
        i = check[s.charAt(j)] > 0 ? Math.max(check[s.charAt(j)], i) : i;
        check[s.charAt(j)] = j + 1;
        res = Math.max(res, j - i + 1);
    }
    return res;
}
  ```
* 【31】实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）
  * 贪心的思想，只有前面比后面小才可能交换成大的，找到这个小的后，需要找到最刚刚大的，然后交换，再排个序就好了
  * 从后往前找，找到刚刚比上一个小的元素记作下标i
  * 从后往前找，找到刚刚比i大的元素，交换
  * 将i+1后的元素升序，即是最小的

```
    public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        while (i >= 0) {
            if (i < nums.length - 1 && nums[i] < nums[i + 1]) {
                break;
            }
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j > i && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i+1, nums.length-1);
    }

    public void reverse(int[] nums, int lo, int hi) {
        while (lo < hi) {
            swap(nums, lo++, hi--);
        }
    }

    public void swap(int[] nums, int lo, int hi){
        if (lo == hi) {
            return;
        }
        int temp = nums[lo];
        nums[lo] = nums[hi];
        nums[hi] = temp;
    }
```


* 【76】给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串
  * 贪心算法、滚动窗口
  * 两个指针，右指针右移动，直到t中的字符全部覆盖
  * 左值针右移，直到停在第一个补全的位置
  * 记录较小的窗口大小和起始位置
  * 左值针右移一位，触发右指针移动
```
    public String minWindow(String s, String t) {
        int[] check = new int[128];
        for (int i = 0; i < t.length(); i++) {
            check[t.charAt(i)]++;
        }
        int left = 0, right = 0, count = t.length(), start = 0, windowLength = Integer.MAX_VALUE;
        while (right < s.length()) {
            if (check[s.charAt(right)] > 0) {
                count--;
            }
            check[s.charAt(right)]--;
            if (count == 0) {
                //左值针右移动，直到遇到包含的第一个的t字符
                while (left < right && check[s.charAt(left)] < 0) {
                    check[s.charAt(left)]++;
                    left++;
                }
                if (right - left + 1 < windowLength) {
                    windowLength = right - left + 1;
                    start = left;
                }
                check[s.charAt(left)]++;
                left++;
                count++;
            }
            right++;
        }
        return windowLength == Integer.MAX_VALUE ? "" : s.substring(start, start + windowLength);

    }
```

* 【402】 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。 
  * 将string放入使用stringbuffer方便删除字符串
  * 贪心的思想，每次从左往右找到第一个大的一个数，删除
  * 需要及时校验字符串是否为空了
  * 需要每次校验是否有前导零
```
    public String removeKdigits(String num, int k) {
        //利用stringbuffer进行删除数据
        StringBuffer buffer = new StringBuffer(num);
        //按照k的次数，一次一次的删除从前往后找的第一个大的数字
        for (int i = 0; i < k; i++) {
            int idx = 0;
            //找到后一个数字大于前一个数字位置。即第一个大于的数字.
            for (int j = 1; j < buffer.length() && buffer.charAt(j) >= buffer.charAt(j-1); j++) {
                idx = j;
            }
            //删除这个数字
            buffer.delete(idx, idx + 1);
            //有可能删除完了，需要校验一下
            if (buffer.length() == 0) {
                return "0";
            }
            //删除前导0
            while (buffer.charAt(0) == '0' && buffer.length() > 1) {
                buffer.delete(0, 1);
            }
        }
        return buffer.toString();
    }
```


* 【209】 给定一个含有 n 个正整数的数组和一个正整数 target， 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0
  * 滑动窗口
  * 左边先增加，右边减少。
```
    public int minSubArrayLen(int target, int[] nums) {
        int lo = 0, hi = 0, len = Integer.MAX_VALUE;
        while (hi < nums.length) {
            target -= nums[hi++];
            while (lo < hi && target <= 0) {
                len = Math.min(len, hi - lo);
                target += nums[lo++];
            }
        }
        return len == Integer.MAX_VALUE ? 0 : len;
    }
```



* 【670】 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值
  * 记录每个数字最大出现的位置
  * 从头遍历如果发现有比大的小，就交换
```
    public int maximumSwap(int num) {
        char[] charArray = Integer.toString(num).toCharArray();
        int[] maxIdx = new int[10];
        //记录每个数字的最后一个出现的下标
        for (int i = 0; i < charArray.length; i++) {
            maxIdx[charArray[i] - '0'] = i;
        }
        for (int i = 0; i < charArray.length; i++) {
            //从高位遍历，1992132，
            //从最高的开始遍历
            for (int j = 9; j > charArray[i] - '0'; j--) {
                if (maxIdx[j] > i) {
                    char temp = charArray[maxIdx[j]];
                    charArray[maxIdx[j]] = charArray[i];
                    charArray[i] = temp;
                    return Integer.valueOf(new String(charArray));
                }
            }
        }
        return num;
    }
```

* 【11】给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水
  * 一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了 1。这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会
```
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, res = 0;
        while (left < right) {
            int lv = height[left], rv = height[right];
            if (lv < rv) {
                res = Math.max(lv * (right - left), res);
                left++;
            } else {
                res = Math.max(rv * (right - left), res);
                right--;
            }
        }
        return res;
    }

```



* 【135】老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。每个孩子至少分配到 1 个糖果，评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果
  * 从左到右，保存以左边对比，每个孩子至少的糖果
  * 以右到左，判断以右边对比，每个孩子至少的糖果
  * 取最大值。
```
    public int candy(int[] ratings) {
        int[] left = new int[ratings.length], right = new int[ratings.length];
        Arrays.fill(left, 1);
        Arrays.fill(right, 1);
        for (int i = 1; i < ratings.length; i++) {
            if (ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }
        int res = 0;
        for (int i = ratings.length - 1; i >= 0; i--) {
            if (i <  ratings.length - 1 && ratings[i] > ratings[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
            res += Math.max(left[i], right[i]);
        }
        return res;
    }
```

* 【556】给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。 
  * 贪心算法
  * 从后往前找到比后面小的元素，这样才可能有小数字
  * 然后从后往前找到刚刚比上一个元素大或相等的元素交换，那么交换后，一定是比前一个小后一个大的。
  * 对后续的元素反转一下就正好是结果了。
  * 注意题目要求可能会大于Integer的最大值，需要用Long判断结果

```
   public int nextGreaterElement(int n) {
        char[] chars = String.valueOf(n).toCharArray();
        if (chars.length <= 1) {
            return -1;
        }
        //从后往前找，刚刚比后一个小的点
        int i = chars.length - 2;
        while (i >= 0 && chars[i] >= chars[i + 1]) {
            i--;
        }
        if (i < 0) {
            return -1;
        }
        //找到刚好比i大的点作为交换的点
        int swapJoint = chars.length - 1;
        while (swapJoint > i && chars[swapJoint] <= chars[i]) {
            swapJoint--;
        }
        swap(chars, i, swapJoint);
        reverse(chars, i + 1, chars.length - 1);
        long res = Long.valueOf(String.valueOf(chars));
        return res > Integer.MAX_VALUE ? -1 : (int) res;
    }

    private void swap(char[] chars, int i, int j) {
        char temp = chars[i];
        chars[i] = chars[j];
        chars[j] = temp;
    }

    private void reverse(char[] chars, int i, int j) {
        while (i < j) {
            swap(chars, i++, j--);
        }
    }
```

* 【763】字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 
  *  先扫描一遍整个S，建立一个字典，字典的键是字母，值是这个字母最后一次出现的下标
  *  再线性扫描S，设置变量right 用于表示分隔开的子字符串的末尾在S里的下标，变量left表示子字符串的开头在S里的下标
  *  当前扫描的元素的最后一次出现的下标比right大，就说明子字符串还需要延长，就刷新right
  *  如果当前扫描的元素的下标已经达到了right，就说明这个子字符串完全已经找到了，就可以把答案添加到res中
```
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        for (int i = 0; i < s.length(); i++) {
            last[s.charAt(i) - 'a'] = i;
        }
        List<Integer> res = new ArrayList();
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, last[s.charAt(i) - 'a']);
            if (end == i) {
                res.add(end - start + 1);
                start = end + 1;
            }
        }
        return res;
    }
```

* 【134】在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空.如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 
  * 两个数组之差的总和必须大于等于0，否则不能完成绕行
  * 一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。
```
    public int canCompleteCircuit(int[] gas, int[] cost) {
        //总汽油消耗差，聚合消耗差，下标
        int total = 0, single = 0, idx = 0;
        for (int i = 0; i < cost.length; i++) {
            total += gas[i] - cost[i];//总和必须大于等于0，否则不能完成绕行
            single += gas[i] - cost[i];
            if (single < 0) {
                idx = i + 1;//一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个
                single = 0;// 还原到初始状态
            }
        }
        return total < 0 ? -1 : idx % gas.length ;
    }
```

* 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度.你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置
  * 当前节点能够触达的最远节点
  * 记录一个步数
  * 记录当前这一步能够移动位置
```
    public int jump(int[] nums) {
        int maxIdx = 0,/*当前节点能够触达的最远节点*/steps = 0, /*步数*/stepIdx = 0; /*当前移动位置*/
        for (int i = 0; i < nums.length - 1; i++) {
            maxIdx = Math.max(maxIdx, i + nums[i]);
            if (i == stepIdx) {
                steps++;
                stepIdx = maxIdx;
            }
        }
        return steps;
    }
```
* 【55】给定一个非负整数数组 nums ，你最初位于数组的 第一个下标
  * 不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。这个范围内，别管是怎么跳的，反正一定可以跳过来
  * 每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点
```
    public boolean canJump(int[] nums) {
        //2,3,1,1,4
        int maxIdx = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > maxIdx) {
                return false;
            }
            maxIdx = Math.max(maxIdx, i + nums[i]);
        }
        return true;
    }
```


* 【354】给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）
  * 如下面的注释
```
    [[1, 1], [2, 3], [4, 6], [4, 5], [6, 7]]
    Searching for height of 1
    Result of search: -1
    Inserting height at index: 0
    1 0 0 0 0 
    l is now 1
    Searching for height of 3
    Result of search: -2
    Inserting height at index: 1
    1 3 0 0 0 
    l is now 2
    Searching for height of 6
    Result of search: -3
    Inserting height at index: 2
    1 3 6 0 0 
    l is now 3
    Searching for height of 5
    Result of search: -3
    Inserting height at index: 2
    1 3 5 0 0 
    l is now 3
    Searching for height of 7
    Result of search: -4
    Inserting height at index: 3
    1 3 5 7 0 
    l is now 4
    Max number of envelopes: 4


    //方法1，贪心加二分查找
    public int maxEnvelopes(int[][] envelopes) {
        if (envelopes == null || envelopes.length == 0 || envelopes[0].length != 2) {
            return 0;
        }
        //先按照长度递增排序，如果长相等，则按照宽递减排序,如果是不是递减排序,相同的的长度如果遇到更高的宽度则会被认为是合适的宽度，这是不符合要求的，导致结果变多。
        Arrays.sort(envelopes, (e1, e2) -> e1[0] == e2[0] ? e2[1] - e1[1] : e1[0] - e2[0]);
        //记录递增序列的最后一个元素值，如[3,4,7]表示长度为1的递增序列最后一位为3，长度为2的递增序列最后一位为4，一次类推
        int[] tails = new int[envelopes.length];
        //递增序列的长度
        int len = 0;
        for (int[] envelope : envelopes) {
            int idx = Arrays.binarySearch(tails, 0, len, envelope[1]);
            //如果为负数则没找到，返回的时候要插入的下标的负数
            if (idx < 0) {
                idx = -(idx + 1);
            }
            //如果新的递增序列的最后一位的值
            tails[idx] = envelope[1];
            //如果递增子序列长度增加了，则len加1
            if (idx == len) {
                len++;
            }
        }
        return len;
    }
      //方法2,标准的动态规划
      public int maxEnvelopes(int[][] envelopes) {
        if (envelopes.length == 0) {
            return 0;
        }
        
        int n = envelopes.length;
        Arrays.sort(envelopes, new Comparator<int[]>() {
            public int compare(int[] e1, int[] e2) {
                if (e1[0] != e2[0]) {
                    return e1[0] - e2[0];
                } else {
                    return e2[1] - e1[1];
                }
            }
        });

        int[] f = new int[n];
        Arrays.fill(f, 1);
        int ans = 1;
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (envelopes[j][1] < envelopes[i][1]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
            ans = Math.max(ans, f[i]);
        }
        return ans;
    }
```

* 【1004】最大连续1的个数 III.给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。返回仅包含 1 的最长（连续）子数组的长度
  * 题意转化为找出一个最长的子数组，该子数组内最多允许有 K 个 0
  * 求最大连续子区间，可以使用滑动窗口方法。滑动窗口的限制条件是：窗口内最多有 K 个 0
  * 使用 leftleft 和 rightright 两个指针，分别指向滑动窗口的左右边界。
  * right 主动右移：rightright 指针每次移动一步。当 A[right]A[right] 为 00，说明滑动窗口内增加了一个 00
  * left 被动右移：判断此时窗口内 00 的个数，如果超过了 KK，则 leftleft 指针被迫右移，直至窗口内的 00 的个数小于等于 KK 为止
  * 滑动窗口长度的最大值就是所求
```
    public int longestOnes(int[] nums, int k) {
        int zeros = 0, lo = 0, hi = 0, res = 0;
        while (hi < nums.length) {
            if (nums[hi] == 0) {
                zeros++;
            }
            //保证滑动窗口中的0小于k的个数
            while (zeros > k) {
                if (nums[lo++] == 0) {
                    zeros--;
                }
            }
            //统计1的个数
            res = Math.max(res, hi - lo + 1);
            hi++;
        }
        return res;
    }
```

* 【567】给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。  换句话说，s1 的排列之一是 s2 的 子串
  * 滑动窗口
```
   public boolean checkInclusion(String s1, String s2) {
        int[] dict = new int[26], freq = new int[26];
        int size = 0;//统计s1字母的个数
        for (int i = 0; i < s1.length(); i++) {
            int c = s1.charAt(i) - 'a';
            if (dict[c] == 0) {
                size++;
            }
            dict[c]++;//记录s1每个字母的个数
        }
        int lo = 0, hi = 0, match = 0;
        while (hi < s2.length()) {
            int c = s2.charAt(hi) - 'a';
            freq[c]++;
            if (dict[c] == freq[c]) {//s2某一个字符的数量达到了s1的某一个字符的数量了。
                match++;
            }
            while (match == size) { //不符合匹配要求，需要从左收缩窗口,因为有可能字符不是s1数组的元素
                if (s1.length() == (hi - lo + 1)) {//s1所有字符数量都有了，且长度为滑动窗口长度，说明是连续的,符合要求
                    return true;
                }
                int lc = s2.charAt(lo++) - 'a';
                freq[lc]--;
                if (freq[lc] < dict[lc]) {//其它元素是大于dict的
                    match--;
                }
            }
            hi++;
        }
        return false;
    }
```