## 1. 概念


## 2. 经典题目
* 【3】给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度
  * 双指针
  * 最开始两个指针都指向0
  * 右指针开始一步步移动
  * 如果右指针发现数组存在该元素，则选取i和存在的作为最大树最为左指针
  * abc -> a[b]c[b] 第二个b作为左指针了
  * abc[b]  -> abc[b]ef[a] ，如果出现了a，即使a存在，左指针依然不 变，因为取i是取最大的
  * abcbef[a]xy[a]，，如果后面又出现了a则需要更新i了，因为i比位置比以前的远
```
public int lengthOfLongestSubstring(String s) {
    int[] check = new int[128];
    int res = 0;
    for (int i = 0, j = 0; j < s.length(); j++) {
        //说明当前j出现过
        i = check[s.charAt(j)] > 0 ? Math.max(check[s.charAt(j)], i) : i;
        check[s.charAt(j)] = j + 1;
        res = Math.max(res, j - i + 1);
    }
    return res;
}
  ```
* 【31】实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）
  * 贪心的思想，只有前面比后面小才可能交换成大的，找到这个小的后，需要找到最刚刚大的，然后交换，再排个序就好了
  * 从后往前找，找到刚刚比上一个小的元素记作下标i
  * 从后往前找，找到刚刚比i大的元素，交换
  * 将i+1后的元素升序，即是最小的

```
    public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        while (i >= 0) {
            if (i < nums.length - 1 && nums[i] < nums[i + 1]) {
                break;
            }
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j > i && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i+1, nums.length-1);
    }

    public void reverse(int[] nums, int lo, int hi) {
        while (lo < hi) {
            swap(nums, lo++, hi--);
        }
    }

    public void swap(int[] nums, int lo, int hi){
        if (lo == hi) {
            return;
        }
        int temp = nums[lo];
        nums[lo] = nums[hi];
        nums[hi] = temp;
    }
```


* 【76】给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串
  * 贪心算法、滚动窗口
  * 两个指针，右指针右移动，直到t中的字符全部覆盖
  * 左值针右移，直到停在第一个补全的位置
  * 记录较小的窗口大小和起始位置
  * 左值针右移一位，触发右指针移动
```
    public String minWindow(String s, String t) {
        int[] check = new int[128];
        for (int i = 0; i < t.length(); i++) {
            check[t.charAt(i)]++;
        }
        int left = 0, right = 0, count = t.length(), start = 0, windowLength = Integer.MAX_VALUE;
        while (right < s.length()) {
            if (check[s.charAt(right)] > 0) {
                count--;
            }
            check[s.charAt(right)]--;
            if (count == 0) {
                //左值针右移动，直到遇到包含的第一个的t字符
                while (left < right && check[s.charAt(left)] < 0) {
                    check[s.charAt(left)]++;
                    left++;
                }
                if (right - left + 1 < windowLength) {
                    windowLength = right - left + 1;
                    start = left;
                }
                check[s.charAt(left)]++;
                left++;
                count++;
            }
            right++;
        }
        return windowLength == Integer.MAX_VALUE ? "" : s.substring(start, start + windowLength);

    }
```

* 【402】 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。 
  * 将string放入使用stringbuffer方便删除字符串
  * 贪心的思想，每次从左往右找到第一个大的一个数，删除
  * 需要及时校验字符串是否为空了
  * 需要每次校验是否有前导零
```
    public String removeKdigits(String num, int k) {
        //利用stringbuffer进行删除数据
        StringBuffer buffer = new StringBuffer(num);
        //按照k的次数，一次一次的删除从前往后找的第一个大的数字
        for (int i = 0; i < k; i++) {
            int idx = 0;
            //找到后一个数字大于前一个数字位置。即第一个大于的数字.
            for (int j = 1; j < buffer.length() && buffer.charAt(j) >= buffer.charAt(j-1); j++) {
                idx = j;
            }
            //删除这个数字
            buffer.delete(idx, idx + 1);
            //有可能删除完了，需要校验一下
            if (buffer.length() == 0) {
                return "0";
            }
            //删除前导0
            while (buffer.charAt(0) == '0' && buffer.length() > 1) {
                buffer.delete(0, 1);
            }
        }
        return buffer.toString();
    }
```


* 【209】 给定一个含有 n 个正整数的数组和一个正整数 target， 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0
  * 滑动窗口
  * 左边先增加，右边减少。
```
    public int minSubArrayLen(int target, int[] nums) {
        int lo = 0, hi = 0, len = Integer.MAX_VALUE;
        while (hi < nums.length) {
            target -= nums[hi++];
            while (lo < hi && target <= 0) {
                len = Math.min(len, hi - lo);
                target += nums[lo++];
            }
        }
        return len == Integer.MAX_VALUE ? 0 : len;
    }
```



* 【670】 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值
  * 记录每个数字最大出现的位置
  * 从头遍历如果发现有比大的小，就交换
```
    public int maximumSwap(int num) {
        char[] charArray = Integer.toString(num).toCharArray();
        int[] maxIdx = new int[10];
        //记录每个数字的最后一个出现的下标
        for (int i = 0; i < charArray.length; i++) {
            maxIdx[charArray[i] - '0'] = i;
        }
        for (int i = 0; i < charArray.length; i++) {
            //从高位遍历，1992132，
            //从最高的开始遍历
            for (int j = 9; j > charArray[i] - '0'; j--) {
                if (maxIdx[j] > i) {
                    char temp = charArray[maxIdx[j]];
                    charArray[maxIdx[j]] = charArray[i];
                    charArray[i] = temp;
                    return Integer.valueOf(new String(charArray));
                }
            }
        }
        return num;
    }
```

* 【11】给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水
  * 一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了 1。这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会
```
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, res = 0;
        while (left < right) {
            int lv = height[left], rv = height[right];
            if (lv < rv) {
                res = Math.max(lv * (right - left), res);
                left++;
            } else {
                res = Math.max(rv * (right - left), res);
                right--;
            }
        }
        return res;
    }

```