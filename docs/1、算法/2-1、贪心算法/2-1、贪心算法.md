## 1. 概念


## 2. 经典题目
* 【3】给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度
  * 双指针
  * 最开始两个指针都指向0
  * 右指针开始一步步移动
  * 如果右指针发现数组存在该元素，则选取i和存在的作为最大树最为左指针
  * abc -> a[b]c[b] 第二个b作为左指针了
  * abc[b]  -> abc[b]ef[a] ，如果出现了a，即使a存在，左指针依然不 变，因为取i是取最大的
  * abcbef[a]xy[a]，，如果后面又出现了a则需要更新i了，因为i比位置比以前的远
```
public int lengthOfLongestSubstring(String s) {
    int[] check = new int[128];
    int res = 0;
    for (int i = 0, j = 0; j < s.length(); j++) {
        //说明当前j出现过
        i = check[s.charAt(j)] > 0 ? Math.max(check[s.charAt(j)], i) : i;
        check[s.charAt(j)] = j + 1;
        res = Math.max(res, j - i + 1);
    }
    return res;
}
  ```
* 【31】实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）
  * 贪心的思想，只有前面比后面小才可能交换成大的，找到这个小的后，需要找到最刚刚大的，然后交换，再排个序就好了
  * 从后往前找，找到刚刚比上一个小的元素记作下标i
  * 从后往前找，找到刚刚比i大的元素，交换
  * 将i+1后的元素升序，即是最小的

```
    public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        while (i >= 0) {
            if (i < nums.length - 1 && nums[i] < nums[i + 1]) {
                break;
            }
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j > i && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i+1, nums.length-1);
    }

    public void reverse(int[] nums, int lo, int hi) {
        while (lo < hi) {
            swap(nums, lo++, hi--);
        }
    }

    public void swap(int[] nums, int lo, int hi){
        if (lo == hi) {
            return;
        }
        int temp = nums[lo];
        nums[lo] = nums[hi];
        nums[hi] = temp;
    }
```


* 【76】给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串
  * 贪心算法、滚动窗口
  * 两个指针，右指针右移动，直到t中的字符全部覆盖
  * 左值针右移，直到停在第一个补全的位置
  * 记录较小的窗口大小和起始位置
  * 左值针右移一位，触发右指针移动
```
    public String minWindow(String s, String t) {
        int[] check = new int[128];
        for (int i = 0; i < t.length(); i++) {
            check[t.charAt(i)]++;
        }
        int left = 0, right = 0, count = t.length(), start = 0, windowLength = Integer.MAX_VALUE;
        while (right < s.length()) {
            if (check[s.charAt(right)] > 0) {
                count--;
            }
            check[s.charAt(right)]--;
            if (count == 0) {
                //左值针右移动，直到遇到包含的第一个的t字符
                while (left < right && check[s.charAt(left)] < 0) {
                    check[s.charAt(left)]++;
                    left++;
                }
                if (right - left + 1 < windowLength) {
                    windowLength = right - left + 1;
                    start = left;
                }
                check[s.charAt(left)]++;
                left++;
                count++;
            }
            right++;
        }
        return windowLength == Integer.MAX_VALUE ? "" : s.substring(start, start + windowLength);

    }
```

* 【402】 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。 
  * 将string放入使用stringbuffer方便删除字符串
  * 贪心的思想，每次从左往右找到第一个大的一个数，删除
  * 需要及时校验字符串是否为空了
  * 需要每次校验是否有前导零
```
    public String removeKdigits(String num, int k) {
        //利用stringbuffer进行删除数据
        StringBuffer buffer = new StringBuffer(num);
        //按照k的次数，一次一次的删除从前往后找的第一个大的数字
        for (int i = 0; i < k; i++) {
            int idx = 0;
            //找到后一个数字大于前一个数字位置。即第一个大于的数字.
            for (int j = 1; j < buffer.length() && buffer.charAt(j) >= buffer.charAt(j-1); j++) {
                idx = j;
            }
            //删除这个数字
            buffer.delete(idx, idx + 1);
            //有可能删除完了，需要校验一下
            if (buffer.length() == 0) {
                return "0";
            }
            //删除前导0
            while (buffer.charAt(0) == '0' && buffer.length() > 1) {
                buffer.delete(0, 1);
            }
        }
        return buffer.toString();
    }
```


* 【209】 给定一个含有 n 个正整数的数组和一个正整数 target， 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0
  * 滑动窗口
  * 左边先增加，右边减少。
```
    public int minSubArrayLen(int target, int[] nums) {
        int lo = 0, hi = 0, len = Integer.MAX_VALUE;
        while (hi < nums.length) {
            target -= nums[hi++];
            while (lo < hi && target <= 0) {
                len = Math.min(len, hi - lo);
                target += nums[lo++];
            }
        }
        return len == Integer.MAX_VALUE ? 0 : len;
    }
```



* 【670】 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值
  * 记录每个数字最大出现的位置
  * 从头遍历如果发现有比大的小，就交换
```
    public int maximumSwap(int num) {
        char[] charArray = Integer.toString(num).toCharArray();
        int[] maxIdx = new int[10];
        //记录每个数字的最后一个出现的下标
        for (int i = 0; i < charArray.length; i++) {
            maxIdx[charArray[i] - '0'] = i;
        }
        for (int i = 0; i < charArray.length; i++) {
            //从高位遍历，1992132，
            //从最高的开始遍历
            for (int j = 9; j > charArray[i] - '0'; j--) {
                if (maxIdx[j] > i) {
                    char temp = charArray[maxIdx[j]];
                    charArray[maxIdx[j]] = charArray[i];
                    charArray[i] = temp;
                    return Integer.valueOf(new String(charArray));
                }
            }
        }
        return num;
    }
```

* 【11】给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水
  * 一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了 1。这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会
```
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, res = 0;
        while (left < right) {
            int lv = height[left], rv = height[right];
            if (lv < rv) {
                res = Math.max(lv * (right - left), res);
                left++;
            } else {
                res = Math.max(rv * (right - left), res);
                right--;
            }
        }
        return res;
    }

```



* 【135】老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。每个孩子至少分配到 1 个糖果，评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果
  * 从左到右，保存以左边对比，每个孩子至少的糖果
  * 以右到左，判断以右边对比，每个孩子至少的糖果
  * 取最大值。
```
    public int candy(int[] ratings) {
        int[] left = new int[ratings.length], right = new int[ratings.length];
        Arrays.fill(left, 1);
        Arrays.fill(right, 1);
        for (int i = 1; i < ratings.length; i++) {
            if (ratings[i] > ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }
        int res = 0;
        for (int i = ratings.length - 1; i >= 0; i--) {
            if (i <  ratings.length - 1 && ratings[i] > ratings[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
            res += Math.max(left[i], right[i]);
        }
        return res;
    }
```

* 【556】给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。 
  * 贪心算法
  * 从后往前找到比后面小的元素，这样才可能有小数字
  * 然后从后往前找到刚刚比上一个元素大或相等的元素交换，那么交换后，一定是比前一个小后一个大的。
  * 对后续的元素反转一下就正好是结果了。
  * 注意题目要求可能会大于Integer的最大值，需要用Long判断结果

```
   public int nextGreaterElement(int n) {
        char[] chars = String.valueOf(n).toCharArray();
        if (chars.length <= 1) {
            return -1;
        }
        //从后往前找，刚刚比后一个小的点
        int i = chars.length - 2;
        while (i >= 0 && chars[i] >= chars[i + 1]) {
            i--;
        }
        if (i < 0) {
            return -1;
        }
        //找到刚好比i大的点作为交换的点
        int swapJoint = chars.length - 1;
        while (swapJoint > i && chars[swapJoint] <= chars[i]) {
            swapJoint--;
        }
        swap(chars, i, swapJoint);
        reverse(chars, i + 1, chars.length - 1);
        long res = Long.valueOf(String.valueOf(chars));
        return res > Integer.MAX_VALUE ? -1 : (int) res;
    }

    private void swap(char[] chars, int i, int j) {
        char temp = chars[i];
        chars[i] = chars[j];
        chars[j] = temp;
    }

    private void reverse(char[] chars, int i, int j) {
        while (i < j) {
            swap(chars, i++, j--);
        }
    }
```

* 【763】字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 
  *  先扫描一遍整个S，建立一个字典，字典的键是字母，值是这个字母最后一次出现的下标
  *  再线性扫描S，设置变量right 用于表示分隔开的子字符串的末尾在S里的下标，变量left表示子字符串的开头在S里的下标
  *  当前扫描的元素的最后一次出现的下标比right大，就说明子字符串还需要延长，就刷新right
  *  如果当前扫描的元素的下标已经达到了right，就说明这个子字符串完全已经找到了，就可以把答案添加到res中
```
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        for (int i = 0; i < s.length(); i++) {
            last[s.charAt(i) - 'a'] = i;
        }
        List<Integer> res = new ArrayList();
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, last[s.charAt(i) - 'a']);
            if (end == i) {
                res.add(end - start + 1);
                start = end + 1;
            }
        }
        return res;
    }
```

* 【134】在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空.如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 
  * 两个数组之差的总和必须大于等于0，否则不能完成绕行
  * 一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。
```
    public int canCompleteCircuit(int[] gas, int[] cost) {
        //总汽油消耗差，聚合消耗差，下标
        int total = 0, single = 0, idx = 0;
        for (int i = 0; i < cost.length; i++) {
            total += gas[i] - cost[i];//总和必须大于等于0，否则不能完成绕行
            single += gas[i] - cost[i];
            if (single < 0) {
                idx = i + 1;//一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个
                single = 0;// 还原到初始状态
            }
        }
        return total < 0 ? -1 : idx % gas.length ;
    }
```