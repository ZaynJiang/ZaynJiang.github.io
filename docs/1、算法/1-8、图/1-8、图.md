## 1. 概述   
## 2. 经典题目  
* 【207】你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 .请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。   
* 统计每个课被指向次数，初始被指向次数为0的肯定是安全的（不在环上）。
  * 每被安全课程指向一次，被指次数减一，
  * 如果被指次数减到0，说明该课程全部指向都来自安全课程，则它也是安全的。
  * 依此进行队列循环。 
```
    //[[1,0],[0,1]]
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] inDegree = new int[numCourses];
        Deque<int[]> deque = new ArrayDeque<>();
        //统计每门课程被指向了多少次（需要该课程先学完）
        for (int[] prerequisite : prerequisites) {
            inDegree[prerequisite[1]]++;
            deque.offer(prerequisite);
        }
        while (!deque.isEmpty()) {
            int size = deque.size(), loopSize = size;
            while (loopSize-- > 0) {
                int[] preInfo = deque.poll();
                //如果要需要的课程的入度为0
                if (inDegree[preInfo[0]] == 0) {
                    //说明是安全的，可以减去前置条件
                    inDegree[preInfo[1]]--;
                } else {
                    deque.offer(preInfo);
                }
            }
            if (size == deque.size()) {
                return false;
            }
        }
        return true;
    }
```

* 【210】现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。 
  * 统计入度大于等于1的
  * 将入度为0的放入队列作为第一波
```
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] inDegree = new int[numCourses];
        for (int[] prerequisite : prerequisites) {
            inDegree[prerequisite[0]]++;
        }
        Deque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
               deque.offer(i);
            }
        }
        int[] res = new int[numCourses];
        int idx = 0;
        while (!deque.isEmpty()) {
            int cur = deque.poll();
            res[idx++] = cur;
            for (int[] prerequisite : prerequisites) {
                if (prerequisite[1] == cur && --inDegree[prerequisite[0]] == 0) {
                    deque.offer(prerequisite[0]);
                }
            }

        }
        return idx != numCourses ? new int[]{} : res;
    }
```

* 【331】序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录.上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点.给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 "1,,3" 。
  * 基于一个性质：所有节点的入度之和等于出度之和
  * 初始为1是为了在加入根节点的时候，diff 先减去 1（入度），再加上 2（出度），此时 diff 正好应该是2.
```
 public boolean isValidSerialization(String preorder) {
        int diff = 1;//出度减去入度的差值,是为了在加入根节点的时候，diff 先减去 1（入度），再加上 2（出度），此时 diff 正好应该是2.
        for (String c : preorder.split(",")) {
            diff--;//遍历第一个字符串，一定有一个入度，减去入度的值
            if (diff < 0) {
                return false;
            }
            diff += (c.equals("#") ? 0 : 2);//加上出度的值
        }
        return diff == 0;
    }
```

* 【133】给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）
  * 和之前的随机数拷贝一样
  * 需要注意，需要提前将node放入cahche中
```
    Map<Integer, Node> cache = new HashMap<>();
    public Node cloneGraph(Node node) {
        if (node == null) {
            return node;
        }
        Node newNode = cache.get(node.val);
        if (newNode != null) {
            return newNode;
        }
        newNode = new Node(node.val);
        cache.put(newNode.val, newNode);
        for (Node neighbor : node.neighbors) {
            newNode.neighbors.add(cloneGraph(neighbor));
        }
        return newNode;
    }
```

* 【】存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u]。是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：
  不存在自环（graph[u] 不包含 u）。 
不存在平行边（graph[u] 不包含重复值）。 
如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图） 
这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。 
二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称
 二分图 。 
如果图是二分图，返回 true ；否则，返回 false 。 
* 我们任选一个节点开始，将其染成红色，并从该节点开始对整个无向图进行遍历；
* 在遍历的过程中，如果我们通过节点 uu 遍历到了节点 vv（即 uu 和 vv 在图中有一条边直接相连），那么会有两种情况
  * 如果 vv 未被染色，那么我们将其染成与 uu 不同的颜色，并对 vv 直接相连的节点进行遍历
  * 如果 vv 被染色，并且颜色与 uu 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 \text{False}False 作为答案
* 当遍历结束时，说明给定的无向图是二分图，返回 \text{True}True 作为答案 
```
    public boolean isBipartite(int[][] graph) {
        int[] colors = new int[graph.length];
        for (int i = 0; i < graph.length; i++) {
            if (colors[i] == 0 && !dfs(graph, colors, i, 1)) {
                return false;
            }
        }
        return true;
    }

    private boolean dfs(int[][] graph,  int[] colors, int i, int color) {
        if (colors[i] != 0) {
            //如果染色相同，为真
            return colors[i] == color;
        }
        colors[i] = color;
        for (int nei : graph[i]) {
            //如果染色不同，则直接返回
            if (!dfs(graph, colors, nei, -color)) {
                return false;
            }
        }
        return true;
    }
```