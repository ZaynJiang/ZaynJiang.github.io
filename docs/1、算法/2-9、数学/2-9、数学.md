## 1. 开头
## 2. 经典题目

* 【Offer 62】圆圈中最后剩下的数字
0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
![](环形数组删除问问题.png)
```
    /*
    思路：使用数学方法(先举例)
            你要知道最后的结果是3，带着结果去看问题

        第一次，【0, 1, 2, 3, 4】，本轮要踢出2                                  看3
        (下一轮开始从3计数，为了方便读者看出规律，将开始计数的那一位移到开头)
        第二次，【3, 4, 0, 1】，本轮要踢出0                                     看1
        第三次，【1, 3, 4】，本轮要踢出4                                        看1
        第四次，【1, 3】 本轮要踢出1                                            看3
        第五次，【3】
        最后返回3

        我们要使用的数学方法，就是从结果0号位置，反推最开始在哪
        你从第二次，向上看第一次
        你会发现，原来3在0的位置
                现在，3在(0 + 3) % 5
                        => +3 回到上次的位置
                        => %5 防止数组溢出，并且数组本来就是循环数组

        f(n) = ( f(n - 1) + m ) % n
        解释意思：
            f(n) 表示上一次
            f(n - 1) 表示这次，因为我们要从这次回推上一次
            m 表示隔几个
            n表示上一次的数组长度

     */
  public int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
```

* 【204】 计数质数
  统计所有小于非负整数 n 的质数的数量
  * 对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x\cdot xx⋅x 开始标记，因为 2x,3x,\ldots2x,3x,… 这些数一定在 xx 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等
  * 当然这里还可以继续优化，对于一个质数x，如果按上文说的我们从2x开始标记其实是冗余的，应该直接从x*x开始标记，因为2.x , 3.x , ....这些数一定在x之前就被其他数的倍数标记过了，例如2的所有倍数，3的所有倍数等。
```
    public int countPrimes(int n) {
        int ans = 0;
        boolean[] check = new boolean[n];
        for (int i = 2; i < n; i++) {
            if (!check[i]) {
                ans++;
                if ((long) i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        check[j] = true;
                    }
                }
            }
        }
        return ans;
    }
```

* 【9】回文数
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数
```
  public boolean isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        if (x == 0) {
            return true;
        }
        int n = 0, y = x;
        while (x != 0) {
            n = n * 10 + x % 10;
            x /= 10;
        }
        return y == n;
    }
```

* 【1363】. 形成三的最大倍数
给你一个整数数组 digits，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。

由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。

如果无法得到答案，请返回一个空字符串

  * 如果取模3等于0，那其实可以都要，如果是1，那就得去掉一个1或者两个2，如果是2那就得去掉一个2或者两个1
  * 而这些删掉一个数的函数其实是类似的，可以反复调用。注意在如果全是0输出0而不是00000. 删完数之后判断答案的最高位是不是0即可


https://leetcode.com/problems/largest-multiple-of-three/discuss/518830/C%2B%2BJava-Concise-O(n)


```
/**
显然，尝试数字组合是行不通的，因为我们最多可以有 10,000 个数字。幸运的是，有一个方便的可分性测试：

如果一个数的所有数字之和能被 3 整除，则该数能被 3 整除。

观察 1：由于顺序无关紧要，最大的数可以通过从最大 ( 9) 到最小 ( 0) 的数字相加来形成，例如9999966330000。

因此，我们可以只计算每个数字的出现次数，然后生成字符串。

观察 2：我们需要使用所有数字来形成最大数。如果我们对所有数字求和，并且 3 的模不为零，我们需要删除 1（最好）或 2 个最小的数字。例如，如果和的模 3 是1，我们将尝试删除1、4或7（如果存在）或 、 或2的5两个8。

更多示例：

9965341 % 3 == 1; 我们删除1以获得最大的数字。
9952000 % 3 == 1; 现在我们需要删除两个数字2和5，因为没有1,4或7
*/

public String largestMultipleOfThree(int[] digits) {
    int m1[] = new int[] {1, 4, 7, 2, 5, 8}, m2[] = new int[] {2, 5, 8, 1, 4, 7};
    int sum = 0, ds[] = new int[10];
    for (int d : digits) {
        ++ds[d];
        sum += d;
    }
    while (sum % 3 != 0) {
        for (int i : sum % 3 == 1 ? m1 : m2) {
          if (ds[i] > 0) {
            --ds[i];
            sum -= i;
            break;
          }
        }
      }
    StringBuilder sb = new StringBuilder();
    for (int i = 9; i >= 0; --i)
        sb.append(Character.toString('0' + i).repeat(ds[i]));     
    return sb.length() > 0 && sb.charAt(0) == '0' ? "0" : sb.toString();
}
```


* 【1201】. 丑数 III
给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。

丑数是可以被 a 或 b 或 c 整除的 正整数
  * 使用了容斥原理  
  * 二分法
![](容斥原理.png) 

```
    public int nthUglyNumber(int n, int a, int b, int c) {
        long ab = (long) a * (long) b / gcd(a, b);
        long ac = (long) a * (long) c / gcd(a, c);
        long bc = (long) b * (long) c / gcd(b, c);
        long abc = (long) a * bc / gcd(bc, a);
        long lo = 1, hi = (long) 2e9;
        while (lo < hi) {
            long mid = lo + (hi - lo) / 2;
            long val = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;
            if (val < n) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        return (int) lo;
    }


    //求最大公约数，比如6，4为2
    //2，3为1
    public long gcd(long x, long y) {
        if (x == 0) return y;
        return gcd(y % x, x);
    }
```

```
  //该方法思路可以借鉴，但是结果不对,有可能重复
   public int nthUglyNumber(int n, int a, int b, int c) {
        int[] dp = new int[n + 1];
        for (int i = 1, a1 = 1, b1 = 1, c1 = 1; i <= n; i++) {
            int next = Math.min(c * c1, Math.min(a * a1, b * b1));
            dp[i] = next;
            if (next == c * c1) {
                c1++;
            }
            if (next == b * b1) {
                b1++;
            }
            if (next == a * a1) {
                a1++;
            }
        }
        return dp[n];
    }
```





* 【1104】二叉树寻路,在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。

如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；

而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。



给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的

```
    /**
Normally Ordered Binary Tree:
             1
           /   \
         2       3
       /  \     /  \
     4     5   6     7
   / |    /|   |\    | \
 8   9  10 11 12 13  14  15


 Zig Zag Binary Tree:
             1
           /   \
         3       2  <- 3+2-3 = 2/2 = 1
       /  \     /  \
     4     5   6     7   <- 7+4-4 = 7/2 = 3
   / |    /|   |\    | \
 15 14  13 12 11 10  9  8   <- 15+8-14 = 9/2 = 4

 反演公式：（当前级别的最大数量 + 当前级别的最小数量）- 当前数量
例如要找到 14 的反演： 15 + 8 - 14 = 9
从这里你只需将 9 除以 2 即可找到父 4

想法 3）您必须在每个级别运行反转公式，因为在每个级别，该行都相对于前一行反转
    */
    public List<Integer> pathInZigZagTree(int label) {
        int level = 1, maxCount = 1;
        while (maxCount * 2 <= label) {
            maxCount *= 2;
            level++;
        }
        List<Integer> res = new LinkedList<>();
        while (label > 0) {
            res.add(label);
            int curLevelMax = (int) Math.pow(2, level) - 1,  curLevelMin = (int) Math.pow(2, level - 1) ;
            label = (curLevelMax + curLevelMin - label)/2;
            level--;
        }
        Collections.reverse(res);
        return res;
    }
```

* 【932】. 漂亮数组
对于某些固定的 N，如果数组 A 是整数 1, 2, ..., N 组成的排列，使得：

对于每个 i < j，都不存在 k 满足 i < k < j 使得 A[k] * 2 = A[i] + A[j]。

那么数组 A 是漂亮数组。


给定 N，返回任意漂亮数组 A（保证存在一个）

```
/* A 是漂亮数组，则 a * A + b 也是漂亮数组 
 * A 为奇数漂亮数组，B 为偶数漂亮数组，A + B 为漂亮数组
 * 数组两两配对，左数组 * 2 - 1 一定是奇数组，右数组 * 2 一定为偶数组，合并一定为漂亮数组
 * 假设 [1] 是最小漂亮数组，按照上面规律递推得到的一定是漂亮数组。 
 * |1|1|1|1|1|1|1|1|
 * |1 2|1 2|1 2|1 2|
 * |1 3 2 4|1 3 2 4|
 * |1 5 3 7 2 6 4 8|
 */

class Solution {
    public int[] beautifulArray(int N) {
        int[] a = new int[N];
        Arrays.fill(a, 1);
        part(a, 0, N - 1);
        return a;
    }
    public void part(int[] a, int lo, int hi) {
        if (hi <= lo) return;
        int mid = lo + (hi - lo) / 2;
        part(a, lo, mid);
        part(a, mid + 1, hi);
        for (int i = lo; i <= mid; i++) {
            a[i] = 2 * a[i] - 1;
        } 
        for (int i = mid + 1; i <= hi; i++) {
            a[i] = 2 * a[i];
        }
        return;
    }
}
```

* 【313】. 超级丑数
超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。

给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。

题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内  
![](丑数分析.png) 


```
   public int nthSuperUglyNumber(int n, int[] primes) {
        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((o1, o2) -> o1[0] - o2[0]);
        for (int i = 0; i < primes.length; i++) {
            priorityQueue.add(new int[]{primes[i], i, 0});
        }
        int[] ans = new int[n];
        ans[0] = 1;
        for (int j = 1; j < n; ) {
            int[] min = priorityQueue.poll();
            if (min[0] != ans[j - 1]) {
                ans[j++] = min[0];
            }
            priorityQueue.offer(new int[]{primes[min[1]] * ans[min[2] + 1], min[1], min[2] + 1});
        }
        return ans[n - 1];
    }
```



* 【829】. 连续整数求和
给定一个正整数 n，返回 连续正整数满足所有数字之和为 n 的组数 
```
    public int consecutiveNumbersSum(int n) {
        int ans = 0;
        for (int i = 1; n > 0; n -= i++) {
            ans +=  (n % i == 0 ? 1 : 0);
        }
        return ans;
    }
```
参考
```
    def consecutiveNumbersSum(self, N: int) -> int:
        # 1个数时，必然有一个数可构成N
        # 2个数若要构成N，第2个数与第1个数差为1，N减掉这个1能整除2则能由商与商+1构成N
        # 3个数若要构成N，第2个数与第1个数差为1，第3个数与第1个数的差为2，N减掉1再减掉2能整除3则能由商、商+1与商+2构成N
        # 依次内推，当商即第1个数小于等于0时结束
        res, i = 0, 1
        while N > 0:
            res += N % i == 0
            N -= i
            i += 1
        return res

```


* 【172】. 阶乘后的零
给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
/*
    求n!
    0的来源 2 * 5 所以一对2和5即可产生一个0,所以0的个数即为min(阶乘中5的个数和2的个数) 
    又因为是2的倍数的数一定比是5的倍数的数多 所以2的个数一定>=5的个数 所以只需要统计 5 的个数了
    例如 5！ = 1 * 2 * 3 * 4 * 5
                  2      2 2  5    一个2和一个5配对出现0 所以5!末尾只有一个零
        而在 n = 25 时 可以产生5的有 5 10 15 20 25 
                                    即 n/5 = 5个 然鹅 25 = 5*5 所以少算了一个5 
        n>=25时,故而需要补上它 因此所有可以产生25的也要加上 
                                    即为 n/5 + n/25  然鹅 125 = 5*25 所以又少算了一个5
        n>=125时,故而需要补上它 因此所有可以产生125的也要加上
                                    即为 n/5 + n/25 + n/125  然鹅 625 = 5*125 所以又少算了一个5
        继续补上...
        所以最终为 n/5 + n/25 + n/125 + n/625 + ... 
                即 n/5 + n/5/5 + n/5/5/5 + n/5/5/5/5 + ... 
        代码如下
    */

```
    public int trailingZeroes(int n) {
        int ans = 0;
        while (n >= 5) {
            ans += (n/=5);
        }
        return ans;
    }
```



【396】旋转函数

难度中等221收藏分享切换为英文接收动态反馈

给定一个长度为 `n` 的整数数组 `nums` 。

假设 `arrk` 是数组 `nums` 顺时针旋转 `k` 个位置后的数组，我们定义 `nums` 的 **旋转函数** `F` 为：

- `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]`

返回 *`F(0), F(1), ..., F(n-1)`中的最大值* 。

生成的测试用例让答案符合 **32 位** 整数。

```
      /*

F(0) =            (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6)      1式
                -----------------------------
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2)                 2式
                -----------------------------

        2式画线部分 - 1式画线部分 = sum - arr[n - 1]

F(1) - F(0) = sum - arr[n - 1] - (n - 1) * arr[n - 1]
            = sum - n * arr[n - 1]

F(1) = F(0) + sum - n * arr[n - 1]

F(k) = F(k - 1) + sum - n * arr[n - k]

*/
   public int maxRotateFunction(int[] nums) {
        int sum = Arrays.stream(nums).sum(), pre = 0, n = nums.length;
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i] * i;
        }
        int ans = pre;
        for (int i = 1; i <= n; i++) {
            pre = pre + sum - n * nums[n - i];
            ans = Math.max(ans, pre);
        }
        return ans;
    }
```

