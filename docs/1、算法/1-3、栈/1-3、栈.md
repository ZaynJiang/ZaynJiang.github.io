## 1. 概念

## 2. 经典题目
* 【42】给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
  * 当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明可能会有积水
  * 当墙大于栈顶的高度，说明可以接水了
  * 取出上一面墙取最小者计算可以接的水
  * 需要注意理解计算宽度(i - deque.peek() - 1)
```
    public int trap(int[] heights) {
        if (heights == null || heights.length <= 1) {
            return 0;
        }
        int total = 0;
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < heights.length; i++) {
            //如果当前矩形高于栈顶的,则说明有雨水可接
            while (!deque.isEmpty() && heights[i] > heights[deque.peek()]) {
                //取出栈顶的代表底部矩形
                int bottomIdx = deque.pop();
                //如果栈中无矩形，说明无水可接
                if (deque.isEmpty()) {
                    break;
                }
                //取与上一个的最低的矩形作为高
                int height = Math.min(heights[i], heights[deque.peek()]) - heights[bottomIdx];
                //计算宽乘以高得出面积为水
                total += (i - deque.peek() - 1) * height;
            }
            deque.push(i);
        }
        return total;
    }
```

* 【155】设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 
  * 方法1
  * 两个栈
  * 一个最小栈，代表当前栈的最小值
  * 每次入栈都会比较一下
  * 方法2
  * 顺序队列（PriorityQueue）
```
    //方法1
    public MinStack() {
        deque = new ArrayDeque<Integer>();
        minDeque = new ArrayDeque<>();
        minDeque.push(Integer.MAX_VALUE);
    }

    Deque<Integer> deque;
    Deque<Integer> minDeque;

    public void push(int val) {
        deque.push(val);
        minDeque.push(Math.min(minDeque.peek(), val));
    }

    public void pop() {
        deque.pop();
        minDeque.pop();
    }

    public int top() {
        return deque.peek();
    }

    public int getMin() {
        return minDeque.peek();
    }

     //方法2
        Stack<Integer> vals;
    PriorityQueue<Integer> priorityQueue;
    /** initialize your data structure here. */
    public MinStack() {
        vals = new Stack<>();
        priorityQueue = new PriorityQueue<Integer>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        });
    }

    public void push(int val) {
        Integer isert = Integer.valueOf(val);
        vals.add(isert);
        priorityQueue.offer(isert);
    }

    public void pop() {
        Integer inte =  vals.pop();
        priorityQueue.remove(inte);
    }

    public int top() {
        return vals.peek();
    }

    public int getMin() {
        return priorityQueue.peek();
    }
```

* 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 
  * 栈
  * 直接看以下两种解法

```
    //模拟法
    public boolean isValid(String s) {
        Deque<Character> deque = new ArrayDeque<>();
        for (int i = 0; i < s.length(); i++) {
            char cur = s.charAt(i);
            if (cur == ')') {
                if (deque.isEmpty() || deque.pollFirst() != '(') {
                    return false;
                }
            } else if (cur == '}') {
                if (deque.isEmpty() || deque.pollFirst() != '{') {
                    return false;
                }
            } else if (cur == ']') {
                if (deque.isEmpty() || deque.pollFirst() != '[') {
                    return false;
                }
            } else {
                deque.push(cur);
            }
        }
        return deque.isEmpty();
    }

    //优雅解法
    public boolean isValid(String s) {
        if (s.length() % 2 != 0) {
            return false;
        }
        Deque<Character> deque = new ArrayDeque<>();
        for (char c : s.toCharArray()) {
            if (c == '(') {
                deque.push(')');
            } else if (c == '{') {
                deque.push('}');
            } else if (c == '[') {
                deque.push(']');
            } else {
                if (deque.isEmpty() || deque.pop() != c) {
                    return false;
                }
            }
        }
        return true;
    }
```


* 【232】请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）
  * 两个栈
  * 取的时候，从输出栈取，没有的话从输入栈中取出来
```
class MyQueue {
    Deque<Integer> in;
    Deque<Integer> out;

    public MyQueue() {
        in = new ArrayDeque<>();
        out = new ArrayDeque<>();
    }

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
        return out.pop();
    }

    public int peek() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
        return out.peek();
    }

    public boolean empty() {
        return out.isEmpty() && in.isEmpty();
    }
}
```

* 【739】请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替
  * 单调递减栈
  * 遍历温度时，只有后面的温度才可能对其有影响，先放到栈里面
  * 如果遇到比栈顶大的说明刚刚当前节点对以前的有影响了，取出来设置为结果
  * 循环判断将所有的都有影响的都设置成结果

```
    public int[] dailyTemperatures(int[] temperatures) {
        Deque<Integer> deque = new ArrayDeque<>();
        int[] res = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            //维护一个单调递减的栈，如果有升高的温度，那么说明升高的温度一定会对应一个相对低的温度
            while (!deque.isEmpty() && temperatures[i] > temperatures[deque.peek()]) {
                res[deque.peek()] = i - deque.pop();
            }
            deque.push(i);
        }
        return res;
    }

```