## 1. 概念

## 2. 经典题目
* 【42】给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
  * 当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明可能会有积水
  * 当墙大于栈顶的高度，说明可以接水了
  * 取出上一面墙取最小者计算可以接的水
  * 需要注意理解计算宽度(i - deque.peek() - 1)
```
    public int trap(int[] heights) {
        if (heights == null || heights.length <= 1) {
            return 0;
        }
        int total = 0;
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < heights.length; i++) {
            //如果当前矩形高于栈顶的,则说明有雨水可接
            while (!deque.isEmpty() && heights[i] > heights[deque.peek()]) {
                //取出栈顶的代表底部矩形
                int bottomIdx = deque.pop();
                //如果栈中无矩形，说明无水可接
                if (deque.isEmpty()) {
                    break;
                }
                //取与上一个的最低的矩形作为高
                int height = Math.min(heights[i], heights[deque.peek()]) - heights[bottomIdx];
                //计算宽乘以高得出面积为水
                total += (i - deque.peek() - 1) * height;
            }
            deque.push(i);
        }
        return total;
    }
```

* 【155】设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 
  * 方法1
  * 两个栈
  * 一个最小栈，代表当前栈的最小值
  * 每次入栈都会比较一下
  * 方法2
  * 顺序队列（PriorityQueue）
```
    //方法1
    public MinStack() {
        deque = new ArrayDeque<Integer>();
        minDeque = new ArrayDeque<>();
        minDeque.push(Integer.MAX_VALUE);
    }

    Deque<Integer> deque;
    Deque<Integer> minDeque;

    public void push(int val) {
        deque.push(val);
        minDeque.push(Math.min(minDeque.peek(), val));
    }

    public void pop() {
        deque.pop();
        minDeque.pop();
    }

    public int top() {
        return deque.peek();
    }

    public int getMin() {
        return minDeque.peek();
    }

     //方法2
        Stack<Integer> vals;
    PriorityQueue<Integer> priorityQueue;
    /** initialize your data structure here. */
    public MinStack() {
        vals = new Stack<>();
        priorityQueue = new PriorityQueue<Integer>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        });
    }

    public void push(int val) {
        Integer isert = Integer.valueOf(val);
        vals.add(isert);
        priorityQueue.offer(isert);
    }

    public void pop() {
        Integer inte =  vals.pop();
        priorityQueue.remove(inte);
    }

    public int top() {
        return vals.peek();
    }

    public int getMin() {
        return priorityQueue.peek();
    }
```

* 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 
  * 栈
  * 直接看以下两种解法

```
    //模拟法
    public boolean isValid(String s) {
        Deque<Character> deque = new ArrayDeque<>();
        for (int i = 0; i < s.length(); i++) {
            char cur = s.charAt(i);
            if (cur == ')') {
                if (deque.isEmpty() || deque.pollFirst() != '(') {
                    return false;
                }
            } else if (cur == '}') {
                if (deque.isEmpty() || deque.pollFirst() != '{') {
                    return false;
                }
            } else if (cur == ']') {
                if (deque.isEmpty() || deque.pollFirst() != '[') {
                    return false;
                }
            } else {
                deque.push(cur);
            }
        }
        return deque.isEmpty();
    }

    //优雅解法
    public boolean isValid(String s) {
        if (s.length() % 2 != 0) {
            return false;
        }
        Deque<Character> deque = new ArrayDeque<>();
        for (char c : s.toCharArray()) {
            if (c == '(') {
                deque.push(')');
            } else if (c == '{') {
                deque.push('}');
            } else if (c == '[') {
                deque.push(']');
            } else {
                if (deque.isEmpty() || deque.pop() != c) {
                    return false;
                }
            }
        }
        return true;
    }
```


* 【232】请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）
  * 两个栈
  * 取的时候，从输出栈取，没有的话从输入栈中取出来
```
class MyQueue {
    Deque<Integer> in;
    Deque<Integer> out;

    public MyQueue() {
        in = new ArrayDeque<>();
        out = new ArrayDeque<>();
    }

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
        return out.pop();
    }

    public int peek() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
        return out.peek();
    }

    public boolean empty() {
        return out.isEmpty() && in.isEmpty();
    }
}
```

* 【739】请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替
  * 单调递减栈
  * 遍历温度时，只有后面的温度才可能对其有影响，先放到栈里面
  * 如果遇到比栈顶大的说明刚刚当前节点对以前的有影响了，取出来设置为结果
  * 循环判断将所有的都有影响的都设置成结果

```
    public int[] dailyTemperatures(int[] temperatures) {
        Deque<Integer> deque = new ArrayDeque<>();
        int[] res = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            //维护一个单调递减的栈，如果有升高的温度，那么说明升高的温度一定会对应一个相对低的温度
            while (!deque.isEmpty() && temperatures[i] > temperatures[deque.peek()]) {
                res[deque.peek()] = i - deque.pop();
            }
            deque.push(i);
        }
        return res;
    }

```

* 【862】给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1
  * 前缀和加上单调栈
  * 注意前缀和可能溢出，使用long
```
       /*
        首先解释P:
        P[n]=sum(A[:n-1])
        举例： A = [2,-1,2]
        P = [0, 2, 1, 3]

        如果我们想要A[1:3]的和，也就是[-1,2]的和，结果就是P[3]-P[1]=1

        队列维护：
        官方答案就是通过维持一个队列，从头到尾遍历。对于每个y，找出满足，P[y]-P[x]>=K的最大的x。如果y-x比之前的长度要小就记录新的最小值。

        维持队列涉及两个规则：

        对于新加入的y，前面的P[?]都要比新加入的P[y]要小，比P[y]大的P[?]都要pop掉，甚至如果都比P[y]大，整个队列都要清空。
        为什么？
        因为只有比P[y]小的P[?]，才能跟y组成，(y,x)组合，使得P[y]-P[x]>=K。那些不比P[y]小的P[?]，起不到任何作用，不可能存在一个x让当前的y或者之后的新y满足P[y]-P[x]>=K，也就不可能去更新最小长度。因此，只有比 P[y]小的P[?]才有保留的必要。
        为什么当队列里第一个x满足P[y]-P[x]>=K的时候，第一个x可以被pop掉？
        因为此时我们构成了一个P[y]-P[x]>=K，之后这个x就没有作用了。
        为什么这个x没有用了？
        因为即使之后存在某个其他的y'，也可以跟这个x构成P[y]-P[x]>=K，但是因为y'>y，因此次新的长度一定比当前的长度y-x要长，因为可以不用考虑。


        这个规则1解释的有问题，因为有负数的原因，P[y]和P[y+1]根本没有绝对的大小关系，因为K是个>=1的正整数，如果P[x]>P[y]，当然P[y]-P[x]<0必然满足不了>=K的题目要求，但是P[y+1]呢？倘若P[y+1]>p[y]，那么P[y+1]-P[x]是有可能满足>=K的，你在y这个地方把x给删了，y+1没有匹配了怎么办
        正确解释：还是需要讨论到上一条，y+1会不会没有匹配？这就很有意思了，还是上一条的条件，如果P[x]>P[y]，那么说明P[y]-P[x]<0即x~y这个区间和是个负数，此时假设P[y+1]-P[x]>=K，即y+1能与x匹配，即区间x~y+1满足要求，那么我可以拆开这个区间成为[x~y]+ [y~y+1]，且已知区间[x~y]的区间和是个负数，那么剩下的区间[y~y+1]一定也满足>=K，简单点理解就是A+负数>=K，显然A>=K，且题目要求是区间越短越好，那么自然[y~y+1]这一段会比[x~y+1]要短。所以答案，y+1会有匹配，且左端点是y，所以x没有意义，可以弹出x
        我的y+1可以看做是y后面的任一元素即y+正整数
        这也就解释了为什么是和0比较，而不是队列的尾部不满足题目要求的都弹出。
        如果一个尾部都不弹出，那其实就是默认所有元素为正数了，会wa，eg：[-28,81,-20,28,-29] 89
     */
    public int shortestSubarray(int[] nums, int k) {
        long[] pre = new long[nums.length + 1];
        //设置前缀和数组【0 1 2 ... n】
        for (int i = 1; i <= nums.length; i++) {
            pre[i] = pre[i - 1] + nums[i - 1];
        }
        Deque<Integer> deque = new LinkedList<>();
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < pre.length; i++) {
            //如果栈的last的pre大于等于当前的pre，弹出来last，因为不可能满足要求，pre[x] - pre[y] 》= k才可能满足要求
            while (!deque.isEmpty() && pre[deque.getLast()] >= pre[i]) {
                deque.pollLast();
            }
            while (!deque.isEmpty() && pre[i] - pre[deque.getFirst()] >= k) {
                min = Math.min(min, i - deque.pollFirst());
            }
            deque.addLast(i);
        }
        return min == Integer.MAX_VALUE ? -1 : min;
    }
```

* 【503】给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1
  * 讲两个nums数组拼接在一起，使用单调栈计算出每一个元素的下一个最大值
  * 优化点，if(i < n) stack.add(i);

```
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        Arrays.fill(res, -1);
        Deque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < 2 * nums.length; i++) {
            while (!deque.isEmpty() && nums[deque.peek()] < nums[i % nums.length]) {
                res[deque.pop()] = nums[i % nums.length];
            }
            deque.push(i % nums.length);
            //优化点，if(i < n) stack.add(i);
        }
        return res;
    }
```



* 【239】滑动窗口最大值，给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位，返回滑动窗口中的最大值
  * 维护窗口，向右移动时左侧超出窗口的值弹出，因为需要的是窗口内的最大值，所以只要保证窗口内的值是递减的即可，小于新加入的值全部弹出。最左端即为窗口最大
```
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || nums.length < k) {
            return new int[]{};
        }
        Deque<Integer> deque = new LinkedList<>();
        int[] res = new int[nums.length - k + 1];
        for (int i = 0; i < nums.length; i++) {
            //移除过期的下标
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            //保持一个递减栈
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            deque.addLast(i);
            //当可以窗口开始滑动时填充结果
            if (i - k + 1 >= 0) {
                res[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        return res;
    }   
```

* 【1047】给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 abbaca-》ca
```
    //标准方法
    public String removeDuplicates(String s) {
        Deque<Character> deque = new ArrayDeque<>();
        for (char c : s.toCharArray()) {
            if (!deque.isEmpty() && deque.peekLast() == c) {
                deque.removeLast();
            } else {
                deque.addLast(c);
            }
        }
        return deque.stream().map(String::valueOf).collect(Collectors.joining());
    }

    //原地方法
     public String removeDuplicates(String S) {
        int index = -1;
        char[] chars = S.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (index >= 0 && chars[index] == chars[i]) {
                index--;
            } else {
                index++;
                chars[index] = chars[i];
            }
        }
        return String.copyValueOf(chars, 0, index + 1);
    }
```

* 【225】请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）
  * 使用一个空队列和一个read队列
  * 每次拼接成栈的顺序，交换队列，read变成空队列，空队列变成read队列
```

    public MyStack() {
        tempQue = new ArrayDeque<>();
        readQue = new ArrayDeque<>();
    }
    Deque<Integer> tempQue, readQue;
    public void push(int x) {
        //临时的空队列添加一个元素
        tempQue.addLast(x);
        //将temp中的元素移过来(temp元素已经是栈的顺序了)
        while (!readQue.isEmpty()) {
            tempQue.addLast(readQue.pollFirst());
        }
        Deque<Integer> swap = readQue;
        readQue = tempQue;
        tempQue = swap;
    }

    public int pop() {
        return readQue.pollFirst();
    }

    public int top() {
        return readQue.peekFirst();
    }

    public boolean empty() {
        return readQue.isEmpty();
    }
```

* 【offer09】用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 
  * 注意取得时候如果out为空才循环从in中取
```

    public CQueue() {
        in = new ArrayDeque<>();
        out = new ArrayDeque<>();
    }
    Deque<Integer> in, out;

    public void appendTail(int value) {
        in.addLast(value);
    }

    public int deleteHead() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.addLast(in.removeLast());
            }
        }
        if (out.isEmpty()) {
            return -1;
        }
        return out.removeLast();
    }
```

* 【】给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足i < j < k 和 nums[i] < nums[k] < nums[j] 。如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 
  * 维护一个单调递减栈
  * 倒叙遍历
  * 如果当前元素比栈顶的大，取出比它小的最大值
  * 如果下一个有最大值小的说明找到了
```
   public boolean find132pattern(int[] nums) {
        Deque<Integer> deque = new LinkedList<>();
        int right = Integer.MIN_VALUE;//132中的2
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] < right) {
                return true;
            }
            //维护一个单调递减栈，栈的元素都比i元素大
            while (!deque.isEmpty() && deque.getLast() < nums[i]) {
                //找出比i小的元素的最大值
                right = Math.max(deque.removeLast(), right);
            }
            deque.addLast(nums[i]);
        }
        return false;
    }
```