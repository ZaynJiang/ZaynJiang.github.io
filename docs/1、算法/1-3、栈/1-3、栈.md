## 1. 概念

## 2. 经典题目
* 【42】给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
  * 当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明可能会有积水
  * 当墙大于栈顶的高度，说明可以接水了
  * 取出上一面墙取最小者计算可以接的水
  * 需要注意理解计算宽度(i - deque.peek() - 1)
```
    public int trap(int[] heights) {
        if (heights == null || heights.length <= 1) {
            return 0;
        }
        int total = 0;
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < heights.length; i++) {
            //如果当前矩形高于栈顶的,则说明有雨水可接
            while (!deque.isEmpty() && heights[i] > heights[deque.peek()]) {
                //取出栈顶的代表底部矩形
                int bottomIdx = deque.pop();
                //如果栈中无矩形，说明无水可接
                if (deque.isEmpty()) {
                    break;
                }
                //取与上一个的最低的矩形作为高
                int height = Math.min(heights[i], heights[deque.peek()]) - heights[bottomIdx];
                //计算宽乘以高得出面积为水
                total += (i - deque.peek() - 1) * height;
            }
            deque.push(i);
        }
        return total;
    }
```

* 【155】设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 
  * 方法1
  * 两个栈
  * 一个最小栈，代表当前栈的最小值
  * 每次入栈都会比较一下
  * 方法2
  * 顺序队列（PriorityQueue）
```
    //方法1
    public MinStack() {
        deque = new ArrayDeque<Integer>();
        minDeque = new ArrayDeque<>();
        minDeque.push(Integer.MAX_VALUE);
    }

    Deque<Integer> deque;
    Deque<Integer> minDeque;

    public void push(int val) {
        deque.push(val);
        minDeque.push(Math.min(minDeque.peek(), val));
    }

    public void pop() {
        deque.pop();
        minDeque.pop();
    }

    public int top() {
        return deque.peek();
    }

    public int getMin() {
        return minDeque.peek();
    }

     //方法2
        Stack<Integer> vals;
    PriorityQueue<Integer> priorityQueue;
    /** initialize your data structure here. */
    public MinStack() {
        vals = new Stack<>();
        priorityQueue = new PriorityQueue<Integer>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        });
    }

    public void push(int val) {
        Integer isert = Integer.valueOf(val);
        vals.add(isert);
        priorityQueue.offer(isert);
    }

    public void pop() {
        Integer inte =  vals.pop();
        priorityQueue.remove(inte);
    }

    public int top() {
        return vals.peek();
    }

    public int getMin() {
        return priorityQueue.peek();
    }
```