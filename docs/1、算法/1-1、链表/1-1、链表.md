## 1. 链表
## 2. 单链表
### 2.1. 单链表
* 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表(leetcode25)
  * 链表操作需要熟练度
```
public ListNode reverseKGroup(ListNode head, int k) {
    int i = 1;
    //定义上一个小段的尾部节点，当前当前段的头节点，整个的头节点
    ListNode preTail = null, curHead = head, res = head;
    while (head != null) {
        //记录下一个节点
        ListNode next = head.next;
        //如果是一段的尾部节点
        if (i++ % k == 0) {
            //这一段尾部之后的截断，方便反转
            head.next = null;
            //反转这一段，并返回这一段的新头部
            ListNode newHead = reverse(curHead);
            //如果上一段尾不为空，则新头部与上一段连接起来
            if (preTail != null) {
                preTail.next = newHead;
            //如果上一段尾为空，说明是第一段，设置整个头节点    
            } else {
                res = newHead;
            }
            //当前工作完成，下一段做准备
            //设置当前段尾为”上一段的尾部“
            preTail = curHead;
            //尾部连接下一段
            preTail.next = next;
            //设置下一段的当前段
            curHead = next;
        }
        head = next;
    }
    return res;
}

//反转一个单链表
public ListNode reverse(ListNode head) {
    ListNode pre = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
```
* 【160】给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。  
  * 类似于快慢指针，第一个指针如果走到头，第二个还没有走，那么会从头再来
  * 如果有一天正好相等了，说明就是相交点

```
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA, curB = headB;
        while (curA != curB) {
            curA = curA == null ? headA : curA.next;
            curB = curB == null ? headB : curB.next;
        }
        return curA;
    }
```
* 【143】重排链表
  * 将链表分为两段，第二段反转
  * 反转第二段（注意第一段的结尾还指向第二段的结尾，最后需要处理下）
  * 处理环，最后一个会自己指向自己

```
    public void reorderList(ListNode head) {
        //将链表分为两段，第二段反转
        ListNode slow = head, fast = head;
        //找到第二段的head
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        //反转第二段（注意第一段的结尾还指向第二段的结尾，最后需要处理下）
        ListNode secondHead = reverse(slow);
        while (head != null) {
            ListNode oneNext = head.next, secondNext = secondHead.next;
            //第一段元素指向第二段
            head.next = secondHead;
            //第二段指向第一段下一个元素
            secondHead.next = oneNext;
            //第一段指向下一个元素
            head = oneNext;
            //第二段指向下一个元素
            secondHead = secondNext;
        }
        //处理环，以为最后一个会指向自己
        head.next = null;
    }

    public ListNode reverse(ListNode head) {
        ListNode pre = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
```
* 【92】给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表
  * 方法1，利用虚拟节点避免判空
  * 找到要反转的链表的头节点上一个
  * 判断如果left < right，则说明需要反转，否则不需要
  * 循环，反转的时候，即将元素插入到pre的下一个前面，中间一反转的就不用动了
  * 方法2，分别找到待反转链表的头和尾部
  * 反转后，拼接即可
```
方法1
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(), preHead = dummy;
        dummy.next = head;
        for (int i = 1; i < left; i++) {
            preHead = preHead.next;
        }
        head = preHead.next;
        //后续相当于把head的next节点插入到preHead的后面
        for (; left < right; left++) {
            ListNode next = head.next;
            head.next = next.next;
            next.next = preHead.next;
            preHead.next = next;
        }
        return dummy.next;
    }

方法2
    public ListNode reverseBetween2(ListNode head, int left, int right) {
        if (head == null || right <= left) {
            return head;
        }
        int idx = 1;
        ListNode hair = new ListNode(),  oldTail = null, oldHeadPre = hair;
        hair.next = head;
        while (head != null) {
            // left的上一个
            if (idx + 1 == left) {
                oldHeadPre = head;
            } else if (idx == right) {
                oldTail = head;
            }
            head = head.next;
            idx++;
        }
        //截断尾部
        ListNode tailNext = oldTail.next;
        oldTail.next = null;
        //反转
        ListNode oldHead = oldHeadPre.next;
        ListNode newHead = reverse(oldHead);
        oldHeadPre.next = newHead;
        oldHead.next = tailNext;
        return hair.next;
    }

    public ListNode reverse(ListNode head){
        ListNode pre = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
```

* 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的
  * 优雅代码递归合并
  * 也可以迭代合并
```
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val > l2.val) {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        } else {
            l1.next = mergeTwoLists(l2, l1.next);
            return l1;
        }
    }
```

* 【82】存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字
  * 没有重复head不变，如果有重复的元素，head进行移动到最后一个重复元素
  * pre代表好了的尾部，pre.next如果和head相等，说明head没有移动，即没有重复的元素
  * pre.next如果和head不相等，说明上面的while导致head移动了，pre指向下一个
```
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(), pre = dummy;
        dummy.next = head;
        while (head != null) {
            while (head.next != null && head.next.val == head.val) {
                head = head.next;
            }
            if (pre.next == head) {
                pre = head;
            } else {
                pre.next = head.next;
            }
            head = head.next;
        }
        return dummy.next;
    }
```