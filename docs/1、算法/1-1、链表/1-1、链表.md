## 1. 链表
## 2. 单链表
### 2.1. 单链表
* 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表(leetcode25)
  * 链表操作需要熟练度
```
public ListNode reverseKGroup(ListNode head, int k) {
    int i = 1;
    //定义上一个小段的尾部节点，当前当前段的头节点，整个的头节点
    ListNode preTail = null, curHead = head, res = head;
    while (head != null) {
        //记录下一个节点
        ListNode next = head.next;
        //如果是一段的尾部节点
        if (i++ % k == 0) {
            //这一段尾部之后的截断，方便反转
            head.next = null;
            //反转这一段，并返回这一段的新头部
            ListNode newHead = reverse(curHead);
            //如果上一段尾不为空，则新头部与上一段连接起来
            if (preTail != null) {
                preTail.next = newHead;
            //如果上一段尾为空，说明是第一段，设置整个头节点    
            } else {
                res = newHead;
            }
            //当前工作完成，下一段做准备
            //设置当前段尾为”上一段的尾部“
            preTail = curHead;
            //尾部连接下一段
            preTail.next = next;
            //设置下一段的当前段
            curHead = next;
        }
        head = next;
    }
    return res;
}

//反转一个单链表
public ListNode reverse(ListNode head) {
    ListNode pre = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
```
* 【160】给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。  
  * 类似于快慢指针，第一个指针如果走到头，第二个还没有走，那么会从头再来
  * 如果有一天正好相等了，说明就是相交点

```
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA, curB = headB;
        while (curA != curB) {
            curA = curA == null ? headA : curA.next;
            curB = curB == null ? headB : curB.next;
        }
        return curA;
    }
```
* 【143】重排链表
  * 将链表分为两段，第二段反转
  * 反转第二段（注意第一段的结尾还指向第二段的结尾，最后需要处理下）
  * 处理环，最后一个会自己指向自己

```
    public void reorderList(ListNode head) {
        //将链表分为两段，第二段反转
        ListNode slow = head, fast = head;
        //找到第二段的head
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        //反转第二段（注意第一段的结尾还指向第二段的结尾，最后需要处理下）
        ListNode secondHead = reverse(slow);
        while (head != null) {
            ListNode oneNext = head.next, secondNext = secondHead.next;
            //第一段元素指向第二段
            head.next = secondHead;
            //第二段指向第一段下一个元素
            secondHead.next = oneNext;
            //第一段指向下一个元素
            head = oneNext;
            //第二段指向下一个元素
            secondHead = secondNext;
        }
        //处理环，以为最后一个会指向自己
        head.next = null;
    }

    public ListNode reverse(ListNode head) {
        ListNode pre = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
```