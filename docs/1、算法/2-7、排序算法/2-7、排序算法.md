## 1. 概念


## 2. 经典题目
* 【215】给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
  * 快速排序思想
  * 找出任意一个数的下标，使得右边比它都大
  * 比较这个数和k是不是相等,相等则说明就是它
  * 大于k,右指针下移动mark位置，再找出一个数，使得右边比它大
  * 小于k，左指针上移动mark位置，再找出一个数，使得右边比它大
  * 重复即可
```
    public int findKthLargest(int[] nums, int k) {
        k = nums.length - k;
        int lo = 0, hi = nums.length - 1;
        while (lo < hi) {
            int higherMark = getHigherMark(nums, lo, hi);
            if (k == higherMark) {
                return nums[k];
            } else if (k > higherMark){
                lo = higherMark + 1;
            } else {
                hi = higherMark - 1;
            }
        }
        return nums[lo];
    }

    //快速排序的经典操作
    public int getHigherMark(int[] nums, int left, int right) {
        int lowerMark = left;
        while (left < right) {
            if (nums[left] < nums[right]) {
                swap(nums, lowerMark++, left);
            }
            left++;
        }
        swap(nums, lowerMark, right);
        return lowerMark;
    }


    public void swap(int[] nums, int i, int j) {
        if (i == j) {
            return;
        }
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

* 【148】给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 
    * 标准的归并排序
    * 先写出合并两个有序链表的方法
    * 如何归并呢？数组是取首位和末尾中间为作为mid，链表可以采用快慢指针的方法找到
    ```
    //归并排序
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode secondHead = slow.next;
        slow.next = null;
        return merge(sortList(head), sortList(secondHead));
    }

    //合并有序链表的标准写法
    public ListNode merge(ListNode node1, ListNode node2) {
        if (node1 == null) {
            return node2;
        }
        if (node2 == null) {
            return node1;
        }
        if (node1.val < node2.val) {
            node1.next = merge(node1.next, node2);
            return node1;
        } else {
            node2.next = merge(node2.next, node1);
            return node2;
        }
    }
   ```

* 【offer40】输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4  
    * 利用快排思想找到某一个下标，左边的比它小右边比它大
    * 如果idx == k说明正好
    * 如果idx > k，说明idx大于k了需要将hi下移
    * 如果idx < k，说明idx小于k了需要将lo上移
   ```
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0) {
            return new int[]{};
        }
        k--;
        int lo = 0, hi = arr.length - 1;
        while (lo <= hi) {
            int idx = quickSort(arr, lo, hi);
            if (idx == k) {
                return Arrays.copyOf(arr, k + 1);
            } else if (idx > k) {
                hi = idx - 1;
            } else {
                lo = idx + 1;
            }
        }
        return null;
    }

    public int quickSort(int[] arr, int start, int end) {
        int readyIdx = end;
        while (start < end) {
            if (arr[start] <= arr[end]) {
                swap(arr, readyIdx--, end);
            }
            end--;
        }
        swap(arr, readyIdx, start);
        return readyIdx;
    }

    public void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

   ```

* 【offer51】在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数
    * 典型的不能再典型的归并排序实现
   ```
      public int reversePairs(int[] nums) {
        mergeSort(nums, 0, nums.length - 1);
        return count;
    }


    public void mergeSort(int[] nums, int start, int end) {
        if (start >= end) {
            return;
        }
        int mid = (start + end) >> 1;
        mergeSort(nums, start, mid);
        mergeSort(nums, mid + 1, end);
        mergeSortArray(nums, start, mid, end);
    }

    int count = 0;

    public void mergeSortArray(int[] nums, int start, int mid, int end) {
        int[] res = new int[end - start + 1];
        int idx = 0, i = start, j = mid + 1;
        while (i <= mid && j <= end) {
            if (nums[i] <= nums[j]) {
                res[idx++] = nums[i++];
            } else {
                res[idx++] = nums[j++];
                count += mid - i + 1;
            }
        }
        while (i <= mid) {
            res[idx++] = nums[i++];
        }
        while (j <= end) {
            res[idx++] = nums[j++];
        }
        System.arraycopy(res, 0, nums, start, res.length);
    }
   ```

* 【75】给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列
   * 注意循环的放在前面
   ```
       public void sortColors(int[] nums) {
        //0、 1 和 2
        int i = 0, j = nums.length - 1;
        for (int k = 0; k < nums.length; k++) {
            while (nums[k] == 2 && k < j) {
                swap(nums, k, j--);
            }
            if (nums[k] == 0) {
                swap(nums, k, i++);
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
   ```

* 【mianshi17.14】设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可
  * 快排思想 
```
   public int[] smallestK(int[] arr, int k) {
        if (k <= 0) {
            return new int[]{};
        }
        int lo = 0, hi = arr.length - 1;
        while (lo <= hi) {
            int idx = smallerConunt(arr, lo, hi);
            if (idx == k - 1) {
                return Arrays.copyOf(arr, k);
            } else if (idx < k - 1){
                lo = idx + 1;
            } else {
                hi = idx - 1;
            }
        }
        return new int[]{};
    }

    private int smallerConunt(int[] arr, int lo, int hi) {
        int idx = lo;
        while (lo < hi) {
            if (arr[lo] < arr[hi]) {
                swap(arr, lo, idx++);
            }
            lo++;
        }
        swap(arr, idx, hi);
        return idx;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```