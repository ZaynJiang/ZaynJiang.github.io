## 1. 开头
## 2. 经典题目
* 【381】 O(1) 时间插入、删除和获取随机元素 - 允许重复
```
    List<Integer> list;
    Map<Integer, Set<Integer>> map;
    public RandomizedCollection() {
        list = new ArrayList<>();
        map = new HashMap<>();
    }

    public boolean insert(int val) {
        list.add(val);
        Set<Integer> set = map.computeIfAbsent(val,x->new HashSet<>());
        set.add(list.size() - 1);//存储val对应于list的下标.
        return set.size() == 1;
    }

    public boolean remove(int val) {
        if (!map.containsKey(val)) {
            return false;
        }
        Iterator<Integer> it = map.get(val).iterator();//取出val对应的下标列表
        int valIdx = it.next();//找到val对应的一个下标值
        int lastVal = list.get(list.size() - 1);//找到list中最后一个的val
        list.set(valIdx, lastVal);//将val的位置置为last
        map.get(lastVal).remove(list.size() - 1);//删除last的下标
        map.get(val).remove(valIdx);//删除val的下标
        if (valIdx < list.size() - 1) {//如果删除元素恰好就是最后一个元素,避免添加错误元素
            map.get(lastVal).add(valIdx);//新增last的下标
        }
        if (map.get(val).size() == 0) {//如果val不重复，直接删掉
            map.remove(val);
        }
        list.remove(list.size() - 1);
        return true;
    }

    public int getRandom() {
        return list.get(new Random().nextInt(list.size()));
    }
```

* 【895】实现 FreqStack，模拟类似栈的数据结构的操作的一个类。FreqStack 有两个函数。push(int x)，将整数 x 推入栈中。  pop()，它移除并返回栈中出现最频繁的元素。如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。
  * 注意maxFreq的值是依次递增的,每次加1

```
   Map<Integer, Integer> valFreq; //数字和频率的映射
    Map<Integer, Deque<Integer>> freqDeque; //频率和数字的映射
    private int maxFreq; //最大频率值

    public FreqStack() {
        valFreq = new HashMap<>();
        freqDeque = new HashMap<>();
    }

    public void push(int val) {
        int freq =  valFreq.getOrDefault(val, 0) + 1;
        valFreq.put(val, freq);
        freqDeque.computeIfAbsent(freq,  z -> new ArrayDeque<>()).push(val);
        if (freq > maxFreq) {
            maxFreq = freq;
        }
    }

    public int pop() {
        Deque<Integer> maxDeque = freqDeque.get(maxFreq);
        int popVal = maxDeque.pop();//当前频率的val移除
        valFreq.put(popVal, valFreq.get(popVal) - 1);
        if (maxDeque.size() == 0) {//最大的所有的val都移除掉了，最大频率要减小一位
            maxFreq--;
        }
        return popVal;
    }
```

* 【622】设计循环队列
设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：

MyCircularQueue(k): 构造器，设置队列长度为 k 。
Front: 从队首获取元素。如果队列为空，返回 -1 。
Rear: 获取队尾元素。如果队列为空，返回 -1 。
enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
isEmpty(): 检查循环队列是否为空。
isFull(): 检查循环队列是否已满

```
class MyCircularQueue {
    int[] queue;
    int len = 0, front = 0, rear = -1;

    public MyCircularQueue(int k) {
        queue = new int[k];
    }

    public boolean enQueue(int value) {
        if (!isFull()) {
            rear = (rear + 1) % queue.length;
            queue[rear] = value;
            len++;
            return true;
        }
        return false;
    }

    public boolean deQueue() {
        if (!isEmpty()) {
            front = (front + 1) % queue.length;
            len--;
            return true;
        }
        return false;
    }

    public int Front() {
        return !isEmpty() ? queue[front] : -1;
    }

    public int Rear() {
        return !isEmpty() ? queue[rear] : -1;
    }

    public boolean isEmpty() {
        return len == 0;
    }

    public boolean isFull() {
        return len == queue.length;
    }
}
```