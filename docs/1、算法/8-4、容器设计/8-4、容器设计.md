## 1. 开头
## 2. 经典题目
* 【381】 O(1) 时间插入、删除和获取随机元素 - 允许重复
```
    List<Integer> list;
    Map<Integer, Set<Integer>> map;
    public RandomizedCollection() {
        list = new ArrayList<>();
        map = new HashMap<>();
    }

    public boolean insert(int val) {
        list.add(val);
        Set<Integer> set = map.computeIfAbsent(val,x->new HashSet<>());
        set.add(list.size() - 1);//存储val对应于list的下标.
        return set.size() == 1;
    }

    public boolean remove(int val) {
        if (!map.containsKey(val)) {
            return false;
        }
        Iterator<Integer> it = map.get(val).iterator();//取出val对应的下标列表
        int valIdx = it.next();//找到val对应的一个下标值
        int lastVal = list.get(list.size() - 1);//找到list中最后一个的val
        list.set(valIdx, lastVal);//将val的位置置为last
        map.get(lastVal).remove(list.size() - 1);//删除last的下标
        map.get(val).remove(valIdx);//删除val的下标
        if (valIdx < list.size() - 1) {//如果删除元素恰好就是最后一个元素,避免添加错误元素
            map.get(lastVal).add(valIdx);//新增last的下标
        }
        if (map.get(val).size() == 0) {//如果val不重复，直接删掉
            map.remove(val);
        }
        list.remove(list.size() - 1);
        return true;
    }

    public int getRandom() {
        return list.get(new Random().nextInt(list.size()));
    }
```

* 【895】实现 FreqStack，模拟类似栈的数据结构的操作的一个类。FreqStack 有两个函数。push(int x)，将整数 x 推入栈中。  pop()，它移除并返回栈中出现最频繁的元素。如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。
  * 注意maxFreq的值是依次递增的,每次加1

```
   Map<Integer, Integer> valFreq; //数字和频率的映射
    Map<Integer, Deque<Integer>> freqDeque; //频率和数字的映射
    private int maxFreq; //最大频率值

    public FreqStack() {
        valFreq = new HashMap<>();
        freqDeque = new HashMap<>();
    }

    public void push(int val) {
        int freq =  valFreq.getOrDefault(val, 0) + 1;
        valFreq.put(val, freq);
        freqDeque.computeIfAbsent(freq,  z -> new ArrayDeque<>()).push(val);
        if (freq > maxFreq) {
            maxFreq = freq;
        }
    }

    public int pop() {
        Deque<Integer> maxDeque = freqDeque.get(maxFreq);
        int popVal = maxDeque.pop();//当前频率的val移除
        valFreq.put(popVal, valFreq.get(popVal) - 1);
        if (maxDeque.size() == 0) {//最大的所有的val都移除掉了，最大频率要减小一位
            maxFreq--;
        }
        return popVal;
    }
```