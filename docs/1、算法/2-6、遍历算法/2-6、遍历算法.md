## 1. 概念

## 广度优先遍历

* 【103】给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 
  * 使用linkedlist
  * 使用队列
  * 广度优先遍历
  * 奇数偶数addlast、addFirst
```
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            LinkedList list = new LinkedList();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                if (res.size() % 2 == 0) {
                    list.addLast(node.val);
                } else {
                    list.addFirst(node.val);
                }
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            res.add(list);
        }
        return res;
    }
```

* 【199】 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。  
  * 层序遍历,广度优先遍历
  * 双端队列，取队尾peekLast
  * 这个也可以用dfs，也很简单,相当于反着的前序遍历
```
    //bfs
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            res.add(deque.peekLast().val);
            int size = deque.size();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return res;
    }

    //dfs
    List<Integer> res = new ArrayList<>();

    public List<Integer> rightSideView(TreeNode root) {
         // 从根节点开始访问，根节点深度是0
        dfs(root, 0); 
        return res;
    }

    private void dfs(TreeNode root, int depth) {
        if (root == null) {
            return;
        }
        // 先访问 当前节点，再递归地访问 右子树 和 左子树。
        if (depth == res.size()) {   
            // 如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。
            res.add(root.val);
        }
        depth++;
        dfs(root.right, depth);
        dfs(root.left, depth);
    }
```

* 【102】给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点
  * 标准的层序遍历
```
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.push(root);
        while (!deque.isEmpty()) {
            List<Integer> list = new LinkedList<>();
            int size = deque.size();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                list.add(node.val);
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            res.add(list);
        }
        return res;
    }
```

## 深度优先遍历 
* 【200】给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
  * dfs遍历
  * 遇到1，从该1处把能够和它连接的1全部置为0   
```
   public int numIslands(char[][] grid) {
        if (grid == null) {
            return 0;
        }
        int res = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    private void dfs(char[][] grid, int i, int j) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == '0') {
            return;
        }
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
```

* 【101】给定一个二叉树，检查它是否是镜像对称的
  * 递归，从上到下，检查左侧的左侧和右侧的右侧，以及左侧的右侧及右侧的左侧
  * 迭代，左侧的左侧和右侧的右侧，以及左侧的右侧及右侧的左侧依次放到栈里，校验即可
```
    public boolean isSymmetric(TreeNode root) {
        return isSymmetric(root.left, root.right);
    }

    //递归
    public boolean isSymmetric(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);
    }

    //迭代
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        Deque<TreeNode> deque  = new LinkedList<>();
        deque.push(root);
        deque.push(root);
        while (!deque.isEmpty()) {
            TreeNode left = deque.pop(), right = deque.pop();
            if (left == null && right == null) {
                continue;
            }
            if (left == null || right == null) {
                return false;
            }
            if (left.val != right.val) {
                return false;
            }
            deque.push(left.left);
            deque.push(right.right);
            deque.push(left.right);
            deque.push(right.left);
        }
        return true;
    }
```

* 【129】给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。计算从根节点到叶节点生成的 所有数字之和 
  * 上一层的值乘以10加上当前值
  * 如果为空，说明该路径无效，为0
  * 如果不为空且是是叶子节点，就直接返回last
  * 不是叶子节点的话，就发散，计算分支的和
```
    private int getSumNumbers(TreeNode root, int last) {
        if (root == null) {
            return 0;
        }
        last = last*10 + root.val;
        if (root.left == null && root.right == null) {
            return last;
        }
        return getSumNumbers(root.left, last) + getSumNumbers(root.right, last);
    }
```


* 【662】给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空
  * 层序遍历
  * 每个节点保存一个序号，可以观察完全二叉树左节点为上一个序号的两倍，右节点的序号为上一序号的两倍加1
  * 使用双端队列，取每一层前端和后端之间的差值，取最大值
```
   public int widthOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        int max = 1;
        root.val = 1;
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            max = Math.max(max, deque.peekLast().val - deque.peekFirst().val + 1);
            while (size-- > 0) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    node.left.val = 2 * node.val;
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    node.right.val = 2 * node.val + 1;
                    deque.offer(node.right);
                }
            }
        }
        return max;
    }
```  

* 【440】给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字
  * 前序遍历
  * 注意数字可能越界
  * 寻找一个节点的满足条件的数量，如果小于剩余的k个，直接右
  * 最终不断的右移获取结果。注意k > 0
```
    public int findKthNumber(int n, int k) {
        k--;
        long cur = 1;
        while (k > 0) {
            //获取cur节点下的满足小于n的节点数量
            long nums = getNumsByRoot(n, cur);
            //cur小于n节点的数量小于k，说明这个cur分支的结果数量不够k个，需要右移动
            if (nums > k) {
                cur *= 10;
                k--;
                //cur小于n节点的数量大于k，说明结果就在cur下
            } else {
                cur++;
                k -= nums;
            }
        }
        return (int) cur;
    }
    /**
     * 返回某一个cur根节点下所有小于等于目标值n的数量
     * @param cur， 当前根节点
     * @param n， 目标值
     * @return
     */
    public long getNumsByRoot(long n, long cur) {
        long nums = 0, nextCur = cur + 1;
        while (cur <= n) {
            nums += Math.min(nextCur - cur, n - cur + 1);
            cur *= 10;
            nextCur *= 10;
        }
        return nums;
    }
```

* 【94】 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 
```
    public List<Integer> inorderTraversal(TreeNode root) {
        dfs(root);
        return res;
    }
    public void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        res.add(root.val);
        dfs(root.right);
    }
    List<Integer> res = new ArrayList<Integer>();
```
```
    public List<Integer> inorderTraversal(TreeNode root) {
            Deque<TreeNode> deque = new ArrayDeque<>();
            List<Integer> ans = new ArrayList<>();
            while (root != null || !deque.isEmpty()) {
                while (root != null) {
                    deque.push(root);
                    root = root.left;
                }
                TreeNode node = deque.pop();
                ans.add(node.val);
                root = node.right;

            }
            return ans;
        }

```
    
* 【297】请设计一个算法来实现二叉树的序列化与反序列化
```
    public String serialize(TreeNode root) {
        dfs(root);
        return str.stream().collect(Collectors.joining(":"));
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            str.add("null");
            return;
        }
        str.add(String.valueOf(root.val));
        dfs(root.left);
        dfs(root.right);
    }
    List<String> str = new ArrayList<>();


    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Deque<String> deque = new LinkedList<>(Arrays.asList(data.split(":")));
        return buildTree(deque);
    }
    private TreeNode buildTree(Deque<String> deque) {
        if (deque.isEmpty()) {
            return null;
        }
        String str = deque.pop();
        if ("null".equals(str)) {
            return null;
        } else {
            TreeNode root = new TreeNode(Integer.valueOf(str));
            root.left = buildTree(deque);
            root.right = buildTree(deque);
            return root;
        }
    }
```

* 【114】给你二叉树的根结点 root ，请你将它展开为一个单链表
```
    TreeNode pre = null;
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }
        if (pre != null) {
            pre.right = root;
        }
        //这里必须要将right和left变量先提取出来
        //因为遍历下一层的时候，pre的right会变化，flatten需要使用之前的right
        TreeNode left = root.left, right = root.right;
        root.left = null;
        pre = root;
        flatten(left);
        flatten(right);
    }
```

* 【offer54】给定一棵二叉搜索树，请找出其中第k大的节点
  * 第k大，是找倒数第k大的
```
    public int kthLargest(TreeNode root, int k) {
        dfs(root, k);
        return res;
    }
    private void dfs(TreeNode root, int k) {
        if (root == null) {
            return;
        }
        dfs(root.right, k);
        if (++count == k) {
            res = root.val;
        }
        dfs(root.left, k);
    }
    int res = Integer.MIN_VALUE;
    int count = 0;
```

* 【230】给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）
```
    public int kthSmallest(TreeNode root, int k) {
        dfs(root, k);
        return res;
    }
    private void dfs(TreeNode root, int k) {
        if (root == null) {
            return;
        }
        dfs(root.left, k);
        if (++count == k) {
            res = root.val;
        }
        dfs(root.right, k);
    }
    int res = 0, count = 0;
```


* 【104】给定一个二叉树，找出其最大深度。 
  * 很简单
```
  public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```

* 【offer36】输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向
  * 定义一个上一节点和head节点
  * 中序遍历
  * 最终对尾部进行连接
```
    public Node treeToDoublyList(Node root) {
        if (root == null) {
            return null;
        }
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    Node pre = null, head;
    private void dfs(Node root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        Node cur = new Node(root.val);
        if (head == null) {
            head = cur;
        } else {
            pre.right = cur;
            cur.left = pre;
        }
        pre = cur;
        dfs(root.right);
    }
```


* 【226】翻转一棵二叉树。 
```
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode right = invertTree(root.right), left = invertTree(root.left);
        root.right = left;
        root.left = right;
        return root;
    }
```


* 【145】给定一个二叉树，返回它的 后序 遍历。
```
   List<Integer> res = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        dfs(root);
        return res;
    }
    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        dfs(root.right);
        res.add(root.val);
    }
```

* 【offer34】 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点

```
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        dfs(root, new LinkedList<>(), target);
        return res;
    }

    private void dfs(TreeNode root, LinkedList<Integer> list, int target) {
        if (root == null) {
            return;
        }
        target -= root.val;
        list.addLast(root.val);
        //说明是叶子节点
        if (root.left == null && root.right == null && target == 0) {
            res.add(new LinkedList<>(list));
        }
        dfs(root.left, list, target);
        dfs(root.right, list, target);
        list.removeLast();
    }
```


* 【108】给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树
  * BST的中序遍历是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树
  * 我们可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树
  * 以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树啦
  * 本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点
  * int mid = left + ((right - left) / 2)，这么些不容易int越界数值越，例如left和right都是最大int，(left + right) / 2这么操作就越界了
```
   public TreeNode sortedArrayToBST(int[] nums) {
        return buildTree(nums, 0, nums.length - 1);
    }
    private TreeNode buildTree(int[] nums, int i, int j) {
        if (i > j) {
            return null;
        }
        int mid = i + (j - i) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildTree(nums, i, mid - 1);
        root.right = buildTree(nums, mid + 1, j);
        return root;
    }
```

* 【offer27】请完成一个函数，输入一个二叉树，该函数输出它的镜像
```
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode right = root.right, left = root.left;
        root.left = mirrorTree(right);
        root.right = mirrorTree(left);
        return root;
    }
```

* 【99】给你二叉搜索树的根节点 root ，该树中的两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树。 
  * 中序遍历过程中，记录错误两个错误排序节点，最后进行交换
  * 中序遍历的时候 访问到的元素是从小到大顺序排列
  * 对两个节点交换了顺序  那一定有两个地方是  不满足  前一个元素 < 当前元素 < 后一个元素
  * 使用两个全局变量在遍历过程中记录这两个节点 最后对他们进行交换
```
   TreeNode node1, node2, pre;
    public void recoverTree(TreeNode root) {
        dfs(root);
        int val = node1.val;
        node1.val = node2.val;
        node2.val = val;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        //说明有不正确的节点，即后面的节点比前面的大了
        if (pre != null && root.val < pre.val) {
            if (node1 == null) {
                node1 = pre;
            }
            node2 = root;
        }
        pre = root;
        dfs(root.right);
    }
```

*【144】给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 
```
   public List<Integer> preorderTraversal(TreeNode root) {
        dfs(root);
        return res;
    }
    List<Integer> res = new ArrayList<>();

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        dfs(root.left);
        dfs(root.right);
    }
```
迭代法
```
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.push(root);
        while (!deque.isEmpty()) {
            TreeNode node = deque.pop();
            ans.add(node.val);
            if (node.right != null) {
                deque.push(node.right);
            }
            if (node.left != null) {
                deque.push(node.left);
            }
        }
        return ans;
    }
```

```
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        pre(root, res);
        return res;
    }

    private void pre(TreeNode root, List<Integer> res) {
        Stack<TreeNode> stack = new Stack<>();
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                res.add(root.val);
                stack.add(root);
                root = root.left;
            }
            root = stack.pop().right;
        }
    }
```


* 【106】根据一棵树的中序遍历与后序遍历构造二叉树。 
   * 画图即可

```
   Map<Integer, Integer> inMap = new HashMap<>();
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for (int i = 0; i < inorder.length; i++) {
            inMap.put(inorder[i], i);
        }
        return dfs(postorder, 0, inorder.length - 1, inorder.length - 1);
    }

    private TreeNode dfs(int[] postorder, int inLeft, int inRight, int postRoot) {
        if (inLeft > inRight) {
            return null;
        }
        int rootVal = postorder[postRoot], inRoot = inMap.get(rootVal);
        TreeNode root = new TreeNode(rootVal);
        root.left = dfs(postorder, inLeft, inRoot - 1, postRoot - inRight + inRoot - 1);
        root.right = dfs(postorder, inRoot + 1, inRight, postRoot - 1);
        return root;
    }
```

* 【889】根据前序和后序遍历构造二叉树
  * 这道题需要注意边界寻找
  * 前序和后序都只用于提供根结点，只有中序才能区分左右子树
  * 前序+后序是不能构建唯一的二叉树的
  * 前序遍历是根左右，因此preorder第一个元素一定整个树的根，preorder第二个元素（如果存在的话）一定是左子树。由于题目说明了没有重复元素，因此我们可以通过val去postorder找到pre[1]在postorder中的索引i,
  * 由于后序遍历是左右根，因此我们容易得出。 postorder 中的0到i(包含)是左子树，preorder的1到i+1（包含）也是左子树

```
public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        return buildTreeNode(preorder, postorder, 0, preorder.length - 1, 0, postorder.length);
    }

    private TreeNode buildTreeNode(int[] preorder, int[] postorder, int preLeft, int preRight, int leftPost, int rightPost) {
        if (preRight < preLeft || rightPost < leftPost) {
            return null;
        }
        int rootVal = preorder[preLeft];
        TreeNode root = new TreeNode(rootVal);
        if (preRight == preLeft) {
            return root;
        }
        int rootPostIdx = 0; //包含了最后一个节点
        while (preorder[preLeft + 1] != postorder[rootPostIdx]) {
            rootPostIdx++;
        }
        root.left = buildTreeNode(preorder, postorder, preLeft + 1, preLeft + rootPostIdx - leftPost + 1, leftPost, rootPostIdx);
        root.right = buildTreeNode(preorder, postorder, preLeft + rootPostIdx - leftPost + 2, preRight, rootPostIdx + 1, rightPost);
        return root;
    }
```

* 【111】给定一个二叉树，找出其最小深度，最小深度是从根节点到最近叶子节点的最短路径上的节点数量，说明：叶子节点是指没有子节点的节点
  * 注意最小深度是从根节点到最近叶子节点的最短路径上的节点数量
  * 需要将左和右为空的情况分开计算，这个和最大深度不一样
```
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftLen = minDepth(root.left), rightLen = minDepth(root.right);
        if (root.left == null) {
            return rightLen + 1;
        }
        if (root.right == null) {
            return leftLen + 1;
        }
        return Math.min(leftLen, rightLen) + 1;
    }
```

* 【669】给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变

```
   public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) {
            return null;
        }
        if (root.val < low) {//小于下边界，说明左树已经没希望了
            return trimBST(root.right, low, high);
        }
        if (root.val > high) {//大于上边界，说明右边界已经没希望了
            return trimBST(root.left, low, high);
        }
        root.left = trimBST(root.left, low, high);//正常的节点
        root.right = trimBST(root.right, low, high);//正常的节点
        return root;
    }
```



* 【581】最短无序连续子数组，给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
请你找出符合题意的 最短 子数组，并输出它的长度。
  *  双重递归 思路：首先先序递归遍历每个节点，再以每个节点作为起始点递归寻找满足条件的路径。
```
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return 0;
        }
        return pathSumFrom(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
    }

    private int pathSumFrom(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        return (sum == root.val ? 1 : 0) + pathSumFrom(root.left, sum - root.val)
                + pathSumFrom(root.right, sum - root.val);
    }
```



* 【572】另一棵树的子树，给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。

二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。
```
   public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (root == null) {
            return false;
        }
        return dfs(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }

    private boolean dfs(TreeNode root, TreeNode subRoot) {
        if (root == null && subRoot == null) {
            return true;
        }
        if (root != null && subRoot != null) {
            return root.val == subRoot.val
                    && dfs(root.left, subRoot.left) && dfs(root.right, subRoot.right);
        }
        return false;
    }
```

* 【1104】二叉树寻路,在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。

如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；

而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。



给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的

```
    /**
Normally Ordered Binary Tree:
             1
           /   \
         2       3
       /  \     /  \
     4     5   6     7
   / |    /|   |\    | \
 8   9  10 11 12 13  14  15


 Zig Zag Binary Tree:
             1
           /   \
         3       2  <- 3+2-3 = 2/2 = 1
       /  \     /  \
     4     5   6     7   <- 7+4-4 = 7/2 = 3
   / |    /|   |\    | \
 15 14  13 12 11 10  9  8   <- 15+8-14 = 9/2 = 4

 反演公式：（当前级别的最大数量 + 当前级别的最小数量）- 当前数量
例如要找到 14 的反演： 15 + 8 - 14 = 9
从这里你只需将 9 除以 2 即可找到父 4

想法 3）您必须在每个级别运行反转公式，因为在每个级别，该行都相对于前一行反转
    */
    public List<Integer> pathInZigZagTree(int label) {
        int level = 1, maxCount = 1;
        while (maxCount * 2 <= label) {
            maxCount *= 2;
            level++;
        }
        List<Integer> res = new LinkedList<>();
        while (label > 0) {
            res.add(label);
            int curLevelMax = (int) Math.pow(2, level) - 1,  curLevelMin = (int) Math.pow(2, level - 1) ;
            label = (curLevelMax + curLevelMin - label)/2;
            level--;
        }
        Collections.reverse(res);
        return res;
    }
```


* 【117】填充每个节点的下一个右侧节点指针 II，填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL
```
    public Node connect(Node root) {
        if (root == null)
            return root;
        Deque<Node> deque = new ArrayDeque<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            Node pre = null;
            while (size-- > 0) {
                Node node = deque.poll();
                if (pre != null) {
                    pre.next = node;
                }
                pre = node;
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return root;
    }

    //优化方法
    public Node connect(Node root) {
        if (root == null)
            return root;
        //cur我们可以把它看做是每一层的链表
        Node cur = root;
        while (cur != null) {
            //遍历当前层的时候，为了方便操作在下一
            //层前面添加一个哑结点（注意这里是访问
            //当前层的节点，然后把下一层的节点串起来）
            Node dummy = new Node(0);
            //pre表示访下一层节点的前一个节点
            Node pre = dummy;
            //然后开始遍历当前层的链表
            while (cur != null) {
                if (cur.left != null) {
                    //如果当前节点的左子节点不为空，就让pre节点
                    //的next指向他，也就是把它串起来
                    pre.next = cur.left;
                    //然后再更新pre
                    pre = pre.next;
                }
                //同理参照左子树
                if (cur.right != null) {
                    pre.next = cur.right;
                    pre = pre.next;
                }
                //继续访问这样行的下一个节点
                cur = cur.next;
            }
            //把下一层串联成一个链表之后，让他赋值给cur，
            //后续继续循环，直到cur为空为止
            cur = dummy.next;
        }
        return root;
    }
```

* 【559】N 叉树的最大深度,给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）
```
    public int maxDepth(Node root) {
        if (root == null) {
            return 0;
        }
        int max = 0;
        for (Node child : root.children) {
            max = Math.max(max, maxDepth(child));
        }
        return max + 1;
    }
```

【1367】二叉树中的列表。给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。

如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。

一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。
  * 递归调用
  * 注意是判断其中的某一段，所以不能因为head != null && root != null来判断是否为真值，因为可能，list到头了，head还没到头呢

```
    public boolean isSubPath(ListNode head, TreeNode root) {
        if (head == null) return true;
        if (root == null) return false;
        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);
    }

    private boolean dfs(ListNode head, TreeNode root) {
        if (head == null) return true;
        if (root == null) return false;
        return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));
    }


    //错误代码。。。。。。。。。。。。
        public boolean isSubPath(ListNode head, TreeNode root) {
        if (head == null && root == null) {
            return true;
        }
        if (head != null && root != null) {
            return dfs(head, root) || isSubPath(head, root.left) ||  isSubPath(head, root.right);
        }
        return false;
    }

    private boolean dfs(ListNode head, TreeNode root) {
        if (head == null && root == null) {
            return true;
        }
        if (head != null && root != null) {
            return head.val == root.val && (dfs(head.next, root.left) || dfs(head.next, root.right));
        }
        return false;
    }
```


* 【235】 二叉搜索树的最近公共祖先
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
  * 这里和最近公共祖先不同的是，这里是二叉搜索树，可以利用其性质
```
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return (root.val - p.val) * (root.val - q.val) <= 0
                ? root : lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);
    }
```

* 【617】合并二叉树
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:
```
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) {
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    return new TreeNode(root1.val + root2.val,
            mergeTrees(root1.left, root2.left),
            mergeTrees(root1.right, root2.right));
}
```
* 【109】 有序链表转换二叉搜索树
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
  * 快慢指针找中点
```
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) {
            return null;
        }
        if (head.next == null) {
            return new TreeNode(head.val);
        }
        ListNode p = head, q = head, pre = null;
        while (q != null && q.next != null) {
            pre = p;
            p = p.next;
            q = q.next.next;
        }
        pre.next = null;
        TreeNode root = new TreeNode(p.val);
        root.left = sortedListToBST(head);
        root.right = sortedListToBST(p.next);
        return root;
    }
```
* 【589】 N 叉树的前序遍历
给定一个 N 叉树，返回其节点值的 前序遍历 。

N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。

```
   List<Integer> pre = new ArrayList<Integer>();

    public List<Integer> preorder(Node root) {
        dfs(root);
        return pre;
    }

    public void dfs(Node root) {
        if (root == null) {
            return;
        }
        pre.add(root.val);
        for (Node n : root.children) {
            dfs(n);
        }
    }
```

* 【967】 连续差相同的数字
返回所有长度为 n 且满足其每两个连续位上的数字之间的差的绝对值为 k 的 非负整数 。

请注意，除了 数字 0 本身之外，答案中的每个数字都 不能 有前导零。例如，01 有一个前导零，所以是无效的；但 0 是有效的。

你可以按 任何顺序 返回答案。
  * 广度优先遍历
```
   public int[] numsSameConsecDiff(int n, int k) {
        Deque<Integer> deque = new ArrayDeque<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));
        while (n-- > 1) {
            int size = deque.size();
            while (size-- > 0) {
                int a = deque.poll(), d1 = a % 10 + k, d2 = a % 10 - k;
                if (d1 <= 9) {
                    deque.offer(a * 10 + d1);
                }
                if (d2 >= 0 && d1 != d2) {
                    deque.offer(a * 10 + d2);
                }
            }
        }
        return deque.stream().mapToInt(i -> i).toArray();
    }
```

* 【386】 字典序排数
给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。

你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。
  * 10叉数的先序遍历
```
    public List<Integer> lexicalOrder(int n) {
        for (int i = 1; i <= 9; i++) {
            dfs(i, n);
        }
        return ans;
    }

    private void dfs(int i, int n) {
        if (i > n) {
            return;
        }
        ans.add(i);
        for (int j = 0; j <= 9; j++) {
            dfs(i * 10 + j, n);
        }
    }
    List<Integer> ans = new ArrayList<>();
```

* 【Offer 32 - III】. 从上到下打印二叉树 III
请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
```
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        int level = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            LinkedList<Integer> res = new LinkedList<>();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                if (level % 2 == 0) {
                    res.addLast(node.val);
                } else {
                    res.addFirst(node.val);
                }
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            ans.add(res);
            level++;
        }
        return ans;
    }
```


* 【951】翻转等价二叉树
我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。

只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。

编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。
```
   public boolean flipEquiv(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) {
            return true;
        }
        if (root1 == null || root2 == null) {
            return false;
        }
        if (root1.val == root2.val) {
            return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));
        }
        return false;
    }
```


* 【107】二叉树的层序遍历 II
给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
  * 层序遍历
  * 用栈存储即可
```
   public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if (root == null) {
            return Collections.emptyList();
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        Deque<List<Integer>> res = new ArrayDeque<>();

        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            List<Integer> tem = new ArrayList<>();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                tem.add(node.val);
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            res.push(tem);
        }
        return new ArrayList<>(res);
    }
```


* 【515】在每个树行中找最大值
给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值

```
  public List<Integer> largestValues(TreeNode root) {
      //  return largestValues2(root);

        if (root == null) {
            return Collections.emptyList();
        }
        Map<Integer,Integer> map = new HashMap<>();
        largestValues1(root, 0, map);
        return new ArrayList<>(map.values());
    }

    public List<Integer> largestValues2(TreeNode root) {
        if (root == null) {
            return Collections.emptyList();
        }
        Deque<TreeNode> nodes = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        nodes.offer(root);
        while (!nodes.isEmpty()) {
            int size =  nodes.size();
            long max = Long.MIN_VALUE;
            for (int i = 0; i < size; i++) {
                TreeNode node = nodes.poll();
                max = Math.max(node.val, max);
                if (node.left!=null) {
                    nodes.offer(node.left);
                }
                if(node.right != null) {
                    nodes.offer(node.right);
                }
            }
            result.add(Long.valueOf(max).intValue());
        }
        return result;
    }

    public static void largestValues1(TreeNode root, int level, Map<Integer, Integer> result) {
        if (root == null) {
            return;
        }
        result.put(level, Math.max(result.getOrDefault(level, Integer.MIN_VALUE),root.val));
        largestValues1(root.left, ++level, result);
        largestValues1(root.right, level, result);
    }
```
* 【994】. 腐烂的橘子
在给定的网格中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1
  * 想想我们倒数第二次进入while循环的时候，我们已经把所有的橙子都标记为rotted了（这里不用管-1的情况），并把它们加入到队列中，意思是当我们进入while在最后一次循环中，我们已经污染了所有的橙子，但仍然污染了（count++）。所以我们需要删除这个时间，因为所有的橙子在倒数第二时间都已经腐烂了
```
    public int orangesRotting(int[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        Deque<int[]> deque = new ArrayDeque<>();
        int fresh = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 2) {
                    deque.offer(new int[]{i, j});
                } else if (grid[i][j] == 1) {
                    fresh++;
                }
            }
        }
        if (fresh == 0) return 0;
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        int level = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            while (size-- > 0) {
                int[] cur = deque.poll();
                for (int[] dir : dirs) {
                    int x = cur[0] + dir[0], y = cur[1] + dir[1];
                    if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != 1) {
                        continue;
                    }
                    grid[x][y] = 2;
                    deque.offer(new int[]{x, y});
                    fresh--;
                }
            }
            level++;
        }
        return fresh > 0 ? -1 : level - 1;
    }
```

* 【449】序列化和反序列化二叉搜索树
序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。

设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。

编码的字符串应尽可能紧凑。
```

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuffer str = new StringBuffer();
        dfs(root, str);
        return str.toString();
    }

    private void dfs(TreeNode root, StringBuffer str) {
        if (root == null) {
            return;
        }
        str.append(root.val).append(",");
        dfs(root.left, str);
        dfs(root.right, str);
    }


    public TreeNode deserialize(String data) {
        if (data.isEmpty()) {
            return null;
        }
        Deque<String> deque = new ArrayDeque<>(Arrays.asList(data.substring(0, data.length() - 1).split(",")));
        return deserialize(deque, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    private TreeNode deserialize(Deque<String> deque, int minValue, int maxValue) {
        if (deque.isEmpty()) {
            return null;
        }
        TreeNode cur = new TreeNode(Integer.valueOf(deque.peek()));
        if (cur.val > maxValue) { //因为是前序遍历，如果下一个值大于了二叉树的最大值，说明到头了
            return null;
        }
        deque.pop();
        cur.left = deserialize(deque, minValue, cur.val);
        cur.right = deserialize(deque, cur.val, maxValue);
        return cur;
    }

    //方案2
       // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuffer str = new StringBuffer();
        dfs(root, str);
        return str.toString();
    }

    private void dfs(TreeNode root, StringBuffer str) {
        if (root == null) {
            return;
        }
        str.append(root.val).append(",");
        dfs(root.left, str);
        dfs(root.right, str);
    }


    public TreeNode deserialize(String data) {
        if (data.isEmpty()) {
            return null;
        }
        Deque<String> deque = new ArrayDeque<>(Arrays.asList(data.substring(0, data.length() - 1).split(",")));
        return deserialize(deque, Integer.MAX_VALUE);
    }

    private TreeNode deserialize(Deque<String> deque, int maxValue) {
        if (deque.isEmpty()) {
            return null;
        }
        TreeNode cur = new TreeNode(Integer.valueOf(deque.peek()));
        if (cur.val > maxValue) { //因为是前序遍历，如果下一个值大于了二叉树的最大值，说明到头了
            return null;
        }
        deque.pop();
        cur.left = deserialize(deque, cur.val);
        cur.right = deserialize(deque, maxValue);
        return cur;
    }
```


```
   public List<Double> averageOfLevels(TreeNode root) {
        List<Double> res = new ArrayList<>();
        if (root == null) return res;
        Queue<TreeNode> list = new LinkedList<>();
        list.add(root);
        while (list.size() != 0){
            int len = list.size();
            double sum = 0;
            for (int i = 0; i < len; i++){
                TreeNode node = list.poll();
                sum += node.val;
                if (node.left != null) list.add(node.left);
                if (node.right != null) list.add(node.right);
            }
            res.add(sum/len);
        }
        return res;
    }
```


* 【127】. 单词接龙
字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：

序列中第一个单词是 beginWord 。
序列中最后一个单词是 endWord 。
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词。
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。
  * 双向遍历
  * 单向遍历
```
   public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> banks = new HashSet<>(wordList);
        if (!banks.contains(endWord)) {
            return 0;
        }
        Deque<String> positive = new ArrayDeque<>(), negative = new ArrayDeque<>();
        Set<String> visited = new HashSet<>();
        positive.offer(beginWord);
        negative.offer(endWord);
        int ans = 1;
        while (!positive.isEmpty() && !negative.isEmpty()) {
            ans++;
            if (positive.size() > negative.size()) {
                Deque<String> temp = negative;
                negative = positive;
                positive = temp;
            }
            int size = positive.size();
            while (size-- > 0) {
                String cur = positive.poll();
                for (String s : generate(cur, banks)) {
                    if (negative.contains(s)) {
                        return ans;
                    }
                    if (visited.contains(s)) {
                        continue;
                    }
                    visited.add(s);
                    positive.offer(s);
                }
            }
        }
        return 0;
    }

    private List<String> generate(String cur, Set<String> dict) {
        char[] curChars = cur.toCharArray();
        List<String> nextList = new ArrayList<>();
        for (int i = 0; i < curChars.length; i++) {
            char oldChar = curChars[i];
            for (char j = 'a'; j <= 'z'; j++) {
                if (oldChar != j) {
                    curChars[i] = j;
                    String next = new String(curChars);
                    if (dict.contains(next)) {
                        nextList.add(next);
                    }
                    curChars[i] = oldChar;
                }
            }
        }
        return nextList;
    }

   public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (beginWord.equals(wordList)) {
            return 0;
        }
        Set<String> dict = wordList.stream().collect(Collectors.toSet());
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);
        Deque<String> deque = new ArrayDeque<>();
        deque.offer(beginWord);
        int ans = 0;
        while (!deque.isEmpty()) {
            ans++;
            int size = deque.size();
            while (size-- > 0) {
                String cur = deque.poll();
                if (cur.equals(endWord)) {
                    return ans;
                }
                for (String s : generate(cur, dict)) {
                    if (!visited.contains(s)) {
                        visited.add(s);
                        deque.offer(s);
                    }
                }
            }

        }
        return 0;
    }

    private List<String> generate(String cur, Set<String> dict) {
        char[] curChars = cur.toCharArray();
        List<String> nextList = new ArrayList<>();
        for (int i = 0; i < curChars.length; i++) {
            char oldChar = curChars[i];
            for (char j = 'a'; j <= 'z'; j++) {
                if (oldChar != j) {
                    curChars[i] = j;
                    String next = new String(curChars);
                    if (dict.contains(next)) {
                        nextList.add(next);
                    }
                    curChars[i] = oldChar;
                }
            }
        }
        return nextList;
    }
```