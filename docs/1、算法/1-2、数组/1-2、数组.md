## 1. 概念
## 2. 经典题目
* 【41】给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数。
  * 如果将元素能够一一对应下标，那么遇到第一个和元素不相等的下标时即时没有出现的最小的正整数
  * 遍历原数组
  * 遇到当前元素要对应的数组的位置不一致，则交换，循环判断，因为要对应的数组的值交换过来大概率可能也不满足相等的条件，直到不能满足>0或者不相等。

```
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
                swap(nums, nums[i] - 1, i);
            }
        }
        for (int i = 0; i < len; i++) {
            if (nums[i] != i + 1) {
                return i+1;
            }
        }
        return len+1;
    }

    public void swap(int[] nums, int i , int j) {
        if (i == j) {
            return;
        }
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

* 【48】给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度
  * 上下反转
  * 对接反转
```
    public void rotate(int[][] matrix) {
        int col = matrix[0].length, row = matrix.length;
        //up and down swap
        for (int i = 0; i < row/2; i++) {
            for (int j = 0; j < col; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[col - i - 1][j];
                matrix[col - i - 1][j] = temp;
            }
        }
        //对角线交换
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < i; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
```  


* 【88】给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目.请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 
  * 注意从后往前插入
  * 哪个大就拿哪个插入
  * 有可能j完了，i还没完，那么就不用插入了，说明已经完成了
  * 如果i完了，如果没还需要插入j
```
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (j >= 0) {
            nums1[k--] = i < 0 || nums2[j] > nums1[i] ? nums2[j--] : nums1[i--];
        }
    }
```


* 【498】给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。
  * 这里需要基于一个事实，往上走和往下走的i+j的和是相等的。
  * 注意这里往上走，到头了，两个都满足，优先下移动
  * 往下走，到头了，两个都满足，优先右移动
```
    public int[] findDiagonalOrder(int[][] mat) {
        if (mat == null || mat.length == 0) {
            return new int[]{};
        }
        int row = mat.length, col = mat[0].length;
        int[] res = new int[row * col];
        for (int i = 0, r = 0, c = 0; i < res.length; i++) {
            res[i] = mat[r][c];
            //如果为偶数向上跑
            if ((r + c) % 2 == 0) {
                //优先下移动，如果向上到了最右边
                if (c >= col - 1) {
                    r++;
               //如果向上到顶了, 右移动
                } else if (r <= 0) {
                    c++;
                } else {
                    r--;
                    c++;
                }
                //如果为奇数向下跑
            } else {
                //优先右移动，如果向下到底了, 右移动
                if (r >= row - 1) {
                    c++;
                //如果向下到了最左
                } else if (c <= 0) {
                    r++;
                } else {
                    c--;
                    r++;
                }
            }
        }
        return res;
    }
```


* 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。 
  * 有重复的数可以看成有环的链表
  * 1,3,4,2,2

![](环形数组重复数组.png)
```
    public int findDuplicate(int[] nums) {
        //有重复数字的数组可以看成是有环的链表
        int slow = 0, fast = nums[0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        fast = nums[slow];
        slow = 0;
        while (slow != nums[fast]) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return nums[fast];
    }
```

* 【59】给你一个正整数 n ，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
  * 定义上下左右四个边界
  * 模拟螺线增加即可。
```
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int t = 0, b = n - 1, l = 0, r = n - 1, idx = 1;
        while (idx <= n * n) {
            for (int i = l; i <= r; i++) {
                res[t][i] = idx++;
            }
            t++;
            for (int i = t; i <= b; i++) {
                res[i][r] = idx++;
            }
            r--;
            for (int i = r; i >= l; i--) {
                res[b][i] = idx++;
            }
            b--;
            for (int i = b; i >= t; i--) {
                res[i][l] = idx++;
            }
            l++;
        }
        return res;
    }
```