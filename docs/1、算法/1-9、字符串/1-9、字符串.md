## 1. 概述
## 2. 经典算法
* 【394】给定一个经过编码的字符串，返回它解码后的字符串3[a2[c]]转化成accaccacc
  * 使用栈保存循环的次数
  * 使用栈保存[以前的字符串，因为有可能要取出来和拼接好的的字符组合。
  * stringbufer先存储字母，遇到了[需要暂且存到栈里，遇到]需要从栈中取出来拼接重复
```
        //保存数字
        Deque<Integer> nums = new ArrayDeque<>();
        Deque<String> preStr = new ArrayDeque();
        StringBuffer repeatStr = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //如果当前是数字
            if (Character.isDigit(c)) {
                int num = c - '0';
                while (Character.isDigit(s.charAt(i + 1))) {
                    num = (s.charAt(++i) - '0') + num * 10;
                }
                nums.push(num);
                //如果出现了[，需要重新拼接[]里面的字符串了，存放到preStr里面
            } else if (c == '[') {
                preStr.push(repeatStr.toString());
                repeatStr.setLength(0);
            } else if (c == ']') {
                int num = nums.pop();
                StringBuffer temp = new StringBuffer();
                temp.append(preStr.pop());
                while (num-- > 0) {
                    temp.append(repeatStr);
                }
                repeatStr = new StringBuffer(temp.toString());
            } else if (Character.isLetter(c)) {
                repeatStr.append(c);
            }
        }
        return repeatStr.toString();
```


* 【8】请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）
  * 先找到数字的开头
  * 判断是+还是-
  * 拼接数字，注意是否越界
  * 和边界的十位以上比较
  * 如果直接大于十位以上就越界了
  * 如果等于边界的十位以上， 比较个位数即可。
```
    public int myAtoi(String s) {
        int idx = 0;
        while (idx < s.length() && s.charAt(idx) == ' ') {
            idx++;
        }
        if (idx == s.length()) {
            return 0;
        }
        int sign = 1, res = 0;
        if (s.charAt(idx) == '-') {
            sign = -1;
            idx++;
        } else if (s.charAt(idx) == '+') {
            idx++;
        }
        while (idx < s.length() && Character.isDigit(s.charAt(idx))) {
            //有两种情况：
            // ① res乘以10直接就大于边界了
            // ② res等于边界，需要比较下一位和边界的个位数比较，
            if (res > Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 && (s.charAt(idx) - '0') > 7)) {
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            res =s.charAt(idx++) - '0' +  res * 10;
        }
        return res * sign;
    }
```