## 1. 概述
## 2. 经典算法
* 【394】给定一个经过编码的字符串，返回它解码后的字符串3[a2[c]]转化成accaccacc
  * 使用栈保存循环的次数
  * 使用栈保存[以前的字符串，因为有可能要取出来和拼接好的的字符组合。
  * stringbufer先存储字母，遇到了[需要暂且存到栈里，遇到]需要从栈中取出来拼接重复
```
        //保存数字
        Deque<Integer> nums = new ArrayDeque<>();
        Deque<String> preStr = new ArrayDeque();
        StringBuffer repeatStr = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //如果当前是数字
            if (Character.isDigit(c)) {
                int num = c - '0';
                while (Character.isDigit(s.charAt(i + 1))) {
                    num = (s.charAt(++i) - '0') + num * 10;
                }
                nums.push(num);
                //如果出现了[，需要重新拼接[]里面的字符串了，存放到preStr里面
            } else if (c == '[') {
                preStr.push(repeatStr.toString());
                repeatStr.setLength(0);
            } else if (c == ']') {
                int num = nums.pop();
                StringBuffer temp = new StringBuffer();
                temp.append(preStr.pop());
                while (num-- > 0) {
                    temp.append(repeatStr);
                }
                repeatStr = new StringBuffer(temp.toString());
            } else if (Character.isLetter(c)) {
                repeatStr.append(c);
            }
        }
        return repeatStr.toString();
```


* 【8】请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）
  * 先找到数字的开头
  * 判断是+还是-
  * 拼接数字，注意是否越界
  * 和边界的十位以上比较
  * 如果直接大于十位以上就越界了
  * 如果等于边界的十位以上， 比较个位数即可。
```
    public int myAtoi(String s) {
        int idx = 0;
        while (idx < s.length() && s.charAt(idx) == ' ') {
            idx++;
        }
        if (idx == s.length()) {
            return 0;
        }
        int sign = 1, res = 0;
        if (s.charAt(idx) == '-') {
            sign = -1;
            idx++;
        } else if (s.charAt(idx) == '+') {
            idx++;
        }
        while (idx < s.length() && Character.isDigit(s.charAt(idx))) {
            //有两种情况：
            // ① res乘以10直接就大于边界了
            // ② res等于边界，需要比较下一位和边界的个位数比较，
            if (res > Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 && (s.charAt(idx) - '0') > 7)) {
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            res =s.charAt(idx++) - '0' +  res * 10;
        }
        return res * sign;
    }
```

* 【227】给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值
  * 遇到+、-需要处理tempRes的值，将其累加
```
    public int calculate(String s) {
        //遇到数字就存储到tempNum，遇到一个运算符，可根据上一个运算符来判断如何存储
        //如果上一个字符为+或-号，说明这以前的数字可以了结了。
        //0+a+z*c*e+b+c*d/f*s/x
        int tempRes = 0, res = 0, num = 0;
        char preSign = '+';
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                num = c - '0' + num * 10;
            }
            // 0 + 2+3-5/2*3 + 3 - 1
            //如果是最后一个数字字符，或者是加减乘除字符串
            if (i == s.length() - 1 || (!Character.isDigit(c) && c != ' ')) {
                switch (preSign) {
                    //上一个字符是加号
                    case '+':
                        res += tempRes;
                        tempRes = num;
                        break;
                    case '-':
                        res += tempRes;
                        tempRes = -num;
                        break;
                    case '*':
                        tempRes *= num;
                        break;
                    case '/':
                        tempRes /= num;
                        break;
                }
                num = 0;
                preSign = c;
            }
        }
        return res + tempRes;
    }
```

* 【151】 翻转字符串里的单词
  * 原地交换算法：
  * 先反转整个字符串
  * 逐个反转每一个单词
  * 去除多余的空格
```
    public String reverseWords(String s) {
        char[] charArray = s.toCharArray();
        reverse(charArray, 0, charArray.length - 1);
        reverseWords(charArray);
        return cleanSpace(charArray);
    }

    public void reverseWords(char[] charArray) {
        int i = 0, j = 0;
        while (j < charArray.length) {
            while (i < j || (i < charArray.length && charArray[i] == ' ')) {  // 设置新的单词起点（小于之前的j或者为空字符）
                i++;
            }
            while (i > j || (j < charArray.length && charArray[j] != ' ')) {  //设置新的单词结束点（大于之前的j或者为字母）
                j++;
            }
            reverse(charArray, i, j - 1);
        }
    }

    public String cleanSpace(char[] charArray) {
        int i = 0, j = 0;
        while (j < charArray.length) {
            while (j< charArray.length && charArray[j] == ' ') {
                j++;
            }
            while (j < charArray.length && charArray[j] != ' ') {
                charArray[i++] = charArray[j++];
            }
            while (j< charArray.length && charArray[j] == ' ') {
                j++;
            }
            if (j < charArray.length) {
                charArray[i++] = ' ';
            }
        }
        return new String(charArray).substring(0, i);
    }

    public void reverse(char[] array, int lo, int hi) {
        while (lo < hi) {
            char lv = array[lo];
            array[lo] = array[hi];
            array[hi] = lv;
            lo++;
            hi--;
        }
    }
```

* 【43】给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式
  * 乘数 num1 位数为 MM，被乘数 num2 位数为 NN， num1 x num2 结果 res 最大总位数为 M+N
  * num1[i] x num2[j] 的结果为 tmp(位数为两位，"0x","xy"的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]
  ![](字符串数字相乘.png) 
```
    public String multiply(String num1, String num2) {
        int n1 = num1.length(), n2 = num2.length();
        if (n1 == 0 || n2 == 0) {
            return "";
        }
        int[] res = new int[n1 + n2];
        for (int i = n1 - 1; i >= 0; i--) {
            for (int j = n2 - 1; j >= 0; j--) {
                int p1 = i + j, p2 = i + j + 1;
                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0') + res[p2];
                res[p2] = mul % 10;
                res[p1] += mul / 10;
            }
        }
        StringBuffer buffer = new StringBuffer();
        for (int i = 0; i < res.length; i++) {
            if (buffer.length() == 0 && res[i] == 0 && i < res.length - 1) {
                continue;
            }
            buffer.append(res[i]);
        }
        return buffer.toString();
    }
//参考解答 https://leetcode-cn.com/problems/multiply-strings/solution/gao-pin-mian-shi-xi-lie-zi-fu-chuan-cheng-fa-by-la
```

* 【224】给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值(1+(4+5+2)-3)+(6+8)
  * 熟练度。
```
   public int calculate(String s) {
        Deque<Integer> deque = new ArrayDeque<>();
        int res = 0, lastSign = 1;
        for (int i = 0; i < s.length(); i++) {
            if (Character.isDigit(s.charAt(i))) {
                int num = s.charAt(i) - '0';
                while (i < s.length() - 1 && Character.isDigit(s.charAt(i + 1))) {
                    num = (s.charAt(++i) - '0') + num * 10;
                }
                res = lastSign * num + res;
            } else if (s.charAt(i) == ')') {
                res = deque.pop() + deque.pop() * res;
            } else if (s.charAt(i) == '(') {
                deque.push(lastSign);
                deque.push(res);
                res = 0;
                lastSign = 1;
            } else if (s.charAt(i) == '+') {
                lastSign = 1;
            } else if (s.charAt(i) == '-') {
                lastSign = -1;
            }
        }
        return res;
    }
```
* 【14】编写一个函数来查找字符串数组中的最长公共前缀。
```
    public String longestCommonPrefix(String[] strs) {
        String base = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while (strs[i].indexOf(base) != 0) {
                base = base.substring(0, base.length() - 1);
            }
        }
        return base;
    }
```

* 【166】给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数，如果小数部分为循环小数，则将循环的部分括在括号内，如果存在多个答案，只需返回 任意一个，对于所有给定的输入，保证 答案字符串的长度小于 104 
  * 哈希表记录所有被除数的下标，如果出现了重复的被除数，则证明出现了循环，把左括号塞到记录的下标位置，右括号放在最后
```
   public String fractionToDecimal(int numerator, int denominator) {
        StringBuffer res = new StringBuffer();
        long a = numerator, b = denominator;
        if (a < 0 && b > 0 || a > 0 && b < 0) {
            res.append("-");
        }
        a = Math.abs(a);
        b = Math.abs(b);
        res.append(a / b);
        if (a % b == 0) {
            return res.toString();
        }
        res.append(".");
        Map<Long, Integer> hash = new HashMap<>();
        while ((a = a % b * 10) > 0 && !hash.containsKey(a)) {
            res.append(a / b);
            hash.put(a, res.length() - 1);
        }
        if (a == 0) {
            return res.toString();
        }
        return res.insert(hash.get(a).intValue(), "(").append(")").toString();
    }
```

* 【28】给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1
  * 简单的是暴力法
  * kmp法

```
    //暴力法
    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) {
            return 0;
        }
        int m = haystack.length(), n = needle.length();
        for (int i = 0; i <= m - n; i++) {
            for (int j = 0; j < n; j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    break;
                }
                if (j == n - 1) {
                    return i;
                }
            }
        }
        return -1;
    }
```


* 【】将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
  * 字符串s是以Z字形为顺序存储的字符串，目标是按行打印。
  * 设numRows行字符串分别为ssn，则容易发现:按顺序遍历字符串s时，每个字符
    c在Z字形中对应的行索引先从s增大至sn，再从s减小至s1如此反复。
  * 因此，解决方案为:模拟这个行索引的变化，在遍历s中把每个字符填到正确的行res[i]。
  * 算法流程:按顺序遍历字符串s;
  *  1.res[i] +=c:把每个字符填入对应行si
  *  2 i+=flag:更新当前字符c对应的行索引;
  * 3.f1ag=-f1ag:在达到Z字形转折点时，执行反向。
```
   public String convert(String s, int numRows) {
        if (numRows < 2) {
            return s;
        }
        StringBuffer[] buffers = new StringBuffer[numRows];
        for (int i = 0; i < buffers.length; i++) {
            buffers[i] = new StringBuffer();
        }
        int sign = -1, idx = 0;
        for (char c : s.toCharArray()) {
            buffers[idx] = buffers[idx].append(c);
            if (idx == 0 || idx == numRows - 1) {
                sign = - sign;
            }
            idx += sign;
        }
        return Stream.of(buffers).collect(Collectors.joining());
    }
```

* 【71】给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径.在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成。部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。 /a/./b/../../c/ -》 /c
  * 使用spilt切割
  * 注意上述有可能产生空字符串
  * 如果是..则从结果移除
  * 如果是.则contineu
```
    public String simplifyPath(String path) {
        Deque<String> deque = new LinkedList<>();
        //输入：path = "/a/./b/../../c/"
        //输出："/c"
        for (String s : path.split("/")) {
            if (s.equals("..")) {
                if (!deque.isEmpty()) {
                    deque.pollLast();
                }
            } else if (s.equals(".") || s.isEmpty()) {
                continue;
            } else {
                deque.addLast(s);
            }
        }
        return "/" + String.join("/", deque);
    }
```