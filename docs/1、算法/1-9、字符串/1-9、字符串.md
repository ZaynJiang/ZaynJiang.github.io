## 1. 概述
## 2. 经典算法
* 【394】给定一个经过编码的字符串，返回它解码后的字符串3[a2[c]]转化成accaccacc
  * 使用栈保存循环的次数
  * 使用栈保存[以前的字符串，因为有可能要取出来和拼接好的的字符组合。
  * stringbufer先存储字母，遇到了[需要暂且存到栈里，遇到]需要从栈中取出来拼接重复
```
        //保存数字
        Deque<Integer> nums = new ArrayDeque<>();
        Deque<String> preStr = new ArrayDeque();
        StringBuffer repeatStr = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //如果当前是数字
            if (Character.isDigit(c)) {
                int num = c - '0';
                while (Character.isDigit(s.charAt(i + 1))) {
                    num = (s.charAt(++i) - '0') + num * 10;
                }
                nums.push(num);
                //如果出现了[，需要重新拼接[]里面的字符串了，存放到preStr里面
            } else if (c == '[') {
                preStr.push(repeatStr.toString());
                repeatStr.setLength(0);
            } else if (c == ']') {
                int num = nums.pop();
                StringBuffer temp = new StringBuffer();
                temp.append(preStr.pop());
                while (num-- > 0) {
                    temp.append(repeatStr);
                }
                repeatStr = new StringBuffer(temp.toString());
            } else if (Character.isLetter(c)) {
                repeatStr.append(c);
            }
        }
        return repeatStr.toString();
```


* 【8】请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）
  * 先找到数字的开头
  * 判断是+还是-
  * 拼接数字，注意是否越界
  * 和边界的十位以上比较
  * 如果直接大于十位以上就越界了
  * 如果等于边界的十位以上， 比较个位数即可。
```
    public int myAtoi(String s) {
        int idx = 0;
        while (idx < s.length() && s.charAt(idx) == ' ') {
            idx++;
        }
        if (idx == s.length()) {
            return 0;
        }
        int sign = 1, res = 0;
        if (s.charAt(idx) == '-') {
            sign = -1;
            idx++;
        } else if (s.charAt(idx) == '+') {
            idx++;
        }
        while (idx < s.length() && Character.isDigit(s.charAt(idx))) {
            //有两种情况：
            // ① res乘以10直接就大于边界了
            // ② res等于边界，需要比较下一位和边界的个位数比较，
            if (res > Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 && (s.charAt(idx) - '0') > 7)) {
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            res =s.charAt(idx++) - '0' +  res * 10;
        }
        return res * sign;
    }
```

* 【227】给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值
  * 遇到+、-需要处理tempRes的值，将其累加
```
    public int calculate(String s) {
        //遇到数字就存储到tempNum，遇到一个运算符，可根据上一个运算符来判断如何存储
        //如果上一个字符为+或-号，说明这以前的数字可以了结了。
        //0+a+z*c*e+b+c*d/f*s/x
        int tempRes = 0, res = 0, num = 0;
        char preSign = '+';
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                num = c - '0' + num * 10;
            }
            // 0 + 2+3-5/2*3 + 3 - 1
            //如果是最后一个数字字符，或者是加减乘除字符串
            if (i == s.length() - 1 || (!Character.isDigit(c) && c != ' ')) {
                switch (preSign) {
                    //上一个字符是加号
                    case '+':
                        res += tempRes;
                        tempRes = num;
                        break;
                    case '-':
                        res += tempRes;
                        tempRes = -num;
                        break;
                    case '*':
                        tempRes *= num;
                        break;
                    case '/':
                        tempRes /= num;
                        break;
                }
                num = 0;
                preSign = c;
            }
        }
        return res + tempRes;
    }
```

* 【151】 翻转字符串里的单词
  * 原地交换算法：
  * 先反转整个字符串
  * 逐个反转每一个单词
  * 去除多余的空格
```
    public String reverseWords(String s) {
        char[] charArray = s.toCharArray();
        reverse(charArray, 0, charArray.length - 1);
        reverseWords(charArray);
        return cleanSpace(charArray);
    }

    public void reverseWords(char[] charArray) {
        int i = 0, j = 0;
        while (j < charArray.length) {
            while (i < j || (i < charArray.length && charArray[i] == ' ')) {  // 设置新的单词起点（小于之前的j或者为空字符）
                i++;
            }
            while (i > j || (j < charArray.length && charArray[j] != ' ')) {  //设置新的单词结束点（大于之前的j或者为字母）
                j++;
            }
            reverse(charArray, i, j - 1);
        }
    }

    public String cleanSpace(char[] charArray) {
        int i = 0, j = 0;
        while (j < charArray.length) {
            while (j< charArray.length && charArray[j] == ' ') {
                j++;
            }
            while (j < charArray.length && charArray[j] != ' ') {
                charArray[i++] = charArray[j++];
            }
            while (j< charArray.length && charArray[j] == ' ') {
                j++;
            }
            if (j < charArray.length) {
                charArray[i++] = ' ';
            }
        }
        return new String(charArray).substring(0, i);
    }

    public void reverse(char[] array, int lo, int hi) {
        while (lo < hi) {
            char lv = array[lo];
            array[lo] = array[hi];
            array[hi] = lv;
            lo++;
            hi--;
        }
    }
```

* 【43】给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式
  * 乘数 num1 位数为 MM，被乘数 num2 位数为 NN， num1 x num2 结果 res 最大总位数为 M+N
  * num1[i] x num2[j] 的结果为 tmp(位数为两位，"0x","xy"的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]
  ![](字符串数字相乘.png) 
```
    public String multiply(String num1, String num2) {
        int n1 = num1.length(), n2 = num2.length();
        if (n1 == 0 || n2 == 0) {
            return "";
        }
        int[] res = new int[n1 + n2];
        for (int i = n1 - 1; i >= 0; i--) {
            for (int j = n2 - 1; j >= 0; j--) {
                int p1 = i + j, p2 = i + j + 1;
                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0') + res[p2];
                res[p2] = mul % 10;
                res[p1] += mul / 10;
            }
        }
        StringBuffer buffer = new StringBuffer();
        for (int i = 0; i < res.length; i++) {
            if (buffer.length() == 0 && res[i] == 0 && i < res.length - 1) {
                continue;
            }
            buffer.append(res[i]);
        }
        return buffer.toString();
    }
//参考解答 https://leetcode-cn.com/problems/multiply-strings/solution/gao-pin-mian-shi-xi-lie-zi-fu-chuan-cheng-fa-by-la
```

* 【224】给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值(1+(4+5+2)-3)+(6+8)
  * 熟练度。
```
   public int calculate(String s) {
        Deque<Integer> deque = new ArrayDeque<>();
        int res = 0, lastSign = 1;
        for (int i = 0; i < s.length(); i++) {
            if (Character.isDigit(s.charAt(i))) {
                int num = s.charAt(i) - '0';
                while (i < s.length() - 1 && Character.isDigit(s.charAt(i + 1))) {
                    num = (s.charAt(++i) - '0') + num * 10;
                }
                res = lastSign * num + res;
            } else if (s.charAt(i) == ')') {
                res = deque.pop() + deque.pop() * res;
            } else if (s.charAt(i) == '(') {
                deque.push(lastSign);
                deque.push(res);
                res = 0;
                lastSign = 1;
            } else if (s.charAt(i) == '+') {
                lastSign = 1;
            } else if (s.charAt(i) == '-') {
                lastSign = -1;
            }
        }
        return res;
    }
```
* 【14】编写一个函数来查找字符串数组中的最长公共前缀。
```
    public String longestCommonPrefix(String[] strs) {
        String base = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while (strs[i].indexOf(base) != 0) {
                base = base.substring(0, base.length() - 1);
            }
        }
        return base;
    }
```

* 【166】给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数，如果小数部分为循环小数，则将循环的部分括在括号内，如果存在多个答案，只需返回 任意一个，对于所有给定的输入，保证 答案字符串的长度小于 104 
  * 哈希表记录所有被除数的下标，如果出现了重复的被除数，则证明出现了循环，把左括号塞到记录的下标位置，右括号放在最后
```
   public String fractionToDecimal(int numerator, int denominator) {
        StringBuffer res = new StringBuffer();
        long a = numerator, b = denominator;
        if (a < 0 && b > 0 || a > 0 && b < 0) {
            res.append("-");
        }
        a = Math.abs(a);
        b = Math.abs(b);
        res.append(a / b);
        if (a % b == 0) {
            return res.toString();
        }
        res.append(".");
        Map<Long, Integer> hash = new HashMap<>();
        while ((a = a % b * 10) > 0 && !hash.containsKey(a)) {
            res.append(a / b);
            hash.put(a, res.length() - 1);
        }
        if (a == 0) {
            return res.toString();
        }
        return res.insert(hash.get(a).intValue(), "(").append(")").toString();
    }
```

* 【28】给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1
  * 简单的是暴力法
  * kmp法

```
    //暴力法
    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) {
            return 0;
        }
        int m = haystack.length(), n = needle.length();
        for (int i = 0; i <= m - n; i++) {
            for (int j = 0; j < n; j++) {
                if (haystack.charAt(i + j) != needle.charAt(j)) {
                    break;
                }
                if (j == n - 1) {
                    return i;
                }
            }
        }
        return -1;
    }
```


* 【】将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
  * 字符串s是以Z字形为顺序存储的字符串，目标是按行打印。
  * 设numRows行字符串分别为ssn，则容易发现:按顺序遍历字符串s时，每个字符
    c在Z字形中对应的行索引先从s增大至sn，再从s减小至s1如此反复。
  * 因此，解决方案为:模拟这个行索引的变化，在遍历s中把每个字符填到正确的行res[i]。
  * 算法流程:按顺序遍历字符串s;
  *  1.res[i] +=c:把每个字符填入对应行si
  *  2 i+=flag:更新当前字符c对应的行索引;
  * 3.f1ag=-f1ag:在达到Z字形转折点时，执行反向。
```
   public String convert(String s, int numRows) {
        if (numRows < 2) {
            return s;
        }
        StringBuffer[] buffers = new StringBuffer[numRows];
        for (int i = 0; i < buffers.length; i++) {
            buffers[i] = new StringBuffer();
        }
        int sign = -1, idx = 0;
        for (char c : s.toCharArray()) {
            buffers[idx] = buffers[idx].append(c);
            if (idx == 0 || idx == numRows - 1) {
                sign = - sign;
            }
            idx += sign;
        }
        return Stream.of(buffers).collect(Collectors.joining());
    }
```

* 【71】给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径.在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成。部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。 /a/./b/../../c/ -》 /c
  * 使用spilt切割
  * 注意上述有可能产生空字符串
  * 如果是..则从结果移除
  * 如果是.则contineu
```
    public String simplifyPath(String path) {
        Deque<String> deque = new LinkedList<>();
        //输入：path = "/a/./b/../../c/"
        //输出："/c"
        for (String s : path.split("/")) {
            if (s.equals("..")) {
                if (!deque.isEmpty()) {
                    deque.pollLast();
                }
            } else if (s.equals(".") || s.isEmpty()) {
                continue;
            } else {
                deque.addLast(s);
            }
        }
        return "/" + String.join("/", deque);
    }
```

* 【】给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第i行源码。 删除//和/**/的注释
  * 定义一个块注释标识

```
   public List<String> removeComments(String[] source) {
        StringBuffer codeStr = new StringBuffer();
        List<String> res = new ArrayList<>();
        boolean block = false;
        for (String line : source) {
            for (int i = 0; i < line.length(); i++) {
                // 处于块状注释之中.
                if (block) {
                    //如果结束
                    if (line.charAt(i) == '*' && i < line.length() - 1 && line.charAt(i + 1) == '/') {
                        block = false;
                        i++;
                    }
                    //没有处于块状注释中，
                } else {
                    //如果后面是//，直接跳出
                    if (line.charAt(i) == '/' && i < line.length() - 1 && line.charAt(i + 1) == '/') {
                        break;
                        //如果是/*,说明是开头注释，继续循环看有没有结束的
                    } else if (line.charAt(i) == '/' && i < line.length() - 1 && line.charAt(i + 1) == '*') {
                        block = true;
                        i++;
                    } else {
                        codeStr.append(line.charAt(i));
                    }
                }
            }
            //如果有块注释，先不添加
            if (!block && codeStr.length() > 0) {
                res.add(codeStr.toString());
                codeStr.setLength(0);
            }
        }
        return res;
    }
```


* 【459】给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000
```
    public boolean repeatedSubstringPattern(String s) {
        //abcabcabcabc
        int n = s.length();
        //至少要有两个重复的，所以要保证2*i的样子。
        for (int i = 1; 2 * i <= n; i++) {
            //需要能被i整除的i才可能是重复的
            if (n % i == 0) {
                boolean check = true;
                for (int j = i; j < n; j++) {
                    //和第一截的每一位相比
                    if (s.charAt(j) != s.charAt(j - i)) {
                        check = false;
                    }
                }
                if (check) {
                    return true;
                }
            }
        }
        return false;
    }
```
* 【offer45】输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 
```
    public String minNumber(int[] nums) {
        return Arrays.stream(nums).mapToObj(String::valueOf).sorted((o1, o2) -> (o1 + o2).compareTo(o2 + o1)).collect(Collectors.joining());
    }
```


* 【767】重构字符串.给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。若可行，输出任意可行的结果。若不可行，返回空字符串
  * 需要根据每个字母在字符串中出现的次数处理每个字母放置的位置。如果出现次数最多的字母可以在重新排布之后不相邻，则可以重新排布字母使得相邻的字母都不相同。如果出现次数最多的字母过多，则无法重新排布字母使得相邻的字母都不相同
```
    public String reorganizeString(String s) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        //找出出现次数最大的次数的idx
        int maxIdx = 0;
        for (int i = 0; i < count.length; i++) {
            if (count[i] > count[maxIdx]) {
                maxIdx = i;
            }
        }
        //如果最大的次数超过了1半，则直接返回“”
        if (count[maxIdx] > (s.length() + 1) / 2) {
            return "";
        }
        char[] res = new char[s.length()];
        int idx = 0;
        //填充偶数位数
        while (count[maxIdx]-- > 0) {
            res[idx] = (char) (maxIdx + 'a');
            idx +=2;
        }
        //填充剩余的位数
        for (int i = 0; i < count.length; i++) {
            while (count[i]-- > 0) {
                if (idx >= res.length) {
                    //偶数填充完毕后，置为1，开始填充奇数
                    idx = 1;
                }
                res[idx] = (char) (i + 'a');
                idx +=2;
            }
        }
        return new String(res);
    }
```

* 【165】给你两个版本号 version1 和 version2 ，请你比较它们版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号.比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 
  * 两个指针一轮轮比较
  * 注意正则表达式中的“.”表示除“\n”外的所有字符，所以匹配实际的“.”就需要用“\.”进行标记来表示，但“\”符号的使用还需要配合转义符“\”，即“\\”表示为一个“\”。所以最后通过"\\."来进行“.”的匹配

```
   public int compareVersion(String version1, String version2) {
        String[] v1 = version1.split("."), v2 = version2.split(".");
        int idx1 = 0, idx2 = 0;
        while (idx1 < v1.length || idx2 < v2.length) {
            int num1 = idx1 < v1.length ? Integer.valueOf(v1[idx1++]) : 0,
                    num2 = idx2 < v2.length ? Integer.valueOf(v2[idx2++]) : 0;
            if (num1 != num2) {
                return num1 > num2 ? 1 : -1;
            }
        }
        return 0;
    }
```

* 【50】在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
  * 使用数组记录每个字符的次数
  * 遍历字符串，如果次数为1则返回该字符
```
    public char firstUniqChar(String s) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            if (count[s.charAt(i) - 'a'] == 1) {
                return s.charAt(i);
            }
        }
        return ' ';
    }
```

* 【168】给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。 
  * 这是一道从 11 开始的的 2626 进制转换题。对于一般性的进制转换题目，只需要不断地对 columnNumbercolumnNumber 进行 % 运算取得最后一位，然后对 columnNumbercolumnNumber 进行 / 运算，将已经取得的位数去掉，直到 columnNumbercolumnNumber 为 00 即可。一般性的进制转换题目无须进行额外操作，是因为我们是在「每一位数值范围在 [0,x)[0,x)」的前提下进行「逢 xx 进一」。但本题需要我们将从 11 开始，因此在执行「进制转换」操作前，我们需要先对 columnNumbercolumnNumber 执行减一操作，从而实现整体偏移。
```
    public String convertToTitle(int n) {
        StringBuffer buffer = new StringBuffer();
        while (n > 0) {
            n--;
            buffer.append((char)(n % 26 + 'A'));
            n/=26;
        }
        return buffer.reverse().toString();
    }
```


* 【949】给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。
  * arr = [1,2,3,4]，有效的 24 小时制时间是 "12:34"，"12:43"，"13:24"，"13:42"，"14:23"，"14:32"，"21:34"，"21:43"，"23:14" 和 "23:41" 。这些时间中，"23:41" 是最大时间 
```
    public String largestTimeFromDigits(int[] arr) {
        String res = "";
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                for (int k = 0; k < 4; k++) {
                    if (i == k || j == k || i == j) {
                        continue;
                    }
                    String h = "" + arr[i] + arr[j], m ="" +  arr[k] + arr[6-i-j-k], t =  h + ":"+m;
                    if (h.compareTo("24") < 0 && m.compareTo("60") < 0 && res.compareTo(t) < 0) {
                        res = t;
                    }
                }
            }
        }
        return res;
    }
```

* 【443】给你一个字符数组 chars ，请使用下述算法压缩。从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符。如果这一组长度为 1 ，则将字符追加到 s 中。否则，需要向 s 追加字符，后跟这一组的长度。压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。请在 修改完输入数组后 ，返回该数组的新长度。你必须设计并实现一个只使用常量额外空间的算法来解决此问题

```
    public int compress(char[] chars) {
        int idx = 0, i = 0;
        while (i < chars.length) {
            char cur = chars[i];
            int count = 0;
            while (i < chars.length && cur == chars[i]) {
                i++;
                count++;
            }
            chars[idx++] = cur;
            if (count != 1) {
                for (char c : String.valueOf(count).toCharArray()) {
                    chars[idx++] = c;
                }
            }
        }
        return idx;
    }
```

* 【125】给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串
  * 双指针跳过不符合要求的字符即可

```
   public boolean isPalindrome(String s) {
        int lo = 0, hi = s.length() - 1;
        while (lo < hi) {
            if (!Character.isLetterOrDigit(s.charAt(lo))) {
                lo++;
                continue;
            }
            if (!Character.isLetterOrDigit(s.charAt(hi))) {
                hi--;
                continue;
            }
            if (Character.toLowerCase(s.charAt(lo)) != Character.toLowerCase(s.charAt(hi))) {
                return false;
            }
            lo++;
            hi--;
        }
        return true;
```
* 【468】编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。 
```
    // 如果是有效的 IPv4 地址，返回 "IPv4" ； 
    // 如果是有效的 IPv6 地址，返回 "IPv6" ； 
    // 如果不是上述类型的 IP 地址，返回 "Neither" 。 
    // 
    //
    // IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(".")分割。比如，172.16.254.1； 
    //
    // 同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。 
    //
    // IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (":")分割。比如, 2001:0db8:85a3:0000:0
    //000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85
    //a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。 
    //
    // 然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334
    // 是无效的 IPv6 地址。 
    //
    // 同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的
    //。 
        public String validIPAddress(String queryIP) {
            return "IPv6".equals(isVailidIPV6(queryIP)) ? "IPv6" : isVildIPV4(queryIP);
        }
    
    private String isVailidIPV6(String queryIP) {
        String[] spilt = queryIP.split(":", -1);
        if (spilt.length != 8) {
            return "Neither";
        }
        String hex = "0123456789abcdefABCDEF";
        for (String s : spilt) {
            if (s.trim().length() == 0 || s.length() > 4) {
                return "Neither";
            }
            for (char c : s.toCharArray()) {
                if (hex.indexOf(c) == -1) {
                    return "Neither";
                }
            }
        }
        return "IPv6";
    }
    
    private String isVildIPV4(String queryIP) {
        String[] spilt = queryIP.split("\\.", -1);
        if (spilt.length != 4) {
            return "Neither";
        }
        for (String s : spilt) {
            if (s.trim().length() == 0 || (s.length() > 1 && s.startsWith("0") )|| s.length() > 3) {
                return "Neither";
            }
            for (char c : s.toCharArray()) {
                if (!Character.isDigit(c)) {
                    return "Neither";
                }
            }
            int num = Integer.valueOf(s);
            if (num < 0 || num >= 256) {
                return "Neither";
            }
        }
        return "IPv4";

 ```

* 【383】给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 
```
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] dict = new int[26];
        for (char c : magazine.toCharArray()) {
            dict[c - 'a']++;
        }
        for (char c : ransomNote.toCharArray()) {
            if (--dict[c - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
```


* 【726】给你一个字符串化学式 formula ，返回 每种原子的数量 。

原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。

如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。

例如，"H2O" 和 "H2O2" 是可行的，但 "H1O2" 这个表达是不可行的。
两个化学式连在一起可以构成新的化学式。

例如 "H2O2He3Mg4" 也是化学式。
由括号括起的化学式并佐以数字（可选择性添加）也是化学式。

例如 "(H2O2)" 和 "(H2O2)3" 是化学式。
返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。
```
    public String countOfAtoms(String formula) {
        Deque<TreeMap> deque = new ArrayDeque<>();
        TreeMap<String, Integer> map = new TreeMap<>();
        int i = 0, len = formula.length();
        while (i < len) {
            if (formula.charAt(i) == '(') {
                i++;
                deque.push(map);
                map = new TreeMap<>();
            } else if (formula.charAt(i) == ')') {
                i++;
                int val = 0;
                while (i < len && Character.isDigit(formula.charAt(i))) {
                    val = val * 10 + (formula.charAt(i++) - '0');
                }
                val = (val == 0 ? 1 : val);
                if (!deque.isEmpty()) {
                    TreeMap<String, Integer> temp = map;
                    map = deque.pop();
                    for (Map.Entry<String, Integer> entry : temp.entrySet()) {
                        map.put(entry.getKey(), map.getOrDefault(entry.getKey(), 0) + entry.getValue() * val);
                    }
                }
            } else {
                int ls = i++;
                if (i < len && Character.isLowerCase(formula.charAt(i))) {
                    i++;
                }
                String atom = formula.substring(ls, i);
                int val = 0;
                while (i < len && Character.isDigit(formula.charAt(i))) {
                    val = val * 10 + (formula.charAt(i++) - '0');
                }
                val = (val == 0 ? 1 : val);
                map.put(atom, map.getOrDefault(atom, 0) + val);
            }
        }
        StringBuffer res = new StringBuffer();
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            res.append(entry.getKey());
            if (entry.getValue() > 1) {
                res.append(entry.getValue());
            }
        }
        return res.toString();
    }
```


* 【301】删除无效的括号
，给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。

返回所有可能的结果。答案可以按 任意顺序 返回
```
    // 0 1 2 3 4 5 6 7 8 9
    // ( ( ) ( ) ) ) ) ( )
    //             ^ 在这里发现右括号多了一个，可以删除 s[2], s[4], s[5], s[6] 中的任意一个
    //               但是 s[4], s[5], s[6] 删除后，得出来的子串都是一样的，这里还需要去重
    // 删除 s[2] 后，此时 m = 6, n = 2，这条分支记为 B1
    // 0 1 2 3 4 5 6 7 8
    // ( ( ( ) ) ) ) ( )
    //     ^n      ^m
    // 删除 s[4] 后, 此时 m = 6, n = 4，这条分支记为 B2
    // 0 1 2 3 4 5 6 7 8
    // ( ( ) ( ) ) ) ( )
    //         ^n  ^m
    // 接下来分析分支B2,(分支B1你可以类似分析)，删除 s[4] 后，产生的新串会丢给新的 remove 函数，继续从位置 m = 6 处扫描，但是没有必要从头开始
    // 从位置 m = 6 这里继续扫描即可，发现 s[6] 又不符合条件，于是你又得在 s[0..m] 之间找到一个右括号删除。
    //
    // 0 1 2 3 4 5 6 7 8
    // ( ( ) ( ) ) ) ( )
    //         ^n  ^m
    //
    // 如果你不记录 n 的值，再次进入递归的时候，你又得从位置 0 开始重新找右括号，这时候你可能会删除 s[2]，
    // 这就有问题了，s[2] 删除后变成下面这样。如果你分析了一下 B1 分支，你就会发现产生了一个重复串，和下面一模一样。
    // 0 1 2 3 4 5 6 7 8
    // ( ( ( ) ) ) ( )
    //         ^n  ^m
    // 所以 B2 分支，是不能从位置 0 开始寻找右括号删除，而应该从 n 这个位置开始寻找右括号去删除。删除之后变成下面这样
    // 0 1 2 3 4 5 6 7 8
    // ( ( ) ( ) ) ( )
    //         ^n  ^m
    public List<String> removeInvalidParentheses(String s) {
        List<String> ans = new ArrayList<>();
        removes(s, 0, 0, ans, new char[]{'(', ')'});
        return ans;
    }

    private void removes(String s, int m, int n, List<String> ans, char[] chars) {
        int stack = 0;
        for (int i = m; i < s.length(); i++) {
            if (s.charAt(i) == chars[0]) {
                stack++;
            }
            if (s.charAt(i) == chars[1]) {
                stack--;
            }
            if (stack >= 0) {
                continue;
            }
            for (int j = n; j <= i; j++) {
                if (s.charAt(j) == chars[1] && (j == n || s.charAt(j - 1) != chars[1])) {
                    removes(s.substring(0, j) + s.substring(j + 1), i, j, ans, chars);
                }
            }
            return;
        }
        String reverse = new StringBuffer(s).reverse().toString();
        if (chars[1] == ')') {
            removes(reverse, 0, 0, ans, new char[]{')', '('});
        } else {
            ans.add(reverse);
        }
    }
```

* 【696】计数二进制子串.给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是成组连续的。
重复出现（不同位置）的子串也要统计它们出现的次数

 * 首先，我计算连续分组的 1 或 0 的数量。例如“0110001111”将是[1, 2, 3, 4]。其次，对于 1 和 0 连续分组的任何可能的子串，有效子串的数量将是 0 和 1 的最小数量。例如“0001111”，将是min(3, 4) = 3, ( "01", "0011", "000111")

```
    public int countBinarySubstrings(String s) {
        int cur = 1, pre = 0, ans = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i - 1) == s.charAt(i)) {
                cur++;
            } else {
                ans += Math.min(cur, pre);
                pre = cur;
                cur = 1;
            }
        }
        return ans + Math.min(cur, pre);
    }
```

* 【524】通过删除字母匹配到字典里最长单词。给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。

如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。
```
    public String findLongestWord(String s, List<String> dictionary) {
        dictionary.sort(((o1, o2) -> o1.length() == o2.length() ?
                o1.compareTo(o2) : o2.length() - o1.length()));

        for (String t : dictionary) {
            int i = 0, j = 0;
            while (i < s.length() && j < t.length()) {
                if (s.charAt(i++) == t.charAt(j)) {
                    j++;
                }
            }
            if (t.length() == j) {
                return t;
            }
        }
        return "";
    }
```

* 【400】给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第 n 位上的数字。
    // 基本规律:
    // [1, 9]        有9 * 1个数字     => 9 * 1 * 1     => 9 * 10^0 * 1
    // [10, 99]      有90 * 2个数字    => 9 * 10 * 2    => 9 * 10^1 * 2
    // [100, 999]    有900 * 3个数字   => 9 * 100 * 3   => 9 * 10^2 * 3
    // [1000, 9999]  有9000 * 4个数字  => 9 * 1000 * 4  => 9 * 10^3 * 4
    //          
```
   public int findNthDigit(int n) {
        int len = 1,  start = 1;
        long count = 9;
        while (n > count * len) {
            n -= count * len;//还剩下多少位
            count *= 10;
            len++;
            start *= 10;
        }
        String num = Integer.toString((n - 1) / len + start);//找到n所在的那个数字
        return num.charAt((n - 1) % len) - '0';
    }
```
* 【777】在LR字符串中交换相邻字符,在一个由 'L' , 'R' 和 'X' 三个字符组成的字符串（例如"RXXLRXRXL"）中进行移动操作。一次移动操作指用一个"LX"替换一个"XL"，或者用一个"XR"替换一个"RX"。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。
  * 思路分析： 题目的意思是说 ‘R’只能向右移动，并且只能移向’X’，‘L’只能向左移动，并且只能移向’X’。
  * 第一：如果将start、end中的‘X’全部去掉得到的newStart 和 newEnd相等才有可能转换成功。
  * 第二：如果start中'R'的左边'X'的个数超过在end中对应位置的'R'的左边'X'的个数，则不能转换成功，因为start中的'R'只能向右移动，右边的'X'只能增加不能减少
  * 第三：如果end中'L'的左边'X'的个数超过在start中对应位置的'L'的左边'X'的个数，则不能转换成功，因为start中的'L'只能向左移动，左边的'X'只能减少不能增加
```
    public boolean canTransform(String start, String end) {
        if (!start.replace("X", "").equals(end.replace("X", ""))) {
            return false;
        }
        int p1 = 0, p2 = 0;
        //x <- R, L -> X
        while (p1 < start.length() && p2 < end.length()) {
            while (p1 < start.length() && start.charAt(p1) == 'X') {
                p1++;
            }
            while (p2 < start.length() && end.charAt(p2) == 'X') {
                p2++;
            }
            if (p1 == start.length() && p2 == end.length()) {
                return true;
            }
            if (p1 == start.length() || p2 == end.length()) {
                return false;
            }
            if(start.charAt(p1) != end.charAt(p2)){
                return false;
            }
            //x不够R进行右移
            if (start.charAt(p1) == 'R' && p1 > p2) {
                return false;
            }
            //x不够L进行左移
            if (start.charAt(p1) == 'L' && p2 > p1) {
                return false;
            }
            p1++;
            p2++;
        }
        return true;
    }
```

* 【736】 Lisp 语法解析
给你一个类似 Lisp 语句的字符串表达式 expression，求出其计算结果。

表达式语法如下所示:

表达式可以为整数，let 表达式，add 表达式，mult 表达式，或赋值的变量。表达式的结果总是一个整数。
(整数可以是正整数、负整数、0)
let 表达式采用 "(let v1 e1 v2 e2 ... vn en expr)" 的形式，其中 let 总是以字符串 "let"来表示，接下来会跟随一对或多对交替的变量和表达式，也就是说，第一个变量 v1被分配为表达式 e1 的值，第二个变量 v2 被分配为表达式 e2 的值，依次类推；最终 let 表达式的值为 expr表达式的值。
add 表达式表示为 "(add e1 e2)" ，其中 add 总是以字符串 "add" 来表示，该表达式总是包含两个表达式 e1、e2 ，最终结果是 e1 表达式的值与 e2 表达式的值之 和 。
mult 表达式表示为 "(mult e1 e2)" ，其中 mult 总是以字符串 "mult" 表示，该表达式总是包含两个表达式 e1、e2，最终结果是 e1 表达式的值与 e2 表达式的值之 积 。
在该题目中，变量名以小写字符开始，之后跟随 0 个或多个小写字符或数字。为了方便，"add" ，"let" ，"mult" 会被定义为 "关键字" ，不会用作变量名。
最后，要说一下作用域的概念。计算变量名所对应的表达式时，在计算上下文中，首先检查最内层作用域（按括号计），然后按顺序依次检查外部作用域。测试用例中每一个表达式都是合法的。有关作用域的更多详细信息，请参阅示例。
```
    public int evaluate(String expression) {
        return eval(expression, new HashMap<>());
    }

    private int eval(String exp, Map<String, Integer> parent) {
        if (!exp.startsWith("(")) {
            //如果为数字或者为负数
            if (Character.isDigit(exp.charAt(0)) || exp.charAt(0) == '-') {
                return Integer.parseInt(exp);
            }
            return parent.get(exp);
        }
        Map<String, Integer> curParams = new HashMap<>();//存储当前的变量
        curParams.putAll(parent);
        //去掉括号的
        List<String> tokens = parse(exp.substring(exp.startsWith("(m") ? 6 : 5, exp.length() - 1));
        if (exp.startsWith("(a")) {
            return eval(tokens.get(0), curParams) + eval(tokens.get(1), curParams);
        } else if (exp.startsWith("(m")) {
            return eval(tokens.get(0), curParams) * eval(tokens.get(1), curParams);
        } else {
            for (int i = 0; i < tokens.size() - 2; i+=2) {
                curParams.put(tokens.get(i), eval(tokens.get(i + 1), curParams));
            }
            return eval(tokens.get(tokens.size() - 1), curParams);
        }
    }

    //x 1 y 2 x (add x y) (add x y) ==》 [x, 1, y, 2, x, (add x y), (add x y)]
    public List<String> parse(String exp) {
        //(let x 1 y 2 x (add x y) (add x y))
        List<String> list = new ArrayList<>();
        StringBuffer str = new StringBuffer();
        int sign = 0;
        for (char c : exp.toCharArray()) {
            if (c == '(') {
                sign++;
            }
            if (c == ')') {
                sign--;
            }
            if (sign == 0 && c == ' ') {
                list.add(str.toString());
                str = new StringBuffer();
            } else {
                str.append(c);
            }
        }
        if (str.length() > 0) {
            list.add(str.toString());
        }
        return list;
    }
```


* 【1190】 反转每对括号间的子串
给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

 
```
   //(ed(et(oc))el)
    public String reverseParentheses(String s) {
        Deque<String> deque = new ArrayDeque<>();
        StringBuffer buffer = new StringBuffer();
        for (char c : s.toCharArray()) {
            if (c == ')') {
                buffer.reverse().insert(0, deque.pop());
            } else if (c == '(') {
                deque.push(buffer.toString());
                buffer.setLength(0);
            } else {
                buffer.append(c);
            }
        }
        return buffer.toString();
    }
```

* 【13】 罗马数字转整数
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

```
    public int romanToInt(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        HashMap<Character, Integer> map = new HashMap<>();
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int sum = map.get(s.charAt(s.length() - 1));
        for (int i = s.length() - 2; i >= 0; i--) {
            char one = s.charAt(i), two = s.charAt(i + 1);
            if (map.get(one) < map.get(two)) {//前一位小于后一位，说明要减去
                sum -= map.get(one);
            } else {
                sum += map.get(one);
            }
        }
        return sum;
    }
```