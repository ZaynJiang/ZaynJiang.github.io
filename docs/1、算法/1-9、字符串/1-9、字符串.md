## 1. 概述
## 2. 经典算法
* 【394】给定一个经过编码的字符串，返回它解码后的字符串3[a2[c]]转化成accaccacc
  * 使用栈保存循环的次数
  * 使用栈保存[以前的字符串，因为有可能要取出来和拼接好的的字符组合。
  * stringbufer先存储字母，遇到了[需要暂且存到栈里，遇到]需要从栈中取出来拼接重复
```
        //保存数字
        Deque<Integer> nums = new ArrayDeque<>();
        Deque<String> preStr = new ArrayDeque();
        StringBuffer repeatStr = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //如果当前是数字
            if (Character.isDigit(c)) {
                int num = c - '0';
                while (Character.isDigit(s.charAt(i + 1))) {
                    num = (s.charAt(++i) - '0') + num * 10;
                }
                nums.push(num);
                //如果出现了[，需要重新拼接[]里面的字符串了，存放到preStr里面
            } else if (c == '[') {
                preStr.push(repeatStr.toString());
                repeatStr.setLength(0);
            } else if (c == ']') {
                int num = nums.pop();
                StringBuffer temp = new StringBuffer();
                temp.append(preStr.pop());
                while (num-- > 0) {
                    temp.append(repeatStr);
                }
                repeatStr = new StringBuffer(temp.toString());
            } else if (Character.isLetter(c)) {
                repeatStr.append(c);
            }
        }
        return repeatStr.toString();
```


* 【8】请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）
  * 先找到数字的开头
  * 判断是+还是-
  * 拼接数字，注意是否越界
  * 和边界的十位以上比较
  * 如果直接大于十位以上就越界了
  * 如果等于边界的十位以上， 比较个位数即可。
```
    public int myAtoi(String s) {
        int idx = 0;
        while (idx < s.length() && s.charAt(idx) == ' ') {
            idx++;
        }
        if (idx == s.length()) {
            return 0;
        }
        int sign = 1, res = 0;
        if (s.charAt(idx) == '-') {
            sign = -1;
            idx++;
        } else if (s.charAt(idx) == '+') {
            idx++;
        }
        while (idx < s.length() && Character.isDigit(s.charAt(idx))) {
            //有两种情况：
            // ① res乘以10直接就大于边界了
            // ② res等于边界，需要比较下一位和边界的个位数比较，
            if (res > Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE/10 && (s.charAt(idx) - '0') > 7)) {
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            res =s.charAt(idx++) - '0' +  res * 10;
        }
        return res * sign;
    }
```

* 【227】给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值
  * 遇到+、-需要处理tempRes的值，将其累加
```
    public int calculate(String s) {
        //遇到数字就存储到tempNum，遇到一个运算符，可根据上一个运算符来判断如何存储
        //如果上一个字符为+或-号，说明这以前的数字可以了结了。
        //0+a+z*c*e+b+c*d/f*s/x
        int tempRes = 0, res = 0, num = 0;
        char preSign = '+';
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                num = c - '0' + num * 10;
            }
            // 0 + 2+3-5/2*3 + 3 - 1
            //如果是最后一个数字字符，或者是加减乘除字符串
            if (i == s.length() - 1 || (!Character.isDigit(c) && c != ' ')) {
                switch (preSign) {
                    //上一个字符是加号
                    case '+':
                        res += tempRes;
                        tempRes = num;
                        break;
                    case '-':
                        res += tempRes;
                        tempRes = -num;
                        break;
                    case '*':
                        tempRes *= num;
                        break;
                    case '/':
                        tempRes /= num;
                        break;
                }
                num = 0;
                preSign = c;
            }
        }
        return res + tempRes;
    }
```

* 【151】 翻转字符串里的单词
  * 原地交换算法：
  * 先反转整个字符串
  * 逐个反转每一个单词
  * 去除多余的空格
```
    public String reverseWords(String s) {
        char[] charArray = s.toCharArray();
        reverse(charArray, 0, charArray.length - 1);
        reverseWords(charArray);
        return cleanSpace(charArray);
    }

    public void reverseWords(char[] charArray) {
        int i = 0, j = 0;
        while (j < charArray.length) {
            while (i < j || (i < charArray.length && charArray[i] == ' ')) {  // 设置新的单词起点（小于之前的j或者为空字符）
                i++;
            }
            while (i > j || (j < charArray.length && charArray[j] != ' ')) {  //设置新的单词结束点（大于之前的j或者为字母）
                j++;
            }
            reverse(charArray, i, j - 1);
        }
    }

    public String cleanSpace(char[] charArray) {
        int i = 0, j = 0;
        while (j < charArray.length) {
            while (j< charArray.length && charArray[j] == ' ') {
                j++;
            }
            while (j < charArray.length && charArray[j] != ' ') {
                charArray[i++] = charArray[j++];
            }
            while (j< charArray.length && charArray[j] == ' ') {
                j++;
            }
            if (j < charArray.length) {
                charArray[i++] = ' ';
            }
        }
        return new String(charArray).substring(0, i);
    }

    public void reverse(char[] array, int lo, int hi) {
        while (lo < hi) {
            char lv = array[lo];
            array[lo] = array[hi];
            array[hi] = lv;
            lo++;
            hi--;
        }
    }
```

* https://leetcode-cn.com/problems/multiply-strings/solution/gao-pin-mian-shi-xi-lie-zi-fu-chuan-cheng-fa-by-la/
```

```