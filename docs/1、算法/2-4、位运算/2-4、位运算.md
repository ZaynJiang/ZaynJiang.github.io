## 1. 概念

## 2. 经典题目 
* 【415】给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回
  * 从后往前加
  * 取余取模
  * 注意进位
```
    public String addStrings(String num1, String num2) {
        int n1 = num1.length() - 1, n2 = num2.length() - 1, sum = 0;
        StringBuffer res = new StringBuffer();
        while (n1 >= 0 || n2 >= 0 || sum != 0) {
            if (n1 >= 0) {
                sum += (num1.charAt(n1--) - '0');
            }
            if (n2 >= 0) {
                sum += (num2.charAt(n2--) - '0');
            }
            res.append(sum % 10);
            sum  /= 10;
        }
        return res.reverse().toString();
    }
```

* 【191】编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）

```
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            count += n & 1;
            n >>>= 1;
        }
        return count;
    }
```

* 【136】给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 
  * 交换律：a ^ b ^ c <=> a ^ c ^ b
  * 任何数于0异或为任何数 0 ^ n => n
  * 相同的数异或为0: n ^ n => 0
```
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res = res ^ num;
        }
        return res;
    }
```

* 【260】给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案
```
  public int[] singleNumber(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        //找到不同两个数的异或结果的二进制低位1作为标识
        //1代表这一位二进制它们肯定不同
        int mark = xor & -xor;
        int[] res = new int[2];
        for (int num : nums) {
            //将数分为两组，分别为1个数和多个成对的数
            //不同的两个数肯定分开，相同的肯定是一组
            if ((num & mark) == 0) {
                res[0] ^= num;
            } else {
                res[1] ^= num;
            }
        }
        return res;
    }
```

* 【7】给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。  如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）
* ![](数字反转.png)
```
    public int reverse(int x) {
        int r = 0;
        while (x != 0) { //循环条件判断条件不能是x>0，因为忽略了 负数
            if (r < Integer.MIN_VALUE / 10 || r > Integer.MAX_VALUE / 10) {
                return 0;
            }
            r = r * 10 + x % 10;
            x /= 10;
        }
        return r;
    }

    //方法2
    public int reverse(int x) {
        int r = 0;
        while (x != 0) { //循环条件判断条件不能是x>0，因为忽略了 负数
            int temp = r * 10 + x % 10;
            if (temp/10 != r) { //// 溢出!!!了
                return 0;
            }
            r = temp;
            x /= 10;
        }
        return r;
    }
```

* 【338】比特位计数，给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。
  * i & (i - 1)可以去掉i最右边的一个1（如果有），因此 i & (i - 1）是比 i 小的，而且i & (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i & (i - 1)的1的个数加上1
```
    public int[] countBits(int n) {
        int[] res = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            res[i] = res[(i - 1) & i] + 1;
        }
        return res;
    }
```

* 【51】N 皇后，n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。  
![](n皇后1.png)  
![](n皇后2.png)  
```
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        int[] queens = new int[n];
        dfs(n, 0, queens, ans, 0, 0, 0);
        return ans;
    }

    private void dfs(int n, int row, int[] q, List<List<String>> ans, int col, int pie, int la) {
        if (row == n) {
            ans.add(transfer(q));
            return;
        }
        //找到当前行的可用的皇后，并用1标记
        int availableQ = ((1 << n) - 1) & (~(pie | la | col));
        while (availableQ != 0) {
            //找到第一个1的数字
            int pos = availableQ & (-availableQ);
            availableQ &= availableQ - 1;
            //获取一共由多少1个
            int count = Integer.bitCount(pos - 1);
            q[row] = count;
            dfs(n, row + 1, q, ans, col | pos, (pie | pos) >> 1, (la | pos) << 1);
        }
    }

    public List<String> transfer(int[] n) {
        List<String> ans = new ArrayList<>();
        for (int i : n) {
            char[] str = new char[n.length];
            Arrays.fill(str, '.');
            str[i] = 'Q';
            ans.add(new String(str));
        }
        return ans;
    }
```

* 【29】两数相除,给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

```
59 / 3 = z
⇒ 59 = 3*z
⇒ x*z <= 59
⇒ 3 * (2^4 + 2^1 + 2^0 )
⇒ 3* ( 16 + 2 + 1)
⇒ 57
  
 而 z =  (2^4 + 2^1 + 2^0 ) = 10011 (19)

按照下面写程序的思路，先得到z值的所有可能情况,
z = {3*2^0,  3*2^1,  3*2^2,  3*2^3,  3*2^4} ,因为3 * (2^5) > 59了，所以往后的不计入在内。

计算z值（ans = 0）：
1, 59 - 3*2^4 = 11, 结果集ans = ans + 1<<4 = 16
2, 11 - 3*2^1 = 5, 结果集ans = ans + 1<< 1 = 16 + 2 = 18
3, 5 - 3*2^0 = 2, 结果集ans = ans + 1<< 0 = 16 + 2  + 1= 19(即，二进制10011)
4，2 < 3 ，循环终止，返回结果ans。
```
```

    /**
     * 解题思路：这题是除法，所以先普及下除法术语
     * 商，公式是：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，是一种数学术语。
     * 在一个除法算式里，被除数、余数、除数和商的关系为：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，
     * 进而推导得出：商×除数+余数=被除数。
     *
     * 要求商，我们首先想到的是减法，能被减多少次，那么商就为多少，但是明显减法的效率太低
     *
     * 那么我们可以用位移法，因为计算机在做位移时效率特别高，向左移1相当于乘以2，向右位移1相当于除以2
     *
     * 我们可以把一个dividend（被除数）先除以2^n，n最初为31，不断减小n去试探,当某个n满足dividend/2^n>=divisor时，
     *
     * 表示我们找到了一个足够大的数，这个数*divisor是不大于dividend的，所以我们就可以减去2^n个divisor，以此类推
     *
     * 我们可以以100/3为例
     *
     * 2^n是1，2，4，8...2^31这种数，当n为31时，这个数特别大，100/2^n是一个很小的数，肯定是小于3的，所以循环下来，
     *
     * 当n=5时，100/32=3, 刚好是大于等于3的，这时我们将100-32*3=4，也就是减去了32个3，接下来我们再处理4，同样手法可以再减去一个3
     *
     * 所以一共是减去了33个3，所以商就是33
     *
     * 这其中得处理一些特殊的数，比如divisor是不能为0的，Integer.MIN_VALUE和Integer.MAX_VALUE
     *
     */
    public int divide(int dividend, int divisor) {
        if (divisor == 0 || (Integer.MIN_VALUE == dividend && divisor == -1)) {
            return Integer.MAX_VALUE;
        }
        //商×除数+余数=被除数。
        //可以根据2进制的高位慢慢逼近结果
        long beichu = Math.abs((long) dividend), chu = Math.abs((long) divisor);
        int ans = 0;
        for (int i = 31; i >= 0; i--) {
            if ((beichu >> i) >= chu) {//正好逼近到结果及以上
                ans += 1 << i;
                beichu -= chu << i;
            }
        }
        int sign = dividend ^ divisor;//大于零说明符号相反
        return sign < 0 ? -ans : ans;
    }
```
【405】数字转换为十六进制数。给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
```
   public String toHex(int num) {
        if (num == 0) {
            return "0";
        }
        char[] chars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
        //0xf代表二进制的后四位
        StringBuffer res = new StringBuffer();
        while (res.length() < 8 && num != 0) {
            res.append(chars[num & 0xf]);
            num >>= 4 ;
        }
        return res.reverse().toString();
    }
```



* 【137】只出现一次的数字 II
给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素
  * 比较难理解，参考https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/
  * 如果位出现了1+1+1，则需要回归0，即two->如果是1的话，则要为0
```
    public int singleNumber(int[] nums) {
        int one = 0, two = 0;
        for (int num : nums) {
            one = one ^ num & ~two;
            two = two ^ num & ~one;
        }
        return one;
    }
```