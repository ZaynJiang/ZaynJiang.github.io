## 1. 概念

## 2. 经典题目 
* 【415】给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回
  * 从后往前加
  * 取余取模
  * 注意进位
```
    public String addStrings(String num1, String num2) {
        int n1 = num1.length() - 1, n2 = num2.length() - 1, sum = 0;
        StringBuffer res = new StringBuffer();
        while (n1 >= 0 || n2 >= 0 || sum != 0) {
            if (n1 >= 0) {
                sum += (num1.charAt(n1--) - '0');
            }
            if (n2 >= 0) {
                sum += (num2.charAt(n2--) - '0');
            }
            res.append(sum % 10);
            sum  /= 10;
        }
        return res.reverse().toString();
    }
```

* 【191】编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）

```
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            count += n & 1;
            n >>>= 1;
        }
        return count;
    }
```

* 【136】给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 
  * 交换律：a ^ b ^ c <=> a ^ c ^ b
  * 任何数于0异或为任何数 0 ^ n => n
  * 相同的数异或为0: n ^ n => 0
```
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res = res ^ num;
        }
        return res;
    }
```

* 【260】给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案
```
  public int[] singleNumber(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        //找到不同两个数的异或结果的二进制低位1作为标识
        //1代表这一位二进制它们肯定不同
        int mark = xor & -xor;
        int[] res = new int[2];
        for (int num : nums) {
            //将数分为两组，分别为1个数和多个成对的数
            //不同的两个数肯定分开，相同的肯定是一组
            if ((num & mark) == 0) {
                res[0] ^= num;
            } else {
                res[1] ^= num;
            }
        }
        return res;
    }
```

* 【7】给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。  如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）
* ![](数字反转.png)
```
    public int reverse(int x) {
        int r = 0;
        while (x != 0) { //循环条件判断条件不能是x>0，因为忽略了 负数
            if (r < Integer.MIN_VALUE / 10 || r > Integer.MAX_VALUE / 10) {
                return 0;
            }
            r = r * 10 + x % 10;
            x /= 10;
        }
        return r;
    }

    //方法2
    public int reverse(int x) {
        int r = 0;
        while (x != 0) { //循环条件判断条件不能是x>0，因为忽略了 负数
            int temp = r * 10 + x % 10;
            if (temp/10 != r) { //// 溢出!!!了
                return 0;
            }
            r = temp;
            x /= 10;
        }
        return r;
    }
```

* 【338】比特位计数，给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。
  * i & (i - 1)可以去掉i最右边的一个1（如果有），因此 i & (i - 1）是比 i 小的，而且i & (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i & (i - 1)的1的个数加上1
```
    public int[] countBits(int n) {
        int[] res = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            res[i] = res[(i - 1) & i] + 1;
        }
        return res;
    }
```

* 【51】N 皇后，n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。  
![](n皇后1.png)  
![](n皇后2.png)  
```
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
        int[] queens = new int[n];
        dfs(n, 0, queens, ans, 0, 0, 0);
        return ans;
    }

    private void dfs(int n, int row, int[] q, List<List<String>> ans, int col, int pie, int la) {
        if (row == n) {
            ans.add(transfer(q));
            return;
        }
        //找到当前行的可用的皇后，并用1标记
        int availableQ = ((1 << n) - 1) & (~(pie | la | col));
        while (availableQ != 0) {
            //找到第一个1的数字
            int pos = availableQ & (-availableQ);
            availableQ &= availableQ - 1;
            //获取一共由多少1个
            int count = Integer.bitCount(pos - 1);
            q[row] = count;
            dfs(n, row + 1, q, ans, col | pos, (pie | pos) >> 1, (la | pos) << 1);
        }
    }

    public List<String> transfer(int[] n) {
        List<String> ans = new ArrayList<>();
        for (int i : n) {
            char[] str = new char[n.length];
            Arrays.fill(str, '.');
            str[i] = 'Q';
            ans.add(new String(str));
        }
        return ans;
    }
```

* 【29】两数相除,给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

```
59 / 3 = z
⇒ 59 = 3*z
⇒ x*z <= 59
⇒ 3 * (2^4 + 2^1 + 2^0 )
⇒ 3* ( 16 + 2 + 1)
⇒ 57
  
 而 z =  (2^4 + 2^1 + 2^0 ) = 10011 (19)

按照下面写程序的思路，先得到z值的所有可能情况,
z = {3*2^0,  3*2^1,  3*2^2,  3*2^3,  3*2^4} ,因为3 * (2^5) > 59了，所以往后的不计入在内。

计算z值（ans = 0）：
1, 59 - 3*2^4 = 11, 结果集ans = ans + 1<<4 = 16
2, 11 - 3*2^1 = 5, 结果集ans = ans + 1<< 1 = 16 + 2 = 18
3, 5 - 3*2^0 = 2, 结果集ans = ans + 1<< 0 = 16 + 2  + 1= 19(即，二进制10011)
4，2 < 3 ，循环终止，返回结果ans。
```
```

    /**
     * 解题思路：这题是除法，所以先普及下除法术语
     * 商，公式是：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，是一种数学术语。
     * 在一个除法算式里，被除数、余数、除数和商的关系为：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，
     * 进而推导得出：商×除数+余数=被除数。
     *
     * 要求商，我们首先想到的是减法，能被减多少次，那么商就为多少，但是明显减法的效率太低
     *
     * 那么我们可以用位移法，因为计算机在做位移时效率特别高，向左移1相当于乘以2，向右位移1相当于除以2
     *
     * 我们可以把一个dividend（被除数）先除以2^n，n最初为31，不断减小n去试探,当某个n满足dividend/2^n>=divisor时，
     *
     * 表示我们找到了一个足够大的数，这个数*divisor是不大于dividend的，所以我们就可以减去2^n个divisor，以此类推
     *
     * 我们可以以100/3为例
     *
     * 2^n是1，2，4，8...2^31这种数，当n为31时，这个数特别大，100/2^n是一个很小的数，肯定是小于3的，所以循环下来，
     *
     * 当n=5时，100/32=3, 刚好是大于等于3的，这时我们将100-32*3=4，也就是减去了32个3，接下来我们再处理4，同样手法可以再减去一个3
     *
     * 所以一共是减去了33个3，所以商就是33
     *
     * 这其中得处理一些特殊的数，比如divisor是不能为0的，Integer.MIN_VALUE和Integer.MAX_VALUE
     *
     */
    public int divide(int dividend, int divisor) {
        if (divisor == 0 || (Integer.MIN_VALUE == dividend && divisor == -1)) {
            return Integer.MAX_VALUE;
        }
        //商×除数+余数=被除数。
        //可以根据2进制的高位慢慢逼近结果
        long beichu = Math.abs((long) dividend), chu = Math.abs((long) divisor);
        int ans = 0;
        for (int i = 31; i >= 0; i--) {
            if ((beichu >> i) >= chu) {//正好逼近到结果及以上
                ans += 1 << i;
                beichu -= chu << i;
            }
        }
        int sign = dividend ^ divisor;//大于零说明符号相反
        return sign < 0 ? -ans : ans;
    }
```
【405】数字转换为十六进制数。给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
```
   public String toHex(int num) {
        if (num == 0) {
            return "0";
        }
        char[] chars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
        //0xf代表二进制的后四位
        StringBuffer res = new StringBuffer();
        while (res.length() < 8 && num != 0) {
            res.append(chars[num & 0xf]);
            num >>= 4 ;
        }
        return res.reverse().toString();
    }
```



* 【137】只出现一次的数字 II
给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素
  * 比较难理解，参考https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/
  * 如果位出现了1+1+1，则需要回归0，即two->如果是1的话，则要为0
```
    public int singleNumber(int[] nums) {
        int one = 0, two = 0;
        for (int num : nums) {
            one = one ^ num & ~two;
            two = two ^ num & ~one;
        }
        return one;
    }
```


* 【861】 翻转矩阵后的得分
有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

  * 题目要求每行表示的数的和最大，那么我们很容易就想到可以让每行表示的数尽可能的大。由于每行为一个二进制数，那么我们肯定希望所有位置都尽可能为 1，尤其是数字的高位，最好就是 1。我们通过观察样例发现，每行的第一个数字都为 1。我们想下，的确不论如何翻转，第一列全为 1的结果一定大于其它任何结果的。所以我们先把最高位为 0 的行翻转，并且那些最高位为 1 的是不能行翻转的。对于样例 1，进行如下的变换
  * 我们再去考虑列翻转。对于每列，我们肯定希望 1 越多越好，因为每个 1 都会让那行的数字更大。那么统计每列中 0 和 1 的个数，如果 0 多就列翻转，否则不列翻转。对于样例 1，变换继续
 
```
    public int matrixScore(int[][] grid) {
        int n = grid.length, m = grid[0].length;
        for (int i = 0; i < n; i++) {
            if (grid[i][0] == 0) {//如果行的首位是0，那么就反转这一行能够保证值最大
                for (int j = 0; j < m; j++) {
                    grid[i][j] ^= 1;
                }
            }
        }
        int ans = 0;
        for (int j = 0; j < m; j++) {//逐列进行反转
            int cnt = 0;//统计一列中1的个数
            for (int i = 0; i < n; i++) {
                cnt += grid[i][j];
            }
            //10100
            //11011
            ans += Math.max(cnt, n - cnt) * (1 << m - j - 1);//如果一列0占多数，则反转0为1，否则不反转，将该位的值累加到结果中
        }
        return ans;
    }
```
* 【Offer 56 - I】. 数组中数字出现的次数
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
  * //得到异或结果，即为不相同两个数的异或结果sum
  * 得到sum的二进制的1的最低位
  * 分成两个组进行异或，每组异或后的结果就是不相同两个数的其中之一

```
    public int[] singleNumbers(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum ^= num;
        }
        sum = (-sum) & sum;
        int[] ans = new int[2];
        for (int num : nums) {
            if ((num & sum) == 0) {
                ans[0] ^= num;
            } else {
                ans[1] ^= num;
            }
        }
        return ans;
    }
```

* 【397】整数替换
给定一个正整数 n ，你可以做如下操作：

如果 n 是偶数，则用 n / 2替换 n 。
如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。
n 变为 1 所需的最小替换次数是多少？

主要体现在对α为奇数时的处理，我们总是处理α＋1和a ―1两种情况。
我们可以从二进制的角度进行分析:给定起始值n，求解将其变为(000..0001)2的最小步数。
  * 对于偶数(二进制最低位为0)而言，我们只能进行一种操作，其作用是将当前值α其进行一个单位的右移;
  * 对于奇数（二进制最低位为1)而言，我们能够进行+1或-1操作，分析两种操作为α产生的影响:
    * 对于+1操作而言:最低位必然为1，此时如果次低位为0的话，+1相当于将最低位和次低位交换;如果次低位为1的话，+1操作将将「从最低位开始，连续一段的1」进行消除（置零)，并在连续一段的高一位添加一个1;   
    * 对于-1操作而言:最低位必然为1，其作用是将最低位的1进行消除。
因此，对于α为奇数所能执行的两种操作，+1能够消除连续一段的1，只要次低位为1(存在连续段)，应当优先使用 +1操作，但需要注意边界a=3时的情况(此时选择-1操作)。

```
    public int integerReplacement(int _n) {
        long n = _n;
        int ans = 0;
        while (n != 1) {
            ans++;
            if (n % 2 == 0) {
                n /= 2;
            } else {
                if (n != 3 && (n >> 1 & 1) == 1) {//如果次低位也为1的话，说明加1更划算
                    n++;
                } else {
                    n--;
                }
            }
        }
        return ans;
    }
```