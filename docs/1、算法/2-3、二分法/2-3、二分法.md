## 1、概念

## 2. 经典题目
* 【15】给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组
  * 排序
  * 二分查找
  * 边界条件，注意要去重，外层和内层的都要去重
  * 例如，-4 2 2 7 8 9 -》 -4 2 2，
  * 去重
```
       List<List<Integer>> res = new ArrayList<>();
        if (nums == null || nums.length < 3) {
            return res;
        }
        Arrays.sort(nums);
        //遍历第一个标
        for (int i = 0; i < nums.length - 2; i++) {
            if (nums[i] > 0) {
                return res;
            }
            if (i > 0 && nums[i] == nums[i-1]) {
                continue;
            }
            int lo = i + 1, hi = nums.length - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi];
                if (sum == -nums[i]) {
                    res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));
                    while (lo < hi && nums[hi] == nums[hi-1]) {
                        hi--;
                    }
                    while (lo < hi && nums[lo+1] == nums[lo]) {
                        lo++;
                    }
                    hi--;
                    lo++;
                } else if (sum > -nums[i]){
                    hi--;
                } else {
                    lo++;
                }
            }
        }
        return res;
```

* 【33】搜索旋转排序数组
  * 取中间点
  * 判断中间点如果在右半截，判断如果target在右半截且比中间点大，说明可以lo可以右移动到中间点，其它情况，要么target在中间点左边或者在左半截即hi可以左移动至中间点，
  * 判断中间点如果在左半截，判断如果target在左半截且比中间点小，说明可以hi可以左移动到中间点，其它情况，要么target在中间点右边或者在右半截即lo可以右移动至中间点，
```
    public int search(int[] nums, int target) {
        int lo = 0, hi = nums.length - 1;
        while (lo <= hi) {
            int mid = (lo + hi) >> 1;
            if (target == nums[mid]) {
                return mid;
            } else {
                //mid在右半截
                if (nums[mid] <= nums[nums.length - 1]) {
                    if (target <= nums[nums.length - 1] && target > nums[mid]){
                        lo = mid + 1;
                    } else {
                        hi = mid - 1;
                    }
                    //在左半截
                } else {
                    if (target > nums[nums.length - 1] && target < nums[mid]) {
                        hi = mid - 1;
                    } else {
                        lo = mid + 1;
                    }
                }
            }
        }
        return -1;
    }
```

* 【69】给你一个非负整数 x ，计算并返回 x 的 算术平方根
  * 注意lo == hi
  * 注意lo起始值为0
  * 注意long转换
```
    public int mySqrt(int x) {
        int lo = 0, hi = x;
        while (lo <= hi) {
            int mid = (lo + hi) >> 1;
            long val = (long) mid * mid;
            if (val > x)  {
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }
        return hi;
    }
```

* 【162】 峰值元素是指其值严格大于左右相邻值的元素
  * 遇到logn的算法一般是二分法
  * mid大于下一位，说明mid才可能是峰值，hi下移
  * 如果mid 小于等于下一位，说明下一位才可能为峰值，lo上一mid+1
```
    public int findPeakElement(int[] nums) {
        int lo = 0, hi = nums.length - 1;
        while (lo < hi) {
            int mid = (lo + hi) >> 1;
            //说明有mid大于下一位，说明mid才可能是峰值
            if (nums[mid] > nums[mid + 1]) {
                hi = mid;
            //如果mid 小于等于下一位，说明下一位才可能为峰值
            } else {
                lo = mid+1;
            }
        }
        return hi;
    }
```

* 【4】给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数
  * 可以归结到寻找第k小(大)元素问题
  * 取两个数组中的第k/2个元素进行比较
  * 如果数组1的元素小于数组2的元素，则说明数组1中的前k/2个元素不可能成为第k个元素的候选
  * 所以将数组1中的前k/2个元素去掉，组成新数组和数组2求第k-k/2小的元素，因为我们把前k/2个元素去掉了
  * 所以相应的k值也应该减小
  * 注意处理一些边界条件问题，比如某一个数组可能为空或者k为1的情况

```
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        //寻找到第k+1个
        int k1 = (nums1.length + nums2.length + 1) / 2, k2 = (nums1.length + nums2.length + 2) / 2;
        return (getKMinNum(nums1, nums2, k1, 0, 0) + getKMinNum(nums1, nums2, k2, 0, 0)) / 2.0;
    }

    //寻找有序的两个数组第k小的元素值
    //i、j分别位num1、num2的下标为起点往后，寻找第k小的数字
    private int getKMinNum(int[] nums1, int[] nums2, int k, int i, int j) {
        //本身k的大小大于了数组的下标
        if (i >= nums1.length) {
            return nums2[j + k - 1];
        }
        //本身k的大小大于了数组的下标
        if (j >= nums2.length) {
            return nums1[i + k - 1];
        }
        if (k == 1) {
            return Math.min(nums1[i], nums2[j]);
        }
        //比较i+k/2或者j+k/2的大小
        //获取第一个数组第k/2小的值，如果数组大于了k/2取无穷小
        int n1 = (i + k / 2 - 1) >= nums1.length ? Integer.MAX_VALUE : nums1[i + k / 2 - 1];
        //获取第二个数组第k/2小的值，如果数组大于了k/2取无穷小
        int n2 = (j + k / 2 - 1) >= nums2.length ? Integer.MAX_VALUE : nums2[j + k / 2 - 1];
        //n1和n2取较小者，小的那一段可以排调
        return n1 < n2 ? getKMinNum(nums1, nums2, k - k / 2, i + k / 2, j) : getKMinNum(nums1, nums2, k - k / 2, i, j + k / 2);
    }
```

* 【240】编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target，每行的元素从左到右升序排列，每列的元素从上到下升序排列
  * 
```
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = 0, j = matrix[0].length - 1;
        while (i < matrix.length && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] > target) {
                j--;
            } else {
                i++;
            }
        }
        return false;
    }
```


* 【50】实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）
  * 先计算1半的值，不用一个个计算。
```
    public double myPow(double x, int n) {
        if (n < 0) {
            return 1 / pow(x, -n);
        }
        return pow(x, n);
    }

    public double pow(double x, int n) {
        if (n == 0) {
            return 1;
        }
        //先计算一半的数据量
        double r = pow(x, n / 2);
        if (n % 2 == 0) {
            return r * r;
        } else {
            return r * r * x;
        }
    }
```

* 【704】给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1
  * 标准的2分法
```
    public int search(int[] nums, int target) {
        int lo = 0, hi = nums.length - 1;
        while (lo <= hi) {
            int mid = (lo + hi) >> 1;
            if (target < nums[mid]) {
                hi --;
            } else if (target > nums[mid]) {
                lo ++;
            } else {
                return mid;
            }
        }
        return -1;
    }
```

* 【74】编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值，每行中的整数从左到右按升序排列，每行的第一个整数大于前一行的最后一个整数
  * 二分法
  * 已知一个按行遍历的数字求横轴坐标和纵轴坐标，根据列数取余取模即可，i = mid / matrix[0].length, j = mid % matrix[0].length
```
 public boolean searchMatrix(int[][] matrix, int target) {
        int lo = 0, hi = matrix.length * matrix[0].length - 1;
        while (lo <= hi) {
            int mid = (lo + hi) >> 1, i = mid / matrix[0].length, j = mid % matrix[0].length;
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] > target){
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }
        return false;
    }
```


* 【154】已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到
  *  \textit{nums}[\textit{pivot}] < \textit{nums}[\textit{high}]nums[pivot]<nums[high]。如下图所示，这说明 \textit{nums}  [\textit{pivot}]nums[pivot] 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分
  *  \textit{nums}[\textit{pivot}] > \textit{nums}[\textit{high}]nums[pivot]>nums[high]。如下图所示，这说明 \textit{nums}[\textit{pivot}]nums[pivot] 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分
  * 由于重复元素的存在，我们并不能确定 \textit{nums}[\textit{pivot}]nums[pivot] 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 \textit{nums}[\textit{high}]nums[high] 是不是最小值，都有一个它的「替代品」\textit{nums}[\textit{pivot}]nums[pivot]，因此我们可以忽略二分查找区间的右端点
```
   public int findMin(int[] nums) {
        int lo = 0, hi = nums.length - 1;
        while (lo < hi) {
            int mid = (lo + hi) >> 1;
            if (nums[mid] > nums[hi]) {
                lo = mid + 1;
            } else if (nums[mid] < nums[hi]) {
                hi = mid;
            } else {
                hi--;
            }
        }
        return nums[lo];
    }
```