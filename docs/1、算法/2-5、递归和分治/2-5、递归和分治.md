## 1. 概念

## 2. 经典题目
* 【236】给定一个二叉树, 找到该树中两个指定节点的最近公共祖先
  * 注意p,q必然存在树内, 且所有节点的值唯一!!!
  * 递归思想, 对以root为根的(子)树进行查找p和q, 如果root == null || p || q 直接返回root
  * 表示对于当前树的查找已经完毕, 否则对左右子树进行查找, 根据左右子树的返回值判断:
    * 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA
    * 如果左右子树返回值只有一个不为null, 说明只有p和q存在与左或右子树中, 最先找到的那个节点为LCA
    * 左右子树返回值均为null, p和q均不在树中, 返回null
```
  //返回某一个节点下p、q的公共祖先
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //如果是null，返回空
        //如果与p、q任意一个相等，那么当前节点一定是公共祖先
        if (root == null || root == p || root == q) {
            return root;
        }
        //寻找左子树是否存在公共祖先
        TreeNode leftCommonAncestor = lowestCommonAncestor(root.left, p, q);
        //寻找右子树是否存在公共祖先
        TreeNode rightCommonAncestor = lowestCommonAncestor(root.right, p, q);
        //如果都不为空，说明本节点就是公共祖先
        if (leftCommonAncestor != null && rightCommonAncestor != null) {
            return root;
        }
        //选择不为空的继续寻找
        return leftCommonAncestor != null ? leftCommonAncestor : rightCommonAncestor;
    }
```  

* 【23】合并K个升序链表
  * 分治思想进行合并链表
  * 最开始0--------len
  *      0--mid---len
  * 有序链表可以利用递归的写法更加优雅
```
   public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        return merge(lists, 0, lists.length - 1);
    }

    //分治的标准写法
    public ListNode merge(ListNode[] lists, int lo, int hi){
        if (lo == hi) {
            return lists[lo];
        }
        int mid = (lo + hi) >> 1;
        //两两合并
        return mergeTwo(merge(lists, lo, mid), merge(lists, mid + 1, hi));
    }

    public ListNode mergeTwo(ListNode head1, ListNode head2) {
        ListNode hair = new ListNode(), cur = hair;
        while (head1 != null && head2 != null) {
            if (head1.val >= head2.val) {
                cur.next = head2;
                head2 = head2.next;
            } else {
                cur.next = head1;
                head1 = head1.next;
            }
            cur = cur.next;
        }
        if (head1 != null) {
            cur.next = head1;
        }
        if (head2 != null) {
            cur.next = head2;
        }
        return hair.next;
    }

    //合并有序链表递归的标准写法
    public ListNode mergeTwoLists2(ListNode list1, ListNode list2) {
        if (list1 == null) {
            return list2;
        }
        if (list2 == null) {
            return list1;
        }
        if (list2.val > list1.val) {
            list1.next = mergeTwoLists2(list1.next, list2);
            return list1;
        } else {
            list2.next = mergeTwoLists2(list2.next, list1);
            return list2;
        }
    }
```  

* 【200】给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
  * dfs遍历
  * 遇到1，从该1处把能够和它连接的1全部置为0   
```
   public int numIslands(char[][] grid) {
        if (grid == null) {
            return 0;
        }
        int res = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    private void dfs(char[][] grid, int i, int j) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == '0') {
            return;
        }
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
```
* 【54】给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 
  * 需要注意向右走有限制，因为从下往上的时候时候不能直接往右走
```
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if (matrix == null) {
            return res;
        }
        dfs(matrix, res, 0, 0);
        return res;
    }

    private void dfs(int[][] matrix, List<Integer> res, int i, int j) {
        if (i < 0 || j < 0 || i >= matrix.length || j >= matrix[0].length || matrix[i][j] == Integer.MAX_VALUE) {
            return;
        }
        res.add(matrix[i][j]);
        matrix[i][j] = Integer.MAX_VALUE;
        //需要注意向右走有限制，因为从下往上的时候时候不能直接往右走
        if (i == 0 || matrix[i - 1][j] ==  Integer.MAX_VALUE) {
            dfs(matrix, res, i, j + 1);
        }
        //向下走
        dfs(matrix, res, i + 1, j);
        //向左走
        dfs(matrix, res, i, j-1);
        //向上走
        dfs(matrix, res, i - 1, j);
    }
```

* 【46】给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案
  * 标准的回溯写法模板
```
    public List<List<Integer>> permute(int[] nums) {
        dfs(nums, new LinkedList<>(), new boolean[nums.length]);
        return res;
    }

    private void dfs(int[] nums, LinkedList<Integer> list, boolean[] visited) {
        if (list.size() == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (visited[i] ) {
                continue;
            }
            visited[i] = true;
            list.push(nums[i]);
            dfs(nums, list, visited);
            visited[i] = false;
            list.pop();
        }
    }

    List<List<Integer>> res = new ArrayList<>();
```
* 【56】以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 
  * 先排序，利用Arrays方法的排序
  * 从1开始遍历元素，和最新的结果元素的尾部比较，如果在范围之内，说明需要合并，否则结果元素顺移。
```
   public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (o1, o2) -> o1[0] - o2[0]);
        int idx = 0;
        for (int i = 1; i < intervals.length; i++) {
            //如果前一个结尾比结果的开头还大，说明需要合并
            if (intervals[idx][1] >= intervals[i][0]) {
                intervals[idx][1] = Math.max(intervals[idx][1], intervals[i][1]);
            } else {
                intervals[++idx][0] = intervals[i][0];
                intervals[idx][1] = intervals[i][1];
            }
        }
        return Arrays.copyOf(intervals, idx + 1);
    }
```
* 【124】路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点
  * 递归以某节点为起点，向下查找最大贡献值
  * 从左边找能得到的最大路径值
  * 从右边找能得到的最大路径值
  * 更新可能的最大值(路径一定时是左右连起来的)
  * 返回当前节点往下的最大值，要么左边要么右边

```
    public int maxPathSum(TreeNode root) {
        getMaxPrice(root);
        return max;
    }

    //以某节点为起点，向下查找最大贡献值
    int max = Integer.MIN_VALUE;
    private int getMaxPrice(TreeNode root) {
        if (root == null) {
            return 0;
        }
        //从左边找能得到的最大路径值，如果为负数，还不及不要
        int leftPrice = Math.max(getMaxPrice(root.left), 0);
        //从右边找能得到的最大路径值，如果为负数，还不及不要
        int rightPrice = Math.max(getMaxPrice(root.right), 0);
        //更新可能的最大值
        max = Math.max(max, root.val + leftPrice + rightPrice);
        //返回当前节点往下的最大值，要么左边要么右边
        return  Math.max(leftPrice, rightPrice) + root.val;
    }
```

* 【5】给你一个字符串 s，找到 s 中最长的回文子串。
  * 动态规划，dp[i][j]，表示两个i-j区间是否为回文串
  * 遍历顺序非常有讲究，如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1][j - 1]，来判断了[i,j]是不是回文，那结果一定是不对的
  * 所以必须保证dp[i+1][j-1]已经运算
```
    public String longestPalindrome(String s) {
        boolean[][] dp = new boolean[s.length()][s.length()];
        int len = 1, start = 0;
        for (int j = 0; j < s.length(); j++) {
            for (int i = 0; i <= j; i++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = (j - i < 3) ? true : dp[i + 1][j - 1];
                    if (dp[i][j] && j - i + 1 > len) {
                        len = j - i + 1;
                        start = i;
                    }
                }
            }
        }
        return s.substring(start, start + len);
    }
```

* 【79】给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false
   * 方法1，标准的回溯，定义一个visited，结果和目标一直比对
   * 方法2，定义一个level变量，一级一级的比较，如果不相同就返回false
   * 小技巧，board[i][j]+=256就可以避免使用visited了
```
方法2（优）
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (dfs(board, i,j, 0, words)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(char[][] board, int i, int j, int level, char[] words) {
        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != words[level]) {
            return false;
        }
        if (level == words.length -1) {
            return true;
        }
        board[i][j]+=256;
        boolean res = dfs(board, i+1,j,level + 1, words)
                || dfs(board, i,j+1,level + 1, words)
                || dfs(board, i-1,j,level + 1, words) || dfs(board, i,j-1,level + 1, words);
        board[i][j]-=256;
        return res;
    }

方法1，标准
    public boolean exist(char[][] board, String word) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (dfs(board, i,j, new boolean[board.length][board[0].length], "", word)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(char[][] board, int i, int j, boolean[][] visited,String res, String word) {
        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j]) {
            return false;
        }
        res += board[i][j];
        if (res.length() > word.length() || !word.startsWith(res)) {
            return false;
        }
        if (res.length() == word.length() && res.equals(word)) {
            return true;
        }
        visited[i][j] = true;
        boolean f = dfs(board, i+1,j,visited,res, word)
                || dfs(board, i,j+1,visited,res, word)
                || dfs(board, i-1,j,visited,res, word) || dfs(board, i,j-1,visited,res, word);
        visited[i][j] = false;
        return f;
    }
```

* 【22】数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合，有效括号组合需满足：左括号必须以正确的顺序闭合
  * dfs
  * 剪枝
  * 生成括号的时候，右小括号一定要满足数小于左括号，可以是(()也可以是（）（
  * left > n的要剪枝掉
  * left > right 的要剪枝掉
```
    public List<String> generateParenthesis(int n) {
        dfs("", n, 0, 0);
        return res;
    }
    List<String> res = new ArrayList<>();
    private void dfs(String s, int n, int left, int right) {
        //生成括号数等于
        if (s.length() == 2 * n) {
            res.add(s);
            return;
        }
        //如果左括号小于n，需要继续生成括号
        if (left < n) {
            dfs(s + "(", n, left + 1, right);
        }
        //如果左括号大于右括号，需要继续生成右括号
        if (left > right) {
            dfs(s + ")", n, left, right + 1);
        }
    }
```

* 【78】给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 
  * 递归回溯
```
    // [1,2,3]
    //[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]
    public List<List<Integer>> subsets(int[] nums) {
        dfs(nums, new LinkedList<>(), 0);
        return res;
    }
    List<List<Integer>> res = new ArrayList<>();
    private void dfs(int[] nums, LinkedList<Integer> list, int level) {
        //包含的有空元素，不需要判断
        res.add(new ArrayList<>(list));
        for (int i = level; i < nums.length; i++) {
            list.add(nums[i]);
            dfs(nums, list, i + 1);
            list.removeLast();
        }
    }
```

* 【39】给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合
  * 标准的回溯
  * 注意如何去重，需要传递一个下标，从这个标开始,可以收画一画就知道了
```
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(candidates,  0, new LinkedList<>(), target);
        return res;
    }
    List<List<Integer>> res = new ArrayList<>();
    private void dfs(int[] candidates,  int idx, LinkedList list, int target) {
        if (target < 0) {
            return;
        }
        if (target == 0) {
            res.add(new LinkedList<>(list));
            return;
        }
        for (int i = idx; i < candidates.length; i++) {
            target -= candidates[i];
            list.push(candidates[i]);
            dfs(candidates, i, list, target);
            list.pop();
            target += candidates[i];
        }
    }
```


* 【93】有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔
  * 递归组合进行拼接，每递归一次就相当于拼接1次，拼接的时候循环选择从0到4位进行拼接
  * 可以将ip分为4截
  * 传入条件：要组合的起始位置，第几截，拼接的字符串
```
    public List<String> restoreIpAddresses(String s) {
        dfs(s, 0, 0,"");
        return res;
    }
    List<String> res = new ArrayList<>();
    private void dfs(String s, int start, int count, String x) {
        if (count > 4) {
            return;
        }
        //说明以及拼接好了
        if (x.length() == s.length() + 3) {
            res.add(x);
            return;
        }
        //一共有4段，每一段的字符数应该小于4个
        for (int j = 0; j < 4 && (start + j) < s.length(); j++) {
            String seg = s.substring(start, start+j+1);
            if (Integer.valueOf(seg) > 255 || (seg.length() > 1 && seg.charAt(0) == '0')) {
                continue;
            }
            dfs(s, start + seg.length(),count + 1,  x.length() == 0 ? seg : x + "." + seg);
        }
    }
```

* 【113】给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 
  * 注意当targetsum == 0时，不能直接返回，因为list的元素没有回溯

```
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root, new LinkedList<>(), targetSum);
        return res;
    }
    List<List<Integer>> res = new LinkedList<>();
    private void dfs(TreeNode root, LinkedList<Integer> list, int targetSum) {
        if (root == null) {
            return;
        }
        targetSum -= root.val;
        list.addLast(root.val);
        //说明是叶子节点
        if (root.left == null && root.right == null) {
            if (targetSum == 0) {
                res.add(new LinkedList(list));
                //注意这里不能截至，因为已经list.push(root.val)元素了，需要回溯一下
                //return;
            }
        }
        dfs(root.left, list, targetSum);
        dfs(root.right, list, targetSum);
        list.removeLast();
    }
```  
* 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点
  * 分治
  * 每个节点的左最大高度加上右边的最大高度，就是当前经过这个节点的宽度
  * 注意边界条件

```
    public int diameterOfBinaryTree(TreeNode root) {
        getMaxDeep(root);
        return max;
    }
    int max = 0;
    private int getMaxDeep(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMaxDeep = getMaxDeep(root.left), rightMaxDeep = getMaxDeep(root.right);
        max = Math.max(leftMaxDeep + rightMaxDeep, max);
        return Math.max(leftMaxDeep, rightMaxDeep) + 1;
    }
```

* 【329】给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。 
  * dfs遍历每个点，以它为起点的最长的递增长度。
  * 直接遍历然后取最大值会出现超时
  * 因为每一个点为起点的最大值记录后，就可以不用遍历了，使用cache记住即可
  * dfs方法的意思就是获取（i. j）节点为起点的最大递增长度
```
    public int longestIncreasingPath(int[][] matrix) {
        if (matrix == null ||matrix.length == 0) {
            return 0;
        }
        cache = new int[matrix.length][matrix[0].length];
        int max = 0;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                max = Math.max(getMaxLength(matrix, i, j), max);
            }
        }
        return max;
    }
    int[][] cache;
    //int[][] ops = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    //获取（i. j）节点为起点的最大递增长度
    private int getMaxLength(int[][] matrix, int i, int j) {
        if (cache[i][j] > 0) {
            return cache[i][j];
        }
        int curMax = 1;
        for (int[] op : ops) {
            int x = i + op[0], y = j + op[1];
            if (x >= 0 && y >= 0 && x < matrix.length
                    && y < matrix[0].length && matrix[x][y] > matrix[i][j]) {
                curMax = Math.max(curMax, getMaxLength(matrix, x, y) + 1);
            }
        }
        cache[i][j] = curMax;
        return curMax;
    }
```

* 【695】岛屿的最大面积，岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着,岛屿的面积是岛上值为 1 的单元格的数目,计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0
  * dfs
  * 获取某个点开始统计的1的数量。
```
    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    max = Math.max(max, getNumOneNums(i, j, grid));
                }
            }
        }
        return max;
    }


    private int getNumOneNums(int i, int j, int[][] grid) {
        //如果超越边界则返回0
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {
            return 0;
        }
        grid[i][j] = 0;
        return 1 + getNumOneNums(i + 1, j, grid) +
                getNumOneNums(i - 1, j, grid) +
                getNumOneNums(i, j + 1, grid) +
                getNumOneNums(i, j - 1, grid);
    }
```



* 【112】给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和targetSum
```
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        targetSum -= root.val;
        if (root.left == null && root.right == null&&  targetSum == 0) {
            return true;
        }
        return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);
    }
```


* 【40】给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合
  * 给定的数组可能有重复的元素，先排序，使得重复的数字相邻，方便去重
  * for 枚举出选项时，加入下面判断，从而忽略掉同一层重复的选项，避免产生重复的组合。比如[1,2,2,2,5]，选了第一个 2，变成 [1,2]，它的下一选项也是 2，跳过它，因为如果选它，就还是 [1,2]
```
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        dfs(candidates, new LinkedList<Integer>(), 0, target);
        return res;
    }

    List<List<Integer>> res = new ArrayList();

    private void dfs(int[] candidates, LinkedList<Integer> list, int idx, int target) {
        if (target < 0) {
            return;
        }
        if (target == 0) {
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = idx; i < candidates.length; i++) {
            //这里如何去重
            if (i > idx && candidates[i] == candidates[i - 1]) {
                continue;
            }
            list.push(candidates[i]);
            dfs(candidates, list, i + 1, target - candidates[i]);
            list.pop();
        }

    }
```