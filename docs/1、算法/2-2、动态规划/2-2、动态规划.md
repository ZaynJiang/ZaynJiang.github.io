## 1. 动态规划
## 2. 经典题目
* 【121】给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 
  *  dp表示第i天持有和不持有的最大利润
  *  今日持股：昨天不持股今天持股，昨天持股今天不变
  *  今日不持股：昨天不持股今天不持股，昨天持股今天抛
```
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        //第n天的最大利润
        int[][] dp = new int[prices.length][2];
        //dp[0][0]，第0天持股
        dp[0][0] = - prices[0];
        //dp[0][1]，第0天不持股
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            //今日持股：昨天不持股今天持股，昨天持股今天不变
            dp[i][0] = Math.max(-prices[i], dp[i-1][0]);
            //今日不持股：昨天不持股今天不持股，昨天持股今天抛
            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);
        }
        return dp[prices.length-1][1];
    }

    //空间优化版
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        //第n天的最大利润
        //dp[0][0]，第0天持股
        int preChi = -prices[0], preBu = 0;
        for (int i = 1; i < prices.length; i++) {
            //今日持股：昨天不持股今天持股，昨天持股今天不变
            preChi= Math.max(-prices[i], preChi);
            //今日不持股：昨天不持股今天不持股，昨天持股今天抛
            preBu = Math.max(preChi + prices[i], preBu);
        }
        return preBu;
    }    
```

* 【300】给你一个整数数组 nums ，找到其中最长严格递增子序列的长度
  * 方法一：动态规划
  * 2层循环，以i结尾的严格递增长度
  * 返回dp的最大值即可
  * 还可以使用2分法和贪心策略优化
  * 方法二：二分法+贪心
  * 维护一个长度数组：第一位代表长度为1的结尾的数，第二位代表长度2为结尾的数，以此类推
  * 线性遍历原数组，取到元素后，二分查找长度数组中比它大的元素覆盖。

```
    // 方法1动态编程
    public int lengthOfLIS(int[] nums) {
        //最长
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int len = 1;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= i; j++) {
                dp[i] = Math.max(dp[i], nums[i] > nums[j] ? dp[j] + 1 : 1);
            }
            len = Math.max(len, dp[i]);
        }
        return len;
    }
    
    //二分法优化求解
    public int lengthOfLIS(int[] nums) {
    //最长
    int[] tails = new int[nums.length];
    int len = 0;
    for (int num : nums) {
        int i = 0, j = len;
        while (i < j) {
            int mid = (i + j) >> 1;
            if (tails[mid] < num) {
                i = mid+1;
            } else {
                j = mid;
            }
        }
        tails[i] = num;
        if (i == len) {
            len++;
        }
    }
    return len;
}
```

* 【32】给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度
  *  动态规划
  *  dp代表第i个字符，以i字符结尾的最长有效括号数
  * 有三种情况 xx|xxxxxx)
  * 有三种情况 xx|xxxxxx)
  * 第一种情况 xx|xxxxx()  //dp[i-2] + 2;
  * 有二种情况 x)|(xxxx))  //(i - dp[i-1] -2)位字符位"）"和（i）位字符")"不构成有效括号为0
  * 有三种情况 x(|(xxxx))  //(i - dp[i-1] -2)位字符位"("和（i）位字符")"构成有效括号dp[i - dp[i-1] -2] + dp[i-1] + 2
```
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length() + 1];
        int max = 0;
        for (int i = 2; i <= s.length(); i++) {
            char cur = s.charAt(i-1);
            if (cur == ')') {
                char pre = s.charAt(i - 2);
                if (pre == ')') {
                    //x)|(xxxx))与最后字符不构成有效括号:dp[i]=0；
                    //()(|(xxxx))与最后字符构成有效括号:dp[i - dp[i-1] -2](前面有效数) + dp[i-1] + 2
                    dp[i] = i - dp[i-1] -2 >= 0 && s.charAt(i-dp[i-1]-2) == '(' ? dp[i - dp[i-1] -2] + dp[i-1] + 2 : 0;
                } else {
                    dp[i] = dp[i-2] + 2;
                }
                max = Math.max(max, dp[i]);
            }
        }
        return max;
    }

```


* 【221】在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积
* dp[i][j] 代表第i,j结尾的方块的最大正方形边长大小
* dp[i][j] 如果当前为1，则寻找左上斜上最小者最为边长+1
```
public int maximalSquare(char[][] matrix) {
    //dp[][] 代表第i,j结尾的方块的最大正方形数.
    //dp[i][0] dp[0][i] 都为0，因为不会构成正方形
    int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];
    int maxSide = 0;
    for (int i = 1; i <= matrix.length; i++) {
        for (int j = 1; j <= matrix[0].length; j++) {
            if (matrix[i - 1][j - 1] == '1') {
                dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;
                maxSide = Math.max(dp[i][j], maxSide);
            }
        }
    }
    return maxSide * maxSide;
}
```

* 【322】 零钱兑换，计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1
  *  dp[i] = Math.min(dp[i-coin]+1, dp[i]);
  *  注意初始条件Arrays.fill(dp, Integer.MAX_VALUE);
  *  递推公式的特性，dp[i]必须初始化为一个最大的数，否则就会在min(dp[i - coin] + 1, dp[i])比较的过程中被初始值覆盖
  *  凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0
  *  dp[i-coin]为Integer.MAX_VALUE时需要掠过，因为没有意义了
```
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i - coin >= 0 && dp[i-coin] != Integer.MAX_VALUE) {
                    dp[i] =  Math.min(dp[i-coin]+1, dp[i]);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
```

* 【53】 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和
  * 动态规划
  * dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
  * 注意不是根据nums[i]大于0来判断，因为nums[i]小于0也能找到以它为结尾的连续最大值。
```
   public int maxSubArray(int[] nums) {
        //以i为结尾的最大连续序列的和
        int[] dp = new int[nums.length];
        int max = nums[0];
        dp[0] = max;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
            max = Math.max(dp[i], max);
        }
        return max;
    }
```

* 【122】给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格.设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 
  * 动态规划
  * 动态转移方程，第i天持有和第i天不持有的状态
```
    public int maxProfit(int[] prices) {
        // 表示第n天的利润，0是持有股票，1是不持有股票
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            //第i天持有股票，有两种来源：第i-1不持有第i天持有；第i-1持有，i天啥都不做也持有
            dp[i][0] = Math.max(dp[i-1][1] - prices[i], dp[i-1][0]);
            //第i天持不持有股票，有两种来源：第i-1不持有第i天不持有；第i-1持有，i天卖出
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
```

* 【512】给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 
  * 注意改题目和爬楼梯不一样，这个是组合问题，爬楼梯是排列问题
  * 先走2步再走1步和先走1步再走2步不同，先拿2块再拿1块和先拿1块再拿2块相同
  * 遍历顺序不一样
  * 组合问题其实是在每一次for coin in coins循环中就把coin的可使用次数规定好了。不允许在后面的硬币层次使用之前的硬币。 这就像排列中2,2,1; 2,1,2是两种情况，但是组合问题规定好了一种书写顺序，比如大的写在前面那就只有2,2,1这一种情况了

```
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = 1; i <= amount; i++) {
                if (i - coin >= 0) {
                    //最后一枚是每一种硬币的组合数
                    dp[i] += dp[i - coin];
                }
            }
        }
        return dp[amount];
    }
```

* 【198】给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额
  * 动态规划
  * 标准转移方程dp[i][0] = dp[i - 1][1] + nums[i];dp[i][1] = Math.max(dp[i - 1][1], dp[i-1][0]);
  * 可以空间优化
```
    public int rob(int[] nums) {
        //第i个房子持有的最大金额：0是偷，1是不偷
        int[][] dp = new int[nums.length][2];
        dp[0][0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            //第i个房子偷钱: i-1不偷 + i偷
            dp[i][0] = dp[i - 1][1] + nums[i];
            // 第i个房子不偷
            dp[i][1] = Math.max(dp[i - 1][1], dp[i-1][0]);
        }
        return Math.max(dp[nums.length-1][0], dp[nums.length-1][1]);
    }
    public int rob(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        //f(x) = max(f(x), f(x-2)+nums[x]);
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0],nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);
        }
        return dp[nums.length-1];
    }
```

* 【72】给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
  * dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作
```
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length()+1][word2.length()+1];
        for (int i = 1; i <= word1.length(); i++) {
            dp[i][0] = i;
        }
        for (int i = 1; i <= word2.length(); i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1])  + 1;
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
```


* 【64】给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 
```
    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            dp[i][0] = (i > 0 ? dp[i - 1][0] : 0) + grid[i][0];
        }
        for (int i = 0; i < grid[0].length; i++) {
            dp[0][i] = (i > 0 ? dp[0][i - 1] : 0) + grid[0][i];
        }
        for (int i = 1; i < grid.length; i++) {
            for (int j = 1; j < grid[0].length; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[grid.length-1][grid[0].length-1];
    }
```

* 【70】假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 
```
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int n1 = 2, n2 = 1;
        for (int i = 3; i <= n; i++) {
            int temp = n1;
            n1 = n1 + n2;
            n2 = temp;
        }
        return n1;
    }
```

* 【139】给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词
  * 背包问题
```
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (String word : wordDict) {
                if (i >= word.length() &&
                        word.equals(s.substring(i - word.length(), i))){
                    dp[i] = dp[i - word.length()] || dp[i];
                }
            }
        }
        return dp[s.length()];
    }
```

* **【10】给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。**   
  * dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配
  * 有序列表当s和p对应的当前元素相等，或者当前p为’.’，那么dp[i][j] = dp[i-1][j-1];
  * 有序列表如果当前p为’*’，并且p前一个字符为不等于s的当前字符，且p前一个字符不为‘.’，那么dp[i][j] = dp[i][j-2];
  * 如果当前p为’*’，由于*可以表示字符的数量，那么可以分为3种情况
    * *表示0：dp[i][j] = dp[i][j-2]; 如 acb 和 aca*b;
    * *表示1：dp[i][j] = dp[i][j-1]; 如 acab 和 aca*b
    * *表示大于等于2：dp[i][j] = dp[i-1][j]; 如 acaab 和 aca*b
  * 需要将二维空间的第0行填好，就是统计*对结果的影响；对于i = 0而言，只需要设置*表示0，就是dp[i][j] = dp[i][j-2];
    ```
        public boolean isMatch(String s, String p) {
            boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
            dp[0][0] = true;
            //统计边界情况，“”字符串对于表达式xxx*，只有*号匹配0个才可能匹配成功。
            for (int i = 1; i <= p.length(); i++) {
                //校验当前是*且上上个也是*
                if (p.charAt(i - 1) == '*' && dp[0][i - 2]) {
                    dp[0][i] = true;
                }
            }
            for (int i = 1; i <= s.length(); i++) {
                for (int j = 1; j <= p.length(); j++) {
                    // i和j相等，包含.的情况,和上一个匹配相等
                    if (p.charAt(j-1) == '.' || s.charAt(i - 1) == p.charAt(j - 1)) {
                        dp[i][j] = dp[i-1][j-1];
                    } else if (p.charAt(j - 1) == '*') {
                        // 模式串*的前一个字符能够跟文本串的末位匹配上
                        if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') {
                            dp[i][j] = dp[i][j - 2]      // *匹配0次的情况
                                    || dp[i - 1][j];     // *匹配1次或多次的情况
                        } else { // 模式串*的前一个字符不能够跟文本串的末位匹配
                            dp[i][j] = dp[i][j - 2];     // *只能匹配0次
                        }
                    }
                }
            }
            return dp[s.length()][p.length()];
        }
    ```
    解析：
    ```
        以一个例子详解动态规划转移方程：
        S = abbbbc
        P = ab*d*c
        1. 当 i, j 指向的字符均为字母（或 '.' 可以看成一个特殊的字母）时，
        只需判断对应位置的字符即可，
        若相等，只需判断 i,j 之前的字符串是否匹配即可，转化为子问题 f[i-1][j-1].
        若不等，则当前的 i,j 肯定不能匹配，为 false.
        
            f[i-1][j-1]   i
                    |        |
        S [a  b  b  b  b][c] 
        
        P [a  b  *  d  *][c]
                            |
                            j
        
    
        1. 如果当前 j 指向的字符为 '*'，则不妨把类似 'a*', 'b*' 等的当成整体看待。
        看下面的例子
    
                    i
                    |
        S  a  b [b] b  b  c  
        
        P  a [b  *] d  *  c
                    |
                    j
        
        注意到当 'b*' 匹配完 'b' 之后，它仍然可以继续发挥作用。
        因此可以只把 i 前移一位，而不丢弃 'b*', 转化为子问题 f[i-1][j]:
        
                i
                | <--
        S  a [b] b  b  b  c  
        
        P  a [b  *] d  *  c
                    |
                    j
        
        另外，也可以选择让 'b*' 不再进行匹配，把 'b*' 丢弃。
        转化为子问题 f[i][j-2]:
    
                    i
                    |
        S  a  b [b] b  b  c  
            
        P [a] b  *  d  *  c
            |
            j <--
    
        1. 冗余的状态转移不会影响答案，
        因为当 j 指向 'b*' 中的 'b' 时, 这个状态对于答案是没有用的,
        原因参见评论区 稳中求胜 的解释, 当 j 指向 '*' 时,
        dp[i][j]只与dp[i][j-2]有关, 跳过了 dp[i][j-1].
    ```

* 【152】给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积
  * dp分别代表以i结尾的最大值和最小值
  * 以i结尾的最小值有三种情况：本身、前一个最大值乘以本身，前一个最小值诚意本身
  * 以i结尾的最大值有三种情况：本身、前一个最大值乘以本身，前一个最小值诚意本身

    ```
     public int maxProduct(int[] nums) {
        //分别代表以i结尾的最大值和最小值
        int[] max = new int[nums.length], min = new int[nums.length];
        max[0] = nums[0];
        min[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            //以i结尾的最大值有三种情况：本身、前一个最大值乘以本身，前一个最小值诚意本身
            max[i] = Math.max(nums[i], Math.max(max[i-1]*nums[i], min[i-1]*nums[i]));
            //以i结尾的最小值有三种情况：本身、前一个最大值乘以本身，前一个最小值诚意本身
            min[i] = Math.min(nums[i], Math.min(max[i-1]*nums[i], min[i-1]*nums[i]));
            res = Math.max(max[i], res);
        }
        return res;
    }
    ```

* 【91】一条包含字母 A-Z 的消息通过以下映射进行了'A' -> 1、'B' -> 2、'Z' -> 26；要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为"AAJF" ，将消息分组为 (1 1 10 6) ； "KJF" ，将消息分组为 (11 10 6)注意，消息不能分组为 (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。 
  * 以某个数字为结尾，有两种可能：一种连数dp[i-2]，一种非连数dp[i-1],出现连数的可能为two >= 10 && two <= 26
  * 有0种方法可以解码空字符串。dp[0]设置为1仅用于获取dp[2]的结果。如果这让你困惑，那么就这样想吧。您有一个字符串“12”，您可以将其解码为“2”或“12”。现在，如果选择“12”，则dp[2]+=dp[0]。如果dp[0]为0，则不能将“12”作为解码方式。因此dp[0]必须为1。


```
    public int numDecodings(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int[] dp = new int[s.length() + 1];
        dp[0] = 1;
        dp[1] = s.charAt(0) == '0' ? 0 : 1;
        for (int i = 2; i <= s.length(); i++) {
            int two = Integer.valueOf(s.substring(i - 2, i)); //获取前两个数字
            if (s.charAt(i - 1) != '0') {
                dp[i] += dp[i - 1]; // 加上21（2）的情况
            }
            if (two >= 10 && two <= 26) {
                dp[i] += dp[i - 2]; // 加上2（12）的情况
            }
        }
        return dp[s.length()];

```
* 【188】给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 
  *     //dp[i][][]表示第i天的持有的最大利润：
  *    //dp[i][][0]表示不持有 股票，完成了（1，2，3...k）交易的最大利润
  *   //dp[i][][1]持有 股票，完成了（1，2，3...k）交易的最大利润
  *    //dp[i][j][0]表示第i天，交易了j次，不持有股票：昨天也不持有,昨天持有今天卖了
  *    //dp[i][j][1]表示第i天，交易了j次，持有股票：昨天也持有,昨天不持有今天买入了
  *    //最大交易次数不会超过数组的一半的

```
public int maxProfit(int k, int[] prices) {
    if(k <= 0 || prices.length <= 0) {
        return 0;
    }
    k = Math.min(k, prices.length / 2);
    int[][][] dp = new int[prices.length][k + 1][2];
    for (int i = 0; i <= k; i++) {
        dp[0][i][1] = -prices[0];
    }
    for (int i = 1; i < prices.length; i++) {
        for (int j = 1; j <= k; j++) {
            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
        }
    }
    return dp[prices.length - 1][k][0];
}
```

* 【62】一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）问总共有多少条不同的路径？ 
  * 标准的动态规划
  * 注意当i=0或者j=0只有一种路径。

    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];