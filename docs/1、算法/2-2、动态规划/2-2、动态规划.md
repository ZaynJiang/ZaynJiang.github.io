## 1. 动态规划
## 2. 经典题目
* 【121】给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 
  *  dp表示第i天持有和不持有的最大利润
  *  今日持股：昨天不持股今天持股，昨天持股今天不变
  *  今日不持股：昨天不持股今天不持股，昨天持股今天抛
```
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        //第n天的最大利润
        int[][] dp = new int[prices.length][2];
        //dp[0][0]，第0天持股
        dp[0][0] = - prices[0];
        //dp[0][1]，第0天不持股
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            //今日持股：昨天不持股今天持股，昨天持股今天不变
            dp[i][0] = Math.max(-prices[i], dp[i-1][0]);
            //今日不持股：昨天不持股今天不持股，昨天持股今天抛
            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);
        }
        return dp[prices.length-1][1];
    }

    //空间优化版
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        //第n天的最大利润
        //dp[0][0]，第0天持股
        int preChi = -prices[0], preBu = 0;
        for (int i = 1; i < prices.length; i++) {
            //今日持股：昨天不持股今天持股，昨天持股今天不变
            preChi= Math.max(-prices[i], preChi);
            //今日不持股：昨天不持股今天不持股，昨天持股今天抛
            preBu = Math.max(preChi + prices[i], preBu);
        }
        return preBu;
    }    
```

* 【300】给你一个整数数组 nums ，找到其中最长严格递增子序列的长度
  * 方法一：动态规划
  * 2层循环，以i结尾的严格递增长度
  * 返回dp的最大值即可
  * 还可以使用2分法和贪心策略优化
  * 方法二：二分法+贪心
  * 维护一个长度数组：第一位代表长度为1的结尾的数，第二位代表长度2为结尾的数，以此类推
  * 线性遍历原数组，取到元素后，二分查找长度数组中比它大的元素覆盖。

```
    // 方法1动态编程
    public int lengthOfLIS(int[] nums) {
        //最长
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int len = 1;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= i; j++) {
                dp[i] = Math.max(dp[i], nums[i] > nums[j] ? dp[j] + 1 : 1);
            }
            len = Math.max(len, dp[i]);
        }
        return len;
    }
    
    //二分法优化求解
    public int lengthOfLIS(int[] nums) {
    //最长
    int[] tails = new int[nums.length];
    int len = 0;
    for (int num : nums) {
        int i = 0, j = len;
        while (i < j) {
            int mid = (i + j) >> 1;
            if (tails[mid] < num) {
                i = mid+1;
            } else {
                j = mid;
            }
        }
        tails[i] = num;
        if (i == len) {
            len++;
        }
    }
    return len;
}
```

* 【32】给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度
  *  动态规划
  *  dp代表第i个字符，以i字符结尾的最长有效括号数
  * 有三种情况 xx|xxxxxx)
  * 有三种情况 xx|xxxxxx)
  * 第一种情况 xx|xxxxx()  //dp[i-2] + 2;
  * 有二种情况 x)|(xxxx))  //(i - dp[i-1] -2)位字符位"）"和（i）位字符")"不构成有效括号为0
  * 有三种情况 x(|(xxxx))  //(i - dp[i-1] -2)位字符位"("和（i）位字符")"构成有效括号dp[i - dp[i-1] -2] + dp[i-1] + 2
```
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length() + 1];
        int max = 0;
        for (int i = 2; i <= s.length(); i++) {
            char cur = s.charAt(i-1);
            if (cur == ')') {
                char pre = s.charAt(i - 2);
                if (pre == ')') {
                    //x)|(xxxx))与最后字符不构成有效括号:dp[i]=0；
                    //()(|(xxxx))与最后字符构成有效括号:dp[i - dp[i-1] -2](前面有效数) + dp[i-1] + 2
                    dp[i] = i - dp[i-1] -2 >= 0 && s.charAt(i-dp[i-1]-2) == '(' ? dp[i - dp[i-1] -2] + dp[i-1] + 2 : 0;
                } else {
                    dp[i] = dp[i-2] + 2;
                }
                max = Math.max(max, dp[i]);
            }
        }
        return max;
    }

```


* 【221】在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积
* dp[i][j] 代表第i,j结尾的方块的最大正方形边长大小
* dp[i][j] 如果当前为1，则寻找左上斜上最小者最为边长+1
```
public int maximalSquare(char[][] matrix) {
    //dp[][] 代表第i,j结尾的方块的最大正方形数.
    //dp[i][0] dp[0][i] 都为0，因为不会构成正方形
    int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];
    int maxSide = 0;
    for (int i = 1; i <= matrix.length; i++) {
        for (int j = 1; j <= matrix[0].length; j++) {
            if (matrix[i - 1][j - 1] == '1') {
                dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;
                maxSide = Math.max(dp[i][j], maxSide);
            }
        }
    }
    return maxSide * maxSide;
}
```

* 【322】 零钱兑换，计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1
  *  dp[i] = Math.min(dp[i-coin]+1, dp[i]);
  *  注意初始条件Arrays.fill(dp, Integer.MAX_VALUE);
  *  递推公式的特性，dp[i]必须初始化为一个最大的数，否则就会在min(dp[i - coin] + 1, dp[i])比较的过程中被初始值覆盖
  *  凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0
  *  dp[i-coin]为Integer.MAX_VALUE时需要掠过，因为没有意义了
```
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i - coin >= 0 && dp[i-coin] != Integer.MAX_VALUE) {
                    dp[i] =  Math.min(dp[i-coin]+1, dp[i]);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
```

* 【53】 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和
  * 动态规划
  * dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
  * 注意不是根据nums[i]大于0来判断，因为nums[i]小于0也能找到以它为结尾的连续最大值。
```
   public int maxSubArray(int[] nums) {
        //以i为结尾的最大连续序列的和
        int[] dp = new int[nums.length];
        int max = nums[0];
        dp[0] = max;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
            max = Math.max(dp[i], max);
        }
        return max;
    }
```

* 【122】给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格.设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 
  * 动态规划
  * 动态转移方程，第i天持有和第i天不持有的状态
```
    public int maxProfit(int[] prices) {
        // 表示第n天的利润，0是持有股票，1是不持有股票
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            //第i天持有股票，有两种来源：第i-1不持有第i天持有；第i-1持有，i天啥都不做也持有
            dp[i][0] = Math.max(dp[i-1][1] - prices[i], dp[i-1][0]);
            //第i天持不持有股票，有两种来源：第i-1不持有第i天不持有；第i-1持有，i天卖出
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
```

* 【512】给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 
  * 注意改题目和爬楼梯不一样，这个是组合问题，爬楼梯是排列问题
  * 先走2步再走1步和先走1步再走2步不同，先拿2块再拿1块和先拿1块再拿2块相同
  * 遍历顺序不一样
  * 组合问题其实是在每一次for coin in coins循环中就把coin的可使用次数规定好了。不允许在后面的硬币层次使用之前的硬币。 这就像排列中2,2,1; 2,1,2是两种情况，但是组合问题规定好了一种书写顺序，比如大的写在前面那就只有2,2,1这一种情况了

```
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = 1; i <= amount; i++) {
                if (i - coin >= 0) {
                    //最后一枚是每一种硬币的组合数
                    dp[i] += dp[i - coin];
                }
            }
        }
        return dp[amount];
    }
```

* 【198】给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额
  * 动态规划
  * 标准转移方程dp[i][0] = dp[i - 1][1] + nums[i];dp[i][1] = Math.max(dp[i - 1][1], dp[i-1][0]);
  * 可以空间优化
```
    public int rob(int[] nums) {
        //第i个房子持有的最大金额：0是偷，1是不偷
        int[][] dp = new int[nums.length][2];
        dp[0][0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            //第i个房子偷钱: i-1不偷 + i偷
            dp[i][0] = dp[i - 1][1] + nums[i];
            // 第i个房子不偷
            dp[i][1] = Math.max(dp[i - 1][1], dp[i-1][0]);
        }
        return Math.max(dp[nums.length-1][0], dp[nums.length-1][1]);
    }
    public int rob(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        //f(x) = max(f(x), f(x-2)+nums[x]);
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0],nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);
        }
        return dp[nums.length-1];
    }
```

* 【72】给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
  * dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作
```
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length()+1][word2.length()+1];
        for (int i = 1; i <= word1.length(); i++) {
            dp[i][0] = i;
        }
        for (int i = 1; i <= word2.length(); i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1])  + 1;
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
```


* 【64】给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 
```
    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            dp[i][0] = (i > 0 ? dp[i - 1][0] : 0) + grid[i][0];
        }
        for (int i = 0; i < grid[0].length; i++) {
            dp[0][i] = (i > 0 ? dp[0][i - 1] : 0) + grid[0][i];
        }
        for (int i = 1; i < grid.length; i++) {
            for (int j = 1; j < grid[0].length; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[grid.length-1][grid[0].length-1];
    }
```

* 【70】假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 
```
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int n1 = 2, n2 = 1;
        for (int i = 3; i <= n; i++) {
            int temp = n1;
            n1 = n1 + n2;
            n2 = temp;
        }
        return n1;
    }
```

* 【139】给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词
  * 背包问题
```
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (String word : wordDict) {
                if (i >= word.length() &&
                        word.equals(s.substring(i - word.length(), i))){
                    dp[i] = dp[i - word.length()] || dp[i];
                }
            }
        }
        return dp[s.length()];
    }
```

* **【10】给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。**   
  * dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配
  * 有序列表当s和p对应的当前元素相等，或者当前p为’.’，那么dp[i][j] = dp[i-1][j-1];
  * 有序列表如果当前p为’*’，并且p前一个字符为不等于s的当前字符，且p前一个字符不为‘.’，那么dp[i][j] = dp[i][j-2];
  * 如果当前p为’*’，由于*可以表示字符的数量，那么可以分为3种情况
    * *表示0：dp[i][j] = dp[i][j-2]; 如 acb 和 aca*b;
    * *表示1：dp[i][j] = dp[i][j-1]; 如 acab 和 aca*b
    * *表示大于等于2：dp[i][j] = dp[i-1][j]; 如 acaab 和 aca*b
  * 需要将二维空间的第0行填好，就是统计*对结果的影响；对于i = 0而言，只需要设置*表示0，就是dp[i][j] = dp[i][j-2];
    ```
        public boolean isMatch(String s, String p) {
            boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
            dp[0][0] = true;
            //统计边界情况，“”字符串对于表达式xxx*，只有*号匹配0个才可能匹配成功。
            for (int i = 1; i <= p.length(); i++) {
                //校验当前是*且上上个也是*
                if (p.charAt(i - 1) == '*' && dp[0][i - 2]) {
                    dp[0][i] = true;
                }
            }
            for (int i = 1; i <= s.length(); i++) {
                for (int j = 1; j <= p.length(); j++) {
                    // i和j相等，包含.的情况,和上一个匹配相等
                    if (p.charAt(j-1) == '.' || s.charAt(i - 1) == p.charAt(j - 1)) {
                        dp[i][j] = dp[i-1][j-1];
                    } else if (p.charAt(j - 1) == '*') {
                        // 模式串*的前一个字符能够跟文本串的末位匹配上
                        if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') {
                            dp[i][j] = dp[i][j - 2]      // *匹配0次的情况
                                    || dp[i - 1][j];     // *匹配1次或多次的情况
                        } else { // 模式串*的前一个字符不能够跟文本串的末位匹配
                            dp[i][j] = dp[i][j - 2];     // *只能匹配0次
                        }
                    }
                }
            }
            return dp[s.length()][p.length()];
        }
    ```
    解析：
    ```
        以一个例子详解动态规划转移方程：
        S = abbbbc
        P = ab*d*c
        1. 当 i, j 指向的字符均为字母（或 '.' 可以看成一个特殊的字母）时，
        只需判断对应位置的字符即可，
        若相等，只需判断 i,j 之前的字符串是否匹配即可，转化为子问题 f[i-1][j-1].
        若不等，则当前的 i,j 肯定不能匹配，为 false.
        
            f[i-1][j-1]   i
                    |        |
        S [a  b  b  b  b][c] 
        
        P [a  b  *  d  *][c]
                            |
                            j
        
    
        1. 如果当前 j 指向的字符为 '*'，则不妨把类似 'a*', 'b*' 等的当成整体看待。
        看下面的例子
    
                    i
                    |
        S  a  b [b] b  b  c  
        
        P  a [b  *] d  *  c
                    |
                    j
        
        注意到当 'b*' 匹配完 'b' 之后，它仍然可以继续发挥作用。
        因此可以只把 i 前移一位，而不丢弃 'b*', 转化为子问题 f[i-1][j]:
        
                i
                | <--
        S  a [b] b  b  b  c  
        
        P  a [b  *] d  *  c
                    |
                    j
        
        另外，也可以选择让 'b*' 不再进行匹配，把 'b*' 丢弃。
        转化为子问题 f[i][j-2]:
    
                    i
                    |
        S  a  b [b] b  b  c  
            
        P [a] b  *  d  *  c
            |
            j <--
    
        1. 冗余的状态转移不会影响答案，
        因为当 j 指向 'b*' 中的 'b' 时, 这个状态对于答案是没有用的,
        原因参见评论区 稳中求胜 的解释, 当 j 指向 '*' 时,
        dp[i][j]只与dp[i][j-2]有关, 跳过了 dp[i][j-1].
    ```

* 【152】给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积
  * dp分别代表以i结尾的最大值和最小值
  * 以i结尾的最小值有三种情况：本身、前一个最大值乘以本身，前一个最小值诚意本身
  * 以i结尾的最大值有三种情况：本身、前一个最大值乘以本身，前一个最小值诚意本身

    ```
     public int maxProduct(int[] nums) {
        //分别代表以i结尾的最大值和最小值
        int[] max = new int[nums.length], min = new int[nums.length];
        max[0] = nums[0];
        min[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            //以i结尾的最大值有三种情况：本身、前一个最大值乘以本身，前一个最小值诚意本身
            max[i] = Math.max(nums[i], Math.max(max[i-1]*nums[i], min[i-1]*nums[i]));
            //以i结尾的最小值有三种情况：本身、前一个最大值乘以本身，前一个最小值诚意本身
            min[i] = Math.min(nums[i], Math.min(max[i-1]*nums[i], min[i-1]*nums[i]));
            res = Math.max(max[i], res);
        }
        return res;
    }
    ```

* 【91】一条包含字母 A-Z 的消息通过以下映射进行了'A' -> 1、'B' -> 2、'Z' -> 26；要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为"AAJF" ，将消息分组为 (1 1 10 6) ； "KJF" ，将消息分组为 (11 10 6)注意，消息不能分组为 (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。 
  * 以某个数字为结尾，有两种可能：一种连数dp[i-2]，一种非连数dp[i-1],出现连数的可能为two >= 10 && two <= 26
  * 有0种方法可以解码空字符串。dp[0]设置为1仅用于获取dp[2]的结果。如果这让你困惑，那么就这样想吧。您有一个字符串“12”，您可以将其解码为“2”或“12”。现在，如果选择“12”，则dp[2]+=dp[0]。如果dp[0]为0，则不能将“12”作为解码方式。因此dp[0]必须为1。


```
    public int numDecodings(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int[] dp = new int[s.length() + 1];
        dp[0] = 1;
        dp[1] = s.charAt(0) == '0' ? 0 : 1;
        for (int i = 2; i <= s.length(); i++) {
            int two = Integer.valueOf(s.substring(i - 2, i)); //获取前两个数字
            if (s.charAt(i - 1) != '0') {
                dp[i] += dp[i - 1]; // 加上21（2）的情况
            }
            if (two >= 10 && two <= 26) {
                dp[i] += dp[i - 2]; // 加上2（12）的情况
            }
        }
        return dp[s.length()];

```
* 【188】给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 
  *     //dp[i][][]表示第i天的持有的最大利润：
  *    //dp[i][][0]表示不持有 股票，完成了（1，2，3...k）交易的最大利润
  *   //dp[i][][1]持有 股票，完成了（1，2，3...k）交易的最大利润
  *    //dp[i][j][0]表示第i天，交易了j次，不持有股票：昨天也不持有,昨天持有今天卖了
  *    //dp[i][j][1]表示第i天，交易了j次，持有股票：昨天也持有,昨天不持有今天买入了
  *    //最大交易次数不会超过数组的一半的

```
public int maxProfit(int k, int[] prices) {
    if(k <= 0 || prices.length <= 0) {
        return 0;
    }
    k = Math.min(k, prices.length / 2);
    int[][][] dp = new int[prices.length][k + 1][2];
    for (int i = 0; i <= k; i++) {
        dp[0][i][1] = -prices[0];
    }
    for (int i = 1; i < prices.length; i++) {
        for (int j = 1; j <= k; j++) {
            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
        }
    }
    return dp[prices.length - 1][k][0];
}
```

* 【62】一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）问总共有多少条不同的路径？ 
  * 标准的动态规划
  * 注意当i=0或者j=0只有一种路径。

```
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
```

* 【1143】给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0
  * "ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列
  * 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列
  * text1[i] == text2[j],也就是说两个字符串的最后一位相等，那么问题就转化成了字符串text1的[1,j-1]区间和字符串text2的[1,j-1]区间的最长公共子序列长度再加上一，即f[i][j] = f[i - 1][j - 1] + 1
  * 若text1[i] != text2[j]，也就是说两个字符串的最后一位不相等，那么字符串text1的[1,i]区间和字符串text2的[1,j]区间的最长公共子序列长度无法延长，因此f[i][j]就会继承f[i-1][j]与f[i][j-1]中的较大值，即f[i][j] = max(f[i - 1][j],f[i][j - 1])
  * 参考资料：https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-tu-jie-dpz-6mvz/
```
    public int longestCommonSubsequence(String text1, String text2) {
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
```

* 【718】给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 
  * 子序列默认不连续，子数组默认连续
  * dp[i][j]代表以A[i-1]与B[j-1]结尾的公共字串的长度
  * 公共字串必须以A[i-1]，B[j-1]结束，即当A[i-1] == B[j-1]时，dp[i][j] = dp[i-1][j-1] + 1; 
  * 当A[i-1] != B[j-1]时，以A[i-1]和B[j-1]结尾的公共字串长度为0,dp[i][j] = 0。
  * 输出最大的公共字串的长度即为最长重复字串

```
    public int findLength(int[] nums1, int[] nums2) {
        //以dp,i,j结尾的最长重复子数组
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        int max = 0;
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                max = Math.max(dp[i][j], max);
            }
        }
        return max;
    }
```

* 【213】你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的 房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。  给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额
  * 环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题
  * 在不偷窃第一个房子的情况下（即 nums[1:]nums[1:]），最大金额是 p_1p
  * 在不偷窃最后一个房子的情况下（即 nums[:n-1]nums[:n−1]），最大金额是 p_2p 
```
    public int rob(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        return Math.max(singleRob(nums, 0, nums.length - 2),
                singleRob(nums, 1, nums.length - 1));
    }

    public int singleRob(int[] nums, int start, int end) {
        int[] dp = new int[nums.length];
        dp[start] = nums[start];
        for (int i = start + 1; i <= end; i++) {
            dp[i] = Math.max(dp[i - 1], (i - 2 >= 0 ? dp[i - 2] : 0) + nums[i]);
        }
        return dp[end];
    }
```


* 【85】给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积
```
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        //dp[i][j][0]代表以i,j为右下顶点的最大宽度
        //dp[i][j][1]代表以i,j为右下顶点的最大高度
        int[][][] dp = new int[m][n][2];
        int res = 0;
        if (matrix[0][0] == '1') {
            dp[0][0][1] = 1;
            dp[0][0][0] = 1;
            res = 1;
        }
        for (int i = 1; i < m; i++) {
            if (matrix[i][0] == '1') {
                dp[i][0][0] = 1;
                dp[i][0][1] = dp[i - 1][0][1] + 1;
                res = Math.max(res, dp[i][0][1]);
            }
        }
        for (int i = 1; i < n; i++) {
            if (matrix[0][i] == '1') {
                dp[0][i][1] = 1;
                dp[0][i][0] = dp[0][i - 1][0] + 1;
                res = Math.max(res, dp[0][i][0]);
            }
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == '1') {
                    dp[i][j][0] = dp[i][j - 1][0] + 1;
                    dp[i][j][1] = dp[i - 1][j][1] + 1;
                    //计算可能的矩形面积
                    int height = dp[i][j][1];
                    for (int k = 0; k < dp[i][j][0]; k++) {
                        height = Math.min(height, dp[i][j - k][1]);
                        res = Math.max(res, height * (k + 1));
                    }
                }
            }
        }
        return res;
    }
```

* 【123】 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 
  *     //dp[i][][]表示第i天的持有的最大利润：
  *    //dp[i][][0]表示不持有 股票，完成了（1，2，3...k）交易的最大利润
  *   //dp[i][][1]持有 股票，完成了（1，2，3...k）交易的最大利润
  *    //dp[i][j][0]表示第i天，交易了j次，不持有股票：昨天也不持有,昨天持有今天卖了
  *    //dp[i][j][1]表示第i天，交易了j次，持有股票：昨天也持有,昨天不持有今天买入了
  *    //最大交易次数不会超过数组的一半的
 
```
    public int maxProfit(int[] prices) {
        //dp[i][x][0]表示第i天，不持有股票的最大利润
        //dp[i][x][1]表示第i天，持有股票的最大利润
        int[][][] dp = new int[prices.length][3][2];
        for (int k = 0; k <= 2; k++) {
            dp[0][k][1] = -prices[0];
        }
        for (int i = 1; i < prices.length; i++) {
            //还剩下k次机会购买股票
            for (int k = 1; k <= 2; k++) {
                //第i天不持有股票，两种情况
                dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
                //第i天持有股票，两种情况
                dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
            }
        }
        return dp[prices.length - 1][2][0];
    }
```

* 【264】给你一个整数 n ，请你找出并返回第 n 个 丑数，丑数 就是只包含质因数 2、3 和/或 5 的正整数
  * 我们「往后产生的丑数」都是基于「已有丑数」而来（使用「已有丑数」乘上「质因数」22、33、55）。
  * 因此，如果我们所有丑数的有序序列为 a1,a2,a3,...,ana1,a2,a3,...,an 的话，序列中的每一个数都必然能够被以下三个序列（中的至少一个）覆盖：
  * 由丑数 * 22 所得的有序序列：1 * 21∗2、2 * 22∗2、3 * 23∗2、4 * 24∗2、5 * 25∗2、6 * 26∗2、8 * 28∗2 ...
  * 由丑数 * 33 所得的有序序列：1 * 31∗3、2 * 32∗3、3 * 33∗3、4 * 34∗3、5 * 35∗3、6 * 36∗3、8 * 38∗3 ...
  * 由丑数 * 55 所得的有序序列：1 * 51∗5、2 * 52∗5、3 * 53∗5、4 * 54∗5、5 * 55∗5、6 * 56∗5、8 * 58∗5 ...
  *  由于可能不同有序序列之间产生相同丑数，因此只要一样的丑数就跳过（不能使用 else if ）
  * https://leetcode-cn.com/problems/ugly-number-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-3nvs/
```
    public int nthUglyNumber(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for (int p2 = 1, p3 = 1, p5 = 1, i = 2; i <= n; i++) {
            int nextNum = Math.min(dp[p2]*2, Math.min(dp[p3]*3, dp[p5]*5));
            dp[i] = nextNum;
            if (nextNum == dp[p2]*2) {
                p2++;
            }
            if (nextNum == dp[p3]*3) {
                p3++;
            }
            if (nextNum == dp[p5]*5) {
                p5++;
            }
        }
        return dp[n];
    }
```


* 【offer46】给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法
```
    public int translateNum(int num) {
        String str = String.valueOf(num);
        int[] dp = new int[str.length() + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= str.length(); i++) {
            int two = Integer.valueOf(str.substring(i - 2, i));
            dp[i] += dp[i - 1];
            if (two >= 10 && two <= 25) {
                dp[i] += dp[i - 2];
            }
        }
        return dp[str.length()];
    }
```


* 【44】给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。 '?' 可以匹配任何单个字符。'*' 可以匹配任意字符串（包括空字符串）。  
  * 在本题中，模式 pp 中的任意一个字符都是独立的，即不会和前后的字符互相关联，形成一个新的匹配模式。因此，本题的状态转移方程需要考虑的情况会少一些
  * dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹
  * p[j - 1] == s[s - 1] 或 p[j - 1] == '?'，表示当前的字符串是匹配的，dp[i][j] 可以从 dp[i - 1][j - 1] 转移而来
  * 如果 p[j - 1] == '*'，这个位置可以匹配 0 到 若干个字符。
  * 那么 dp[i][j] 可以从 dp[i][j-1] 转移而来（表示当前星号没有匹配字符）
  * 也可以从 dp[i-1][j] 转移而来（表示当前星号匹配了当前的位置的字符）。就是*匹配多次，等于直接忽略了字符串的第i位，因为它可以被*匹配，同时不会“损耗”掉匹配串的*，还能拿给前面继续用
```
    public boolean isMatch(String s, String p) {
        //ddsdfdsf   d*
        //表示 s 的前 i 个字符和 p 的前 j 个字符是否匹
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[0][0] = true;
        for (int i = 1; i <= p.length(); i++) {
            //dp[0][0]:什么都没有,所以为true
            //s为空,与p匹配,所以只要p开始为*才为true, 即*代表可以匹配任意字符，如果为*，说明匹配，如果是连续的*，则表示可以一直匹配，否则需要退出
            //dp[i][0],当然全部为False
            if (p.charAt(i - 1) == '*') {
                dp[0][i] = true;
            } else {
                break;
            }
        }
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                //如果 p[i - 1] == s[j - 1] 或 p[i - 1] == '?'，表示当前的字符串是匹配的，dp[i][j] 可以从 dp[i - 1][j - 1] 转移而来
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                }
            }
        }
        return dp[s.length()][p.length()];
    }
```

* 【offer19】请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。 
```
    /**
     * 以一个例子详解动态规划转移方程：
     * S = abbbbc
     * P = ab*d*c
     * 1. 当 i, j 指向的字符均为字母（或 '.' 可以看成一个特殊的字母）时，
     *    只需判断对应位置的字符即可，
     *    若相等，只需判断 i,j 之前的字符串是否匹配即可，转化为子问题 f[i-1][j-1].
     *    若不等，则当前的 i,j 肯定不能匹配，为 false.
     *
     *        f[i-1][j-1]   i
     *             |        |
     *    S [a  b  b  b  b][c] 
     *
     *    P [a  b  *  d  *][c]
     *                      |
     *                      j
     *
     *
     * 2. 如果当前 j 指向的字符为 '*'，则不妨把类似 'a*', 'b*' 等的当成整体看待。
     *    看下面的例子
     *
     *             i
     *             |
     *    S  a  b [b] b  b  c  
     *
     *    P  a [b  *] d  *  c
     *             |
     *             j
     *
     *    注意到当 'b*' 匹配完 'b' 之后，它仍然可以继续发挥作用。
     *    因此可以只把 i 前移一位，而不丢弃 'b*', 转化为子问题 f[i-1][j]:
     *
     *          i
     *          | <--
     *    S  a [b] b  b  b  c  
     *
     *    P  a [b  *] d  *  c
     *             |
     *             j
     *
     *    另外，也可以选择让 'b*' 不再进行匹配，把 'b*' 丢弃。
     *    转化为子问题 f[i][j-2]:
     *
     *             i
     *             |
     *    S  a  b [b] b  b  c  
     *
     *    P [a] b  *  d  *  c
     *       |
     *       j <--
     *
     * 3. 冗余的状态转移不会影响答案，
     *    因为当 j 指向 'b*' 中的 'b' 时, 这个状态对于答案是没有用的,
     *    原因参见评论区 稳中求胜 的解释, 当 j 指向 '*' 时,
     *    dp[i][j]只与dp[i][j-2]有关, 跳过了 dp[i][j-1].
     */
    public boolean isMatch(String s, String p) {
        //表示 s 的前 i 个字符和 p 的前 j 个字符是否匹
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[0][0] = true;     //dp[0][0]:什么都没有,所以为true
        for (int i = 1; i <= p.length(); i++) {
            //统计边界情况，“”字符串对于表达式a*a*a*a*a*都算匹配成功
            if (p.charAt(i - 1) == '*' && dp[0][i - 2]) {
                dp[0][i] = true;
            }
        }
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    //说明xxxc和xxxxa*匹配时，c和a不相等，a*匹配0位，不发挥作用
                    if (s.charAt(i - 1) != p.charAt(j - 2) && p.charAt(j - 2) != '.') {
                        dp[i][j] = dp[i][j - 2];
                    } else {
                        //有三种情况：
                        dp[i][j] = dp[i - 1][j] || dp[i][j - 1] ||  dp[i][j - 2];
                    }

                }
            }
        }
        return dp[s.length()][p.length()];
    }
```

* 【279】给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少.给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 
  * dp[i]表示最少需要多少个数的平方来表示整数 ii
  * 假设当前枚举到 jj，那么我们还需要取若干数的平方，构成 i-j^2i−j 
```
    public int numSquares(int n) {
        //dp[i]表示最少需要多少个数的平方来表示整数 ii
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = i;
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);
            }
        }
        return dp[n];
    }
```

* 【647】给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串
  * dp[i][j] 表示[i,j]的字符是否为回文子串
  * 注意循环顺序，j要先循环，i后循环，保证dp[i + 1][j - 1]已经算过了
```
    public int countSubstrings(String s) {
        boolean[][] dp = new boolean[s.length()][s.length()];
        int count = 0;
        for (int j = 0; j < s.length(); j++) {
            for (int i = 0; i <= j; i++) {
                if (s.charAt(i) == s.charAt(j) && (j - i < 2 || dp[i + 1][j - 1])) {
                    dp[i][j] = true;
                }
                if (dp[i][j]) {
                    count++;
                }
            }
        }
        return count;
    }
```


* 【887】给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑.已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎。则可以在之后的操作中 重复使用 这枚鸡蛋。 请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？ 
* 有多种方法，都没懂
```
   public int superEggDrop(int K, int N) {
        int[][] dp = new int[K + 1][N + 1];
        for (int m = 1; m <= N; m++) {
            dp[0][m] = 0; // zero egg
            for (int k = 1; k <= K; k++) {
                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
                if (dp[k][m] >= N) {
                    return m;
                }
            }
        }
        return N;
    }
```

* 【343】给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 
  * 令dp[i]表示整数i对应的最大乘积，那么dp[i]的值应是dp[j]*(i-j),j属于[1,i-1]的最大值，同时注意dp[i]对应的值是经过拆分了的，所以还应判断两个数拆分的情况，即j*(i-j)的值，取最大即可
```
   public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = Math.max(dp[i], Math.max(dp[j] * (i - j), j * (i - j)));
            }
        }
        return dp[n];
    }
```
* 【97】交错字符串,给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的,两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串
  * s = s1 + s2 + ... + sn
  * t = t1 + t2 + ... + tm
  * |n - m| <= 1
  * 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
    * 于是可定义 boolean[][] dp ，dp[i][j] 代表 s1 前 i 个字符与 s2 前 j 个字符拼接成 s3 的 i+j 字符，也就是存在目标路径能够到达 i ,j
    * 边界 1：dp[0][0] = true;
    *  边界 2：if i=0 : dp[0]dp[j] = s2[0-j) equals s3[0,j) 遇到 false 后面可以直接省略
    *  边界 3：if j=0 : dp[i]dp[0] = s1[0-i) equals s3[0,i) 遇到 false 后面可以直接省略
    *  其他情况，到达（i，j）可能由（i-1,j）点向下一步，选择 s1[i-1] 到达；也可能由 （i,j-1） 点向右一步，选择 s2[j-1] 到达；

```
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) {
            return false;
        }
        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
        dp[0][0] = true;
        for (int i = 1; i <= s1.length(); i++) {
            if (dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1)) {
                dp[i][0] = true;
            }
        }
        for (int i = 1; i <= s2.length(); i++) {
            if (dp[0][i - 1] && s2.charAt(i - 1) == s3.charAt(i - 1)) {
                dp[0][i] = true;
            }
        }
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                dp[i][j] = (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1))
                        || (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1));
            }
        }
        return dp[s1.length()][s2.length()];
    }
```

* 【offer63】假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 
  * 注意今天持股的方程为dp[i][0] = Math.max(dp[i - 1][0], - prices[i]);dp[i - 1][1]- prices[i]
```
   public int maxProfit(int[] prices) {
        if (prices.length == 0) {
            return 0;
        }
        //dp[i][0]持有股票利润， dp[i][1]不持有股票, 利润
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
```

* 【673】给定一个未排序的整数数组，找到最长递增子序列的个数
  * f以 nums[i] 为结尾的最长上升子序列的长度
  * g为考虑以 nums[i]nums[i] 结尾的最长上升子序列的个数
  * 每个数都能独自一个成为子序列，因此起始必然有 f为考虑以f[i] = g [i]=1
  * 枚举区间 [0, i)[0,i) 的所有数 nums[j]nums[j]，如果满足 nums[j] < nums[i]nums[j]<nums[i]，说明 nums[i]nums[i] 可以接在 nums[j]nums[j] 后面形成上升子序列
  * 满足 f[i] < f[j] + 1f[i]<f[j]+1：说明 f[i]f[i] 会被 f[j] + 1f[j]+1 直接更新，此时同步直接更新 g[i] = g[j]g[i]=g[j] 即可
  * 满足 f[i] = f[j] + 1f[i]=f[j]+1：说明找到了一个新的符合条件的前驱，此时将值继续累加到方案数当中，即有 g[i] += g[j]g[i]+=g[j]
```
    public int findNumberOfLIS(int[] nums) {
        //dpLen表示以i结尾最长子序列的长度，dpCount表示以i结尾最长子序列的方案数
        int[] dpLen = new int[nums.length], dpCount = new int[nums.length];
        int maxLen = 1;
        for (int i = 0; i < nums.length; i++) {
            dpLen[i] = dpCount[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    //有更长的的递增子序列了，需要更新dpLen了，方案数也需要变更了
                    if (dpLen[i] < dpLen[j] + 1) {
                        dpLen[i] = dpLen[j] + 1;
                        dpCount[i] = dpCount[j];//dpLen[j]是更长的子序列，最终的方案数和dpCount[j]一致
                        //和 dpLen[j]的子序列和dpLen[i]加起来的长度没有变化，那么说明j的变化使得dpCount[i]升高
                    } else if (dpLen[i] == dpLen[j] + 1) {
                        dpCount[i] = dpCount[j] + dpCount[i];
                    }
                    maxLen = Math.max(maxLen, dpLen[i]);
                }
            }
        }
        int res = 0;
        //最长子序列方案数统计
        for (int i = 0; i < dpLen.length; i++) {
            if (dpLen[i] == maxLen) {
                res += dpCount[i];
            }
        }
        return res;
    }
```


* 【96】给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数
  * 假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)
```
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[0] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
```

* 【410】给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组.设计一个算法使得这 m 个子数组各自和的最大值最小
  * 我们可以令 f[i][j]f[i][j] 表示将数组的前 ii 个数分割为 jj 段所能得到的最大连续子数组和的最小值
  * 考虑第 jj 段的具体范围，即我们可以枚举 kk，其中前 kk 个数被分割为 j-1j−1 段
  * 第 k+1k+1 到第 ii 个数为第 jj 段
  * 这 jj 段子数组中和的最大值，就等于 f[k][j-1]f[k][j−1] 与 \textit{sub}(k+1, i)sub(k+1,i) 中的较大值，其中 \textit{sub}(i,j)sub(i,j) 表示数组 \textit{nums}nums 中下标落在区间 [i,j][i,j] 内的数的和

```
   public int splitArray(int[] nums, int m) {
        int[][] dp = new int[nums.length + 1][m + 1];
        int[] pre = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            pre[i + 1] = pre[i] + nums[i];
        }
        for (int[] d : dp) {
            Arrays.fill(d, Integer.MAX_VALUE);
        }
        dp[0][0] = 0;
        for (int i = 1; i <= nums.length; i++) {
            //将以i为结尾的数组切分成j份
            for (int j = 1; j <= Math.min(i, m); j++) {
                //枚举最后一份的分界线
                for (int k = 0; k < i; k++) {
                    //取最后一段的值和上一个的最大值比较，取最大的
                    dp[i][j] = Math.min(dp[i][j], Math.max(pre[i] - pre[k], dp[k][j - 1]));
                }
            }
        }
        return dp[nums.length][m];
    }
```

* 【416】给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等
  * 该题目是一个0/1背包问题，每个元素最多选取一次
  * 01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2至Wn，与之相对应的价值为P1,P2至Pn。01背包是背包问题中最简单的问题。01背包的约束条件是给定几种物品，每种物品有且只有一个，并且有权值和体积两个属性。在01背包问题中，因为每种物品只有一个，对于每个物品只需要考虑选与不选两种情况。如果不选择将其放入背包中，则不需要处理。如果选择将其放入背包中，由于不清楚之前放入的物品占据了多大的空间，需要枚举将这个物品放入背包后可能占据背包空间的所有情况
```
  //0/1背包问题：每个元素最多选取一次
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum % 2 != 0) {
            return false;
        }
        sum /= 2;
        int[] dp = new int[sum + 1];//dp[i]表示 和为i 的组合种数
        dp[0] = 1;
        for (int num : nums) {
            for (int i = sum; i >= num; i--) {
                dp[i] += dp[i-num];//最后一个元素是num的组合数量，进行累加
            }
        }
        return dp[sum] != 0;
    }
```



* 【120】给定一个三角形 triangle ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 
  * 自底向上代码更为简洁
  * 上一行的任意位置元素都是下一行dp来的 这样最后顶部的元素就是最小值
```
    public int minimumTotal(List<List<Integer>> triangle) {
        int[][] dp = new int[triangle.size() + 1][triangle.size() + 1];
        for (int i = triangle.size() - 1; i >= 0; i--) {
            List<Integer> cur = triangle.get(i);
            for (int j = 0; j < cur.size(); j++) {
                dp[i][j] = cur.get(j) + Math.min(dp[i + 1][j], dp[i + 1][j + 1]);
            }
        }
        return dp[0][0];
    }
```


* 【offer10-ii】青蛙跳台阶问题，一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1
```
    public int numWays(int n) {
        if (n <= 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = (dp[i - 1] % 1000000007 + dp[i - 2] % 1000000007) % 1000000007;
        }
        return dp[n];
    }
```

* 【583】给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符
```
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i < dp.length; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i < dp[0].length; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
```


* 【1035】在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。
 * 如果两个长度为0的整数串连线，最大值肯定为0
 * 在合法的解答中，不可能出现A[x],B[y]都参与连线的情况。如果他们两个点都被别的点连线了，那么一定会出现直线相交。因为与B[y]连线的点一定小于A[x]，与A[x]连线的点的位置也一定小于B[y]
 * 如果A[x]==B[y]，那么f(x,y)=f(x-1,y-1)+1;其他没有比这个情况更大的解。否则A[x]和B[y]一定只有一个点参与连线（看情况1中的说明，否则会有相交）
```
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[nums1.length][nums2.length];
    }

```


* 【474】给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集
  * 01背包问题, 物品的大小就是str中0 1的数量, 所以背包有两个维度
  * 物品的价值就是子集数量的多少
  * dp[i][j] 含义: 最多有i个0和j个1的strs的最⼤⼦集的⼤⼩为dp[i][j]
  * 状态转移方程: dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)  -> 物品价值就是+1个子集
  * 先遍历物品, 再遍历背包容量
  * 状态方程为 dp[i][j] = dp[i-1][j-1] + 1;
  * 如果采用从后向前填表，那么我们的dp[i-1][j-1]应该是上一轮计算的结果，因为这一轮我们还没有更新过这个值
  * 但如果采用从前往后填表，那么我们的dp[i-1][j-1]应该是这一轮计算的结果，因为这一轮我们已经更新过这个值
  * 但是我们这个二维dp数组是最初的三维dp数组的一个优化，因此，在状态迁移时，我们需要的是上一轮计算的dp[i-1][j-1]
  * 这就是为什么我们要从后往前填表了，主要是保留上一轮计算的结果不被覆盖
```
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for (String str : strs) {
            int zeros = 0, ones = 0;
            for (char c : str.toCharArray()) {
                if (c == '1') {
                    ones++;
                } else {
                    zeros++;
                }
            }
            for (int i = m; i >= zeros; i--) {
                for (int j = n; j >= ones; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }
        return dp[m][n];
    }
```


* 【494】给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
  * 可转化为01背包问题
  * 因为每个物品（题目中的1）只用一次！
  * dp[j] 表示：填满j（包括j）这么大容积的包，有dp[i]种方法
  * 不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。
  * 那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]] 种方法。
  * 举一个例子,nums[i] = 2： dp[3]，填满背包容量为3的话，有dp[3]种方法。
  * 那么只需要搞到一个2（nums[i]），有dp[3]方法可以凑齐容量为3的背包，相应的就有多少种方法可以凑齐容量为5的背包。
  * 那么需要把 这些方法累加起来就可以了，dp[j] += dp[j - nums[i]]
  * 所以求组合类问题的公式，都是类似这种dp[j] += dp[j - nums[i]]
  * 对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序
```
 /**
     * 494
     * 输入: nums: [1, 1, 1, 1, 1], S: 3
     * 输出: 5
     * 解释:
     * -1+1+1+1+1 = 3
     * +1-1+1+1+1 = 3
     * +1+1-1+1+1 = 3
     * +1+1+1-1+1 = 3
     * +1+1+1+1-1 = 3
     * 
     * sum(P) 前面符号为+的集合；sum(N) 前面符号为减号的集合
     * 所以题目可以转化为
     * sum(P) - sum(N) = target 
     * => sum(nums) + sum(P) - sum(N) = target + sum(nums)
     * => 2 * sum(P) = target + sum(nums) 
     * => sum(P) = (target + sum(nums)) / 2
     * 因此题目转化为01背包，也就是能组合成容量为sum(P)的方式有多少种
     */
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum < target || (sum + target) % 2 == 1 || sum + target < 0) {
            return 0;
        }
        int w = (sum + target) / 2;
        int[] dp = new int[w + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int i = w; i >= num; i--) {
                dp[i] += dp[i - num];
            }
        }
        return dp[w];
    }
```


* 【1049】有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
  * 转换成01背包问题，求两堆石头的最小差值。由于石头总和为sum.则问题转换成了
  * 背包最多装sum / 2的石头,stones数组里有一大堆石头。求如何装能装下最多重量石头 
```
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone : stones) {
            sum += stone;
        }
        int w = sum / 2;
        int[] dp = new int[w + 1];
        for (int stone : stones) {
            for (int i = w; i >= stone; i--) {
                dp[i] = Math.max(dp[i], dp[i - stone] + stone);
            }
        }
        return sum - 2 * dp[w];
    }
```


* 【115】 不同的子序列,给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。
  * 初始状态为1，由于空字符串是任何字符串的子序列，所以初始状态为1，由于非空字符串不是空字符串的子序列所以初始为0
  * 分为两种情况，i参与和i不参与，
    ij参与，如果i和j相等，则个数由i-1和j-1决定
```


   public int numDistinct(String s, String t) {
        if (s.length() < t.length()) {
            return 0;
        }
        //以i,j结尾的字符的子序列的个数
        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 0; i <= s.length(); i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= t.length(); j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[s.length()][t.length()];
    }
```



* 【377】组合总和 Ⅳ，给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。题目数据保证答案符合 32 位整数范围。
  * 爬楼梯变种。    
```
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int num : nums) {
                if (i >= num) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }

```


* 【offer47】 礼物的最大价值。在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
```
    //优雅的做法
    public int maxValue(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int[][] dp = new int[row + 1][col + 1];
        for(int i = 1; i <= row; i++) {
            for(int j = 1; j <= col; j++) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1];
            }
        }
        return dp[row][col];
    }

    //比较挫的做法
    public int maxValue(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < grid.length; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int i = 1; i < grid[0].length; i++) {
            dp[0][i] = dp[0][i - 1] + grid[0][i];
        }
        for (int i = 1; i < grid.length; i++) {
            for (int j = 1; j < grid[0].length; j++) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[grid.length - 1][grid[0].length - 1];
    }

```

* 【879】盈利计划，集团里有 n 名员工，他们可以完成各种各样的工作创造利润。

第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。

工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。

有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。
  * 这道题很难，参考解答https://leetcode-cn.com/problems/profitable-schemes/solution/ying-li-ji-hua-by-leetcode-solution-3t8o/
```
   public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        //dp[i][j][k]表示前i个工作，使用了j个员工，满足至少k的利润的方案总数
        int[][][] dp = new int[group.length + 1][n + 1][minProfit + 1];
        dp[0][0][0] = 1;
        int MOD = (int) 1e9 + 7;
        //如果i不能开展工作，dp[i][j][k] = dp[i - 1][j][k]
        //如果i能够开展工作，dp[i][j][k] = 前(i-1)的工作满足了k利润的方案数 + dp[i-1][j−group[i]][max(0,k−profit[i])]
        for (int i = 1; i <= group.length; i++) {
            int earn = profit[i - 1], member = group[i - 1];
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k <= minProfit; k++) {
                    if (member > j) { //无法开展工作
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - member][Math.max(0, k - earn)]) % MOD;
                    }
                }
            }
        }
        int ans = 0;
        //遍历工人
        for (int i = 0; i <= n; i++) {
            ans = (ans +  dp[group.length][i][minProfit]) % MOD;
        }
        return ans;
    }
```
【1312】. 让字符串成为回文串的最少插入次数。给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 s 成为回文串的 最少操作次数 。
「回文串」是正读和反读都相同的字符串。
  * 我们用 dp[i][j] 表示对于字符串 s 的子串 s[i:j]（这里的下标从 0 开始，并且 s[i:j] 包含 s 中的第 i 和第 j 个字符），最少添加的字符数量，使得 s[i:j] 变为回文串
```
    public int minInsertions(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                dp[i][j] = s.charAt(i) == s.charAt(j) ? dp[i + 1][j - 1] : Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
            }
        }
        return dp[0][n - 1];
    }
```
* 【931】下降路径最小和
给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。

下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。
  *  可以自上而下，也可以自下而上

```
    public int minFallingPathSum(int[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[][] dp = new int[n + 1][m + 1];
        int ans = Integer.MAX_VALUE;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                if (j == 0) {
                    dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + matrix[i][j];
                } else if (j == m - 1) {
                    dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j - 1]) + matrix[i][j];
                } else {
                    dp[i][j] = Math.min(dp[i + 1][j + 1], Math.min(dp[i + 1][j], dp[i + 1][j - 1])) + matrix[i][j];
                }
                if (i == 0) {
                    ans = Math.min(ans, dp[i][j]);
                }
            }
        }
        return ans;
    }
```

* 【714】 买卖股票的最佳时机含手续费
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
  * 常规

 
```
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];//0，持有，1，不持有
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return dp[prices.length - 1][1];
    }
```


* 【337】打家劫舍 III.在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。  
  * 二叉树版的动态规划
  * 可以使用朴素dfs，但是会超时。 
```
   public int rob(TreeNode root) {
        int[] ans = helper(root);
        return Math.max(ans[0], ans[1]);
    }

    private int[] helper(TreeNode root) {
        if (root == null) {
            return new int[2];
        }
        //dp[0]表示当前偷，dp[1]表示当前不偷
        int[] dp = new int[2];
        int[] dpLeft = helper(root.left);
        int[] dpRight = helper(root.right);
        dp[0] = root.val + dpLeft[1] + dpRight[1]; //当前偷，孩子节点不能偷
        dp[1] = Math.max(dpLeft[1], dpLeft[0]) + Math.max(dpRight[1], dpRight[0]);//当前不偷，孩子节点可以选择偷，也可以选择不偷取大的
        return dp;
    }


    //方法2，递归 ，会超时

     if(root == null) return 0;
        int val = 0;
        if(root.left != null) val += rob(root.left.left) + rob(root.left.right);
        if(root.right != null) val += rob(root.right.left) + rob(root.right.right);
        return Math.max(rob(root.left) + rob(root.right),val + root.val);
        */
```


* 【343】 整数拆分
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
  * 将i拆分成j和i-j的和，且i- j不再拆分成多个正整数，此时的乘积是j×(i一j);
  * 将i拆分成j和i-j的和，且i- j继续拆分成多个正整数，此时的乘积是j x dp[i 一j]。

```
    public int cuttingRope(int n) {
        int[] dp = new int[n + 1];//长度为i的最大的乘积
        dp[1] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < n; j++) {
                dp[i] = Math.max(Math.max(dp[j] * (i - j), j * (i - j)), dp[i]);
            }
        }
        return dp[n];
    }
```

* 【63】. 不同路径 II
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
  * 就是简单dp
  * 可有考虑原地修改数组

```
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid[0][0] == 1) {
            return 0;
        }
        int[][] dp = new int[obstacleGrid.length][obstacleGrid[0].length];
        dp[0][0] = 1;
        for (int i = 1; i < obstacleGrid.length; i++) {
            if (obstacleGrid[i][0] == 1) {
                dp[i][0] = 0;
            } else {
                dp[i][0] = dp[i - 1][0];
            }
        }
        for (int i = 1; i < obstacleGrid[0].length; i++) {
            if (obstacleGrid[0][i] == 1) {
                dp[0][i] = 0;
            } else {
                dp[0][i] = dp[0][i - 1];
            }
        }
        for (int i = 1; i < obstacleGrid.length; i++) {
            for (int j = 1; j < obstacleGrid[0].length; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[obstacleGrid.length - 1][obstacleGrid[0].length - 1];
    }
```


* 【1139】. 最大的以 1 为边界的正方形
给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0
```
class Solution {
    public int largest1BorderedSquare(int[][] grid) {
        int[][][] dp = new int[grid.length + 1][grid[0].length + 1][2];//以i,j结尾的横向和纵向连续1的个数
        int ans = 0;
        for (int i = 1; i <= grid.length; i++) {
            for (int j = 1; j <= grid[0].length; j++) {
                if (grid[i - 1][j - 1] == 1) {
                    dp[i][j][0] = dp[i][j - 1][0] + 1; //纵向
                    dp[i][j][1] = dp[i - 1][j][1] + 1; //横向
                    for (int k = Math.min(dp[i][j][0], dp[i][j][1]); k >= 1; k--) {
                        if (dp[i - k + 1][j][0] >= k && dp[i][j - k + 1][1] >= k) {
                            ans = Math.max(ans, k * k);
                        }
                    }
                }
            }
        }
        return ans;
    }
}
```

* 【offer10-1】剑指 Offer 10- I. 斐波那契数列
```
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }
        int mod = 1000000007;
        int n1 = 1, n2 = 1;
        for (int i = 3; i <= n; i++) {
            int temp = (n1 % mod + n2 % mod) % mod;
            n1 = n2;
            n2 = temp;
        }
        return n2;
    }
```