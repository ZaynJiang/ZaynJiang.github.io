## 1. 动态规划
## 2. 经典题目
* 【121】给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 
  *  dp表示第i天持有和不持有的最大利润
  *  今日持股：昨天不持股今天持股，昨天持股今天不变
  *  今日不持股：昨天不持股今天不持股，昨天持股今天抛
```
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        //第n天的最大利润
        int[][] dp = new int[prices.length][2];
        //dp[0][0]，第0天持股
        dp[0][0] = - prices[0];
        //dp[0][1]，第0天不持股
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            //今日持股：昨天不持股今天持股，昨天持股今天不变
            dp[i][0] = Math.max(-prices[i], dp[i-1][0]);
            //今日不持股：昨天不持股今天不持股，昨天持股今天抛
            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);
        }
        return dp[prices.length-1][1];
    }

    //空间优化版
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        //第n天的最大利润
        //dp[0][0]，第0天持股
        int preChi = -prices[0], preBu = 0;
        for (int i = 1; i < prices.length; i++) {
            //今日持股：昨天不持股今天持股，昨天持股今天不变
            preChi= Math.max(-prices[i], preChi);
            //今日不持股：昨天不持股今天不持股，昨天持股今天抛
            preBu = Math.max(preChi + prices[i], preBu);
        }
        return preBu;
    }    
```  

* 【300】给你一个整数数组 nums ，找到其中最长严格递增子序列的长度
  * 方法一：动态规划
  * 2层循环，以i结尾的严格递增长度
  * 返回dp的最大值即可
  * 还可以使用2分法和贪心策略优化
  * 方法二：二分法+贪心
  * 维护一个长度数组：第一位代表长度为1的结尾的数，第二位代表长度2为结尾的数，以此类推
  * 线性遍历原数组，取到元素后，二分查找长度数组中比它大的元素覆盖。

```
    // 方法1动态编程
    public int lengthOfLIS(int[] nums) {
        //最长
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int len = 1;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= i; j++) {
                dp[i] = Math.max(dp[i], nums[i] > nums[j] ? dp[j] + 1 : 1);
            }
            len = Math.max(len, dp[i]);
        }
        return len;
    }
    
    //二分法优化求解
    public int lengthOfLIS(int[] nums) {
    //最长
    int[] tails = new int[nums.length];
    int len = 0;
    for (int num : nums) {
        int i = 0, j = len;
        while (i < j) {
            int mid = (i + j) >> 1;
            if (tails[mid] < num) {
                i = mid+1;
            } else {
                j = mid;
            }
        }
        tails[i] = num;
        if (i == len) {
            len++;
        }
    }
    return len;
}
```

* 【32】给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度
  *  动态规划
  *  dp代表第i个字符，以i字符结尾的最长有效括号数
  * 有三种情况 xx|xxxxxx)
  * 有三种情况 xx|xxxxxx)
  * 第一种情况 xx|xxxxx()  //dp[i-2] + 2;
  * 有二种情况 x)|(xxxx))  //(i - dp[i-1] -2)位字符位"）"和（i）位字符")"不构成有效括号为0
  * 有三种情况 x(|(xxxx))  //(i - dp[i-1] -2)位字符位"("和（i）位字符")"构成有效括号dp[i - dp[i-1] -2] + dp[i-1] + 2
```
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length() + 1];
        int max = 0;
        for (int i = 2; i <= s.length(); i++) {
            char cur = s.charAt(i-1);
            if (cur == ')') {
                char pre = s.charAt(i - 2);
                if (pre == ')') {
                    //x)|(xxxx))与最后字符不构成有效括号:dp[i]=0；
                    //()(|(xxxx))与最后字符构成有效括号:dp[i - dp[i-1] -2](前面有效数) + dp[i-1] + 2
                    dp[i] = i - dp[i-1] -2 >= 0 && s.charAt(i-dp[i-1]-2) == '(' ? dp[i - dp[i-1] -2] + dp[i-1] + 2 : 0;
                } else {
                    dp[i] = dp[i-2] + 2;
                }
                max = Math.max(max, dp[i]);
            }
        }
        return max;
    }

```


* 【221】在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积
* dp[i][j] 代表第i,j结尾的方块的最大正方形边长大小
* dp[i][j] 如果当前为1，则寻找左上斜上最小者最为边长+1
```
public int maximalSquare(char[][] matrix) {
    //dp[][] 代表第i,j结尾的方块的最大正方形数.
    //dp[i][0] dp[0][i] 都为0，因为不会构成正方形
    int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];
    int maxSide = 0;
    for (int i = 1; i <= matrix.length; i++) {
        for (int j = 1; j <= matrix[0].length; j++) {
            if (matrix[i - 1][j - 1] == '1') {
                dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;
                maxSide = Math.max(dp[i][j], maxSide);
            }
        }
    }
    return maxSide * maxSide;
}
```

* 【322】 零钱兑换，计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1
  *  dp[i] = Math.min(dp[i-coin]+1, dp[i]);
  *  注意初始条件Arrays.fill(dp, Integer.MAX_VALUE);
  *  递推公式的特性，dp[i]必须初始化为一个最大的数，否则就会在min(dp[i - coin] + 1, dp[i])比较的过程中被初始值覆盖
  *  凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0
  *  dp[i-coin]为Integer.MAX_VALUE时需要掠过，因为没有意义了
```
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (i - coin >= 0 && dp[i-coin] != Integer.MAX_VALUE) {
                    dp[i] =  Math.min(dp[i-coin]+1, dp[i]);
                }
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
```

* 【53】 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和
  * 动态规划
  * dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
  * 注意不是根据nums[i]大于0来判断，因为nums[i]小于0也能找到以它为结尾的连续最大值。
```
   public int maxSubArray(int[] nums) {
        //以i为结尾的最大连续序列的和
        int[] dp = new int[nums.length];
        int max = nums[0];
        dp[0] = max;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
            max = Math.max(dp[i], max);
        }
        return max;
    }
```

* 【122】给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格.设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 
  * 动态规划
  * 动态转移方程，第i天持有和第i天不持有的状态
```
    public int maxProfit(int[] prices) {
        // 表示第n天的利润，0是持有股票，1是不持有股票
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            //第i天持有股票，有两种来源：第i-1不持有第i天持有；第i-1持有，i天啥都不做也持有
            dp[i][0] = Math.max(dp[i-1][1] - prices[i], dp[i-1][0]);
            //第i天持不持有股票，有两种来源：第i-1不持有第i天不持有；第i-1持有，i天卖出
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
```  

* 【512】给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 
  * 注意改题目和爬楼梯不一样，这个是组合问题，爬楼梯是排列问题
  * 先走2步再走1步和先走1步再走2步不同，先拿2块再拿1块和先拿1块再拿2块相同
  * 遍历顺序不一样
  * 组合问题其实是在每一次for coin in coins循环中就把coin的可使用次数规定好了。不允许在后面的硬币层次使用之前的硬币。 这就像排列中2,2,1; 2,1,2是两种情况，但是组合问题规定好了一种书写顺序，比如大的写在前面那就只有2,2,1这一种情况了

```
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = 1; i <= amount; i++) {
                if (i - coin >= 0) {
                    //最后一枚是每一种硬币的组合数
                    dp[i] += dp[i - coin];
                }
            }
        }
        return dp[amount];
    }
```

* 【198】给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额
  * 动态规划
  * 标准转移方程dp[i][0] = dp[i - 1][1] + nums[i];dp[i][1] = Math.max(dp[i - 1][1], dp[i-1][0]);
  * 可以空间优化
```
    public int rob(int[] nums) {
        //第i个房子持有的最大金额：0是偷，1是不偷
        int[][] dp = new int[nums.length][2];
        dp[0][0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            //第i个房子偷钱: i-1不偷 + i偷
            dp[i][0] = dp[i - 1][1] + nums[i];
            // 第i个房子不偷
            dp[i][1] = Math.max(dp[i - 1][1], dp[i-1][0]);
        }
        return Math.max(dp[nums.length-1][0], dp[nums.length-1][1]);
    }
    public int rob(int[] nums) {
        if (nums.length == 1) {
            return nums[0];
        }
        //f(x) = max(f(x), f(x-2)+nums[x]);
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0],nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]);
        }
        return dp[nums.length-1];
    }
```