## 1. 动态规划
## 2. 经典题目
* 【121】给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 
  *  dp表示第i天持有和不持有的最大利润
  *  今日持股：昨天不持股今天持股，昨天持股今天不变
  *  今日不持股：昨天不持股今天不持股，昨天持股今天抛
```
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        //第n天的最大利润
        int[][] dp = new int[prices.length][2];
        //dp[0][0]，第0天持股
        dp[0][0] = - prices[0];
        //dp[0][1]，第0天不持股
        dp[0][1] = 0;
        for (int i = 1; i < prices.length; i++) {
            //今日持股：昨天不持股今天持股，昨天持股今天不变
            dp[i][0] = Math.max(-prices[i], dp[i-1][0]);
            //今日不持股：昨天不持股今天不持股，昨天持股今天抛
            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);
        }
        return dp[prices.length-1][1];
    }

    //空间优化版
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }
        //第n天的最大利润
        //dp[0][0]，第0天持股
        int preChi = -prices[0], preBu = 0;
        for (int i = 1; i < prices.length; i++) {
            //今日持股：昨天不持股今天持股，昨天持股今天不变
            preChi= Math.max(-prices[i], preChi);
            //今日不持股：昨天不持股今天不持股，昨天持股今天抛
            preBu = Math.max(preChi + prices[i], preBu);
        }
        return preBu;
    }    
```  

* 【300】给你一个整数数组 nums ，找到其中最长严格递增子序列的长度
  * 方法一：动态规划
  * 2层循环，以i结尾的严格递增长度
  * 返回dp的最大值即可
  * 还可以使用2分法和贪心策略优化
  * 方法二：二分法+贪心
  * 维护一个长度数组：第一位代表长度为1的结尾的数，第二位代表长度2为结尾的数，以此类推
  * 线性遍历原数组，取到元素后，二分查找长度数组中比它大的元素覆盖。

```
    // 方法1动态编程
    public int lengthOfLIS(int[] nums) {
        //最长
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int len = 1;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= i; j++) {
                dp[i] = Math.max(dp[i], nums[i] > nums[j] ? dp[j] + 1 : 1);
            }
            len = Math.max(len, dp[i]);
        }
        return len;
    }
    
    //二分法优化求解
    public int lengthOfLIS(int[] nums) {
    //最长
    int[] tails = new int[nums.length];
    int len = 0;
    for (int num : nums) {
        int i = 0, j = len;
        while (i < j) {
            int mid = (i + j) >> 1;
            if (tails[mid] < num) {
                i = mid+1;
            } else {
                j = mid;
            }
        }
        tails[i] = num;
        if (i == len) {
            len++;
        }
    }
    return len;
}
```