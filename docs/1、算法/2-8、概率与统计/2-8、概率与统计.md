## 1. 概念

## 2. 经典题目
* 【470】已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数
  * 此题基于两个结论
  * (rand_X() - 1) × Y + rand_Y() ==> 可以等概率的生成[1, X * Y]范围的随机数
  * 如x为1-Y的随机数，y为z的倍数，x%z+1;就是1-到z的随机数了
  * 本题目初始为7，那么可以找到1-49的概率，进而通过第二个结论算出1-40取模+1的概率
```
    public int rand10() {
        //有这么两个结论：
        // 1. (rand_X() - 1) × Y + rand_Y() ==> 可以等概率的生成[1, X * Y]范围的随机数
        // 2. 如x为1-Y的随机数，y为z的倍数，x%z+1;就是1-到z的随机数了。
        //7-1 * 7 + 7;
        while (true) {
            int x = rand7(), y = rand7();
            //套用公式，1-49的概率
            int z = (x - 1) * 7 + y;
            if (z <= 40) {
                //1-10的概率生成
                return z % 10 + 1;
            }
            // 1-9的概率
            x = z - 40;
            //1-7的概率
            y = rand7();
            //套用公式，1-63的概率
            z = (x - 1) * 7 + y;
            if (z <= 60) {
                return z % 10 + 1;
            }
            // 1-3的概率
            x = z - 60;
            //1-7的概率
            y = rand7();
            //套用公式，1-21的概率
            z = (x - 1) * 7 + y;
            if (z <= 20) {
                return z % 10 + 1;
            }
        }
    }
```

* 【528】给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重，请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w)
  * 先求出每个下标的前缀和
  * 求出最后的前缀和范围内的随机数
  * 遍历前缀和，看随机数落在哪一个下标就是题目要求的随机数。
```
   public pickIndex(int[] w) {
        random = new Random();
        pre = new int[w.length];
        for (int i = 0; i < pre.length; i++) {
            pre[i] = i > 0 ? pre[i - 1] + w[i] : w[i];
        }
    }
    int[] pre;
    Random random;
    public int pickIndex() {
        int hit = random.nextInt(pre[pre.length - 1])+ 1;
        for (int i = 0; i < pre.length; i++) {
            //命中
            if (pre[i] < hit) {
                return i;
            }
        }
        return 0;
    }
```

* 【398】给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中
  * 蓄水池经典问题
  * 对第i个元素，以1/i的概率更新取值，以1 - 1/i的概率保留原值,则n个元素最终留下的概率都是1/n
  * 数据1被留下：（1/2）(2/3) = 1/3
  * 数据2被留下概率：（1/2）(2/3) = 1/3
  * 数据3被留下概率：1/3

```
   public Solution(int[] nums) {
        random = new Random();
        this.nums = nums;
    }
    int[] nums;
    Random random;
    public int pick(int target) {
        int count = 0, res = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target && random.nextInt(++count) == 0) {
                res = i;
            }
        }
        return res;
    }
```