## 1. 概念

## 1. 广度优先遍历


* 【103】给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 
  * 使用linkedlist
  * 使用队列
  * 广度优先遍历
  * 奇数偶数addlast、addFirst
```
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            LinkedList list = new LinkedList();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                if (res.size() % 2 == 0) {
                    list.addLast(node.val);
                } else {
                    list.addFirst(node.val);
                }
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            res.add(list);
        }
        return res;
    }
```

* 【199】 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。  
  * 层序遍历,广度优先遍历
  * 双端队列，取队尾peekLast
  * 这个也可以用dfs，也很简单
```
    //bfs
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            res.add(deque.peekLast().val);
            int size = deque.size();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return res;
    }

    //dfs
    List<Integer> res = new ArrayList<>();

    public List<Integer> rightSideView(TreeNode root) {
         // 从根节点开始访问，根节点深度是0
        dfs(root, 0); 
        return res;
    }

    private void dfs(TreeNode root, int depth) {
        if (root == null) {
            return;
        }
        // 先访问 当前节点，再递归地访问 右子树 和 左子树。
        if (depth == res.size()) {   
            // 如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。
            res.add(root.val);
        }
        depth++;
        dfs(root.right, depth);
        dfs(root.left, depth);
    }
```

* 【105】从前序与中序遍历序列构造二叉树
  * 使用Map保存前序遍历得值和下标映射关系
  * 利用中序遍历找到left的长度
  * 通过前序遍历的root+left找到下一个子树的位置
  * |root|--------------
  * ---------|root|----
  *         
  *         
```
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; i++) {
            inMap.put(inorder[i], i);
        }
        return buildTree(preorder, 0, preorder.length - 1, 0);
    }
    Map<Integer, Integer> inMap = new HashMap<>();
    private TreeNode buildTree(int[] preorder, int preLeft, int preRight, int inLeft) {
        if (preLeft > preRight) {
            return null;
        }
        int rootVal = preorder[preLeft], inRootIdx = inMap.get(rootVal);
        TreeNode rootNode = new TreeNode(rootVal);
        rootNode.left = buildTree(preorder, preLeft + 1, preLeft + inRootIdx - inLeft, inLeft);
        rootNode.right = buildTree(preorder, preLeft + inRootIdx - inLeft + 1, preRight, inRootIdx + 1);
        return rootNode;
    }
```
* 【98】给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 
  * 此题需要非常注意，二叉树时左子树的所有节点比它的根节点小，而不是左孩子节点和右孩子节点，所以需要不断的传入最小值或最大值
  * 或者全局记录一个中序遍历值，不断比较中序遍历的结果即可。

```
    //模拟法
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    public boolean isValidBST(TreeNode root, long lower, long upper) {
        if (root == null) {
            return true;
        }
        if (root.val <= lower) {
            return false;
        }
        if (root.val >= upper) {
            return false;
        }
        return isValidBST(root.left, lower, root.val) && isValidBST(root.right, root.val, upper);
    }
    //中序遍历法

       //中序遍历，增序， 优化
    Integer pre = null;
    public boolean isValidBST3(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST3(root.left) || (pre != null && pre >= root.val)) {
            return false;
        }
        pre = root.val;
        return isValidBST3(root.right);
    }
```

【102】给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点
* 标准的层序遍历
```
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.push(root);
        while (!deque.isEmpty()) {
            List<Integer> list = new LinkedList<>();
            int size = deque.size();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                list.add(node.val);
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            res.add(list);
        }
        return res;
    }
```

* 【101】给定一个二叉树，检查它是否是镜像对称的
  * 递归，从上到下，检查左侧的左侧和右侧的右侧，以及左侧的右侧及右侧的左侧
  * 迭代，左侧的左侧和右侧的右侧，以及左侧的右侧及右侧的左侧依次放到栈里，校验即可
```
    public boolean isSymmetric(TreeNode root) {
        return isSymmetric(root.left, root.right);
    }

    //递归
    public boolean isSymmetric(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);
    }

    //迭代
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        Deque<TreeNode> deque  = new LinkedList<>();
        deque.push(root);
        deque.push(root);
        while (!deque.isEmpty()) {
            TreeNode left = deque.pop(), right = deque.pop();
            if (left == null && right == null) {
                continue;
            }
            if (left == null || right == null) {
                return false;
            }
            if (left.val != right.val) {
                return false;
            }
            deque.push(left.left);
            deque.push(right.right);
            deque.push(left.right);
            deque.push(right.left);
        }
        return true;
    }
```

* 【129】给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。计算从根节点到叶节点生成的 所有数字之和 
  * 上一层的值乘以10加上当前值
  * 如果为空，说明该路径无效，为0
  * 如果不为空且是是叶子节点，就直接返回last
  * 不是叶子节点的话，就发散，计算分支的和
```
    private int getSumNumbers(TreeNode root, int last) {
        if (root == null) {
            return 0;
        }
        last = last*10 + root.val;
        if (root.left == null && root.right == null) {
            return last;
        }
        return getSumNumbers(root.left, last) + getSumNumbers(root.right, last);
    }
```


* 【662】给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空
  * 层序遍历
  * 每个节点保存一个序号，可以观察完全二叉树左节点为上一个序号的两倍，右节点的序号为上一序号的两倍加1
  * 使用双端队列，取每一层前端和后端之间的差值，取最大值
```
   public int widthOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new ArrayDeque<>();
        int max = 1;
        root.val = 1;
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            max = Math.max(max, deque.peekLast().val - deque.peekFirst().val + 1);
            while (size-- > 0) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    node.left.val = 2 * node.val;
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    node.right.val = 2 * node.val + 1;
                    deque.offer(node.right);
                }
            }
        }
        return max;
    }
```  

* 【440】给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字
  * 前序遍历
  * 注意数字可能越界
  * 寻找一个节点的满足条件的数量，如果小于剩余的k个，直接右
  * 最终不断的右移获取结果。注意k > 0
```
    public int findKthNumber(int n, int k) {
        k--;
        long cur = 1;
        while (k > 0) {
            //获取cur节点下的满足小于n的节点数量
            long nums = getNumsByRoot(n, cur);
            //cur小于n节点的数量小于k，说明这个cur分支的结果数量不够k个，需要右移动
            if (nums > k) {
                cur *= 10;
                k--;
                //cur小于n节点的数量大于k，说明结果就在cur下
            } else {
                cur++;
                k -= nums;
            }
        }
        return (int) cur;
    }
    /**
     * 返回某一个cur根节点下所有小于等于目标值n的数量
     * @param cur， 当前根节点
     * @param n， 目标值
     * @return
     */
    public long getNumsByRoot(long n, long cur) {
        long nums = 0, nextCur = cur + 1;
        while (cur <= n) {
            nums += Math.min(nextCur - cur, n - cur + 1);
            cur *= 10;
            nextCur *= 10;
        }
        return nums;
    }
```

* 【94】 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 
```
    public List<Integer> inorderTraversal(TreeNode root) {
        dfs(root);
        return res;
    }
    public void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        res.add(root.val);
        dfs(root.right);
    }
    List<Integer> res = new ArrayList<Integer>();
```

* 【297】请设计一个算法来实现二叉树的序列化与反序列化
```
    public String serialize(TreeNode root) {
        dfs(root);
        return str.stream().collect(Collectors.joining(":"));
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            str.add("null");
            return;
        }
        str.add(String.valueOf(root.val));
        dfs(root.left);
        dfs(root.right);
    }
    List<String> str = new ArrayList<>();


    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Deque<String> deque = new LinkedList<>(Arrays.asList(data.split(":")));
        return buildTree(deque);
    }
    private TreeNode buildTree(Deque<String> deque) {
        if (deque.isEmpty()) {
            return null;
        }
        String str = deque.pop();
        if ("null".equals(str)) {
            return null;
        } else {
            TreeNode root = new TreeNode(Integer.valueOf(str));
            root.left = buildTree(deque);
            root.right = buildTree(deque);
            return root;
        }
    }
```

* 【114】给你二叉树的根结点 root ，请你将它展开为一个单链表
```
    TreeNode pre = null;
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }
        if (pre != null) {
            pre.right = root;
        }
        //这里必须要将right和left变量先提取出来
        //因为遍历下一层的时候，pre的right会变化，flatten需要使用之前的right
        TreeNode left = root.left, right = root.right;
        root.left = null;
        pre = root;
        flatten(left);
        flatten(right);
    }
```


* 【110】给定一个二叉树，判断它是否是高度平衡的二叉树。 
```
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return Math.abs(getDeep(root.left) - getDeep(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }

    public int getDeep(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return Math.max(getDeep(root.left), getDeep(root.right)) +1;
    }
```



* 【offer54】给定一棵二叉搜索树，请找出其中第k大的节点
  * 第k大，是找倒数第k大的
```
    public int kthLargest(TreeNode root, int k) {
        dfs(root, k);
        return res;
    }
    private void dfs(TreeNode root, int k) {
        if (root == null) {
            return;
        }
        dfs(root.right, k);
        if (++count == k) {
            res = root.val;
        }
        dfs(root.left, k);
    }
    int res = Integer.MIN_VALUE;
    int count = 0;
```

* 【230】给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）
```
    public int kthSmallest(TreeNode root, int k) {
        dfs(root, k);
        return res;
    }
    private void dfs(TreeNode root, int k) {
        if (root == null) {
            return;
        }
        dfs(root.left, k);
        if (++count == k) {
            res = root.val;
        }
        dfs(root.right, k);
    }
    int res = 0, count = 0;
```


* 【104】给定一个二叉树，找出其最大深度。 
  * 很简单
```
  public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```

* 【offer36】输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向
  * 定义一个上一节点和head节点
  * 中序遍历
  * 最终对尾部进行连接
```
    public Node treeToDoublyList(Node root) {
        if (root == null) {
            return null;
        }
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    Node pre = null, head;
    private void dfs(Node root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        Node cur = new Node(root.val);
        if (head == null) {
            head = cur;
        } else {
            pre.right = cur;
            cur.left = pre;
        }
        pre = cur;
        dfs(root.right);
    }
```


* 【226】翻转一棵二叉树。 
```
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode right = invertTree(root.right), left = invertTree(root.left);
        root.right = left;
        root.left = right;
        return root;
    }
```


* 【145】给定一个二叉树，返回它的 后序 遍历。
```
   List<Integer> res = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        dfs(root);
        return res;
    }
    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        dfs(root.right);
        res.add(root.val);
    }
```

* 【offer34】 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点

```
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        dfs(root, new LinkedList<>(), target);
        return res;
    }

    private void dfs(TreeNode root, LinkedList<Integer> list, int target) {
        if (root == null) {
            return;
        }
        target -= root.val;
        list.addLast(root.val);
        //说明是叶子节点
        if (root.left == null && root.right == null && target == 0) {
            res.add(new LinkedList<>(list));
        }
        dfs(root.left, list, target);
        dfs(root.right, list, target);
        list.removeLast();
    }
```


* 【108】给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树
  * BST的中序遍历是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树
  * 我们可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树
  * 以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树啦
  * 本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点
  * int mid = left + ((right - left) / 2)，这么些不容易int越界数值越，例如left和right都是最大int，(left + right) / 2这么操作就越界了
```
   public TreeNode sortedArrayToBST(int[] nums) {
        return buildTree(nums, 0, nums.length - 1);
    }
    private TreeNode buildTree(int[] nums, int i, int j) {
        if (i > j) {
            return null;
        }
        int mid = i + (j - i) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildTree(nums, i, mid - 1);
        root.right = buildTree(nums, mid + 1, j);
        return root;
    }
```

* 【offer27】请完成一个函数，输入一个二叉树，该函数输出它的镜像
```
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode right = root.right, left = root.left;
        root.left = mirrorTree(right);
        root.right = mirrorTree(left);
        return root;
    }
```

* 【99】给你二叉搜索树的根节点 root ，该树中的两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树。 
  * 中序遍历过程中，记录错误两个错误排序节点，最后进行交换
  * 中序遍历的时候 访问到的元素是从小到大顺序排列
  * 对两个节点交换了顺序  那一定有两个地方是  不满足  前一个元素 < 当前元素 < 后一个元素
  * 使用两个全局变量在遍历过程中记录这两个节点 最后对他们进行交换
```
   TreeNode node1, node2, pre;
    public void recoverTree(TreeNode root) {
        dfs(root);
        int val = node1.val;
        node1.val = node2.val;
        node2.val = val;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);
        //说明有不正确的节点，即后面的节点比前面的大了
        if (pre != null && root.val < pre.val) {
            if (node1 == null) {
                node1 = pre;
            }
            node2 = root;
        }
        pre = root;
        dfs(root.right);
    }
```

*【144】给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 
```
   public List<Integer> preorderTraversal(TreeNode root) {
        dfs(root);
        return res;
    }
    List<Integer> res = new ArrayList<>();

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        dfs(root.left);
        dfs(root.right);
    }
```