## 1. 概述  
&emsp;&emsp;之前的文章说过架构设计的主要目的是为了解决软件系统复杂度带来的问题。有前人已经总结了，复杂度的来源一共有6个：  
* 高性能
* 高可用
* 可扩展性
* 低成本
* 安全
* 规模


## 2. 高性能  
&emsp;&emsp;高性能是如何给系统带来复杂性的呢？主要体现在两个方面？
* 单台计算机为了提升性能带来的复杂度
* 多台计算机做成的服务集群带来的复杂性  

这些问题怎么讲呢？

### 2.1. 单台计算机的复杂度  
&emsp;&emsp;计算机内部复杂度最关键的地方就是操作系统，操作系统和性能最相关的就是进程和线程。  
&emsp;&emsp;单台计算机的复杂度是如何增加的呢？ 这其实是一个操作系统的发展史：  
* 最早的计算机其实是没有操作系统的,只有输入、计算和输出功能,性能非常低
* 批处理操作系统应运而生，先把要执行的指令预先写下来（写到纸带、磁带、磁盘等），形成一个指令清单，批处理操作系统负责读取“任务”中的指令清单并进行处理，一次只能执行一个任务，性能有进步但cpu还是有空余闲置的。
* 发明了“进程” ，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令
* 进程通讯被设计出来，包括管道、消息队列、信号量、共享存储等。
* 多进程之间内存不能共享，且进程还是串行的，人们又发明了线程，线程是进程内部的子任务，但这些子任务都共享同一份进程数据，同时互斥锁机制被引入了。
* 以上还是一个cpu在跑
* 多核cpu被引入，实现真正意义上的多任务并行  

&emsp;&emsp;从上面可以看出，仅仅要完成一个高性能的单机软件系统，就需要了解需要考虑如多进程、多线程、进程间通信、多线程并发等技术点。  
&emsp;&emsp;并不是最新的就是最好的，也不是非此即彼的选择。在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。比如Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程。

### 2.2. 集群的复杂度    
&emsp;&emsp;业务的发展速度远远超过了硬件的发展速度，单机的性能无论如何是无法支撑的，必须采用机器集群的方式来达到高性能。   
&emsp;&emsp;然而事情往往没有这么建单，通过加机器提升性能伴随着系统的复杂度也大大的提升了。

#### 2.2.1. 任务分配
&emsp;&emsp;当服务器增加后，需要新增一个任务分配器来将请求分配至相应的服务集群上去。  
![](任务分配系统的复杂度.png)  
&emsp;&emsp;这里的任务分配器在实际生产中有：F5、交换机、LVS、Nginx、HAProxy；还可能是网关。  
任务分配器的特点为：
* 业务服务器和任务分配器需要交互，需要管理，比如连接检测、连接中断的特点
* 任务如何分配，采用何种分配算法、轮询、权重、负载均衡等。业务服务器还需要上报自己的任务状态。

&emsp;&emsp;当我们的任务分配器的压力上来后，任务分配器本身又会成为性能瓶颈，当业务请求达到每秒 10 万次的时候，单台任务分配器也不够用了，任务分配器本身也需要扩展为多台机器。此时任务分配器的复杂度大大提升，其特点有：
* 需要将不同的用户分配到不同的任务分配器上,常见的任务分配策略，如：DNS 轮询、智能 DNS、CDN（Content Delivery Network，内容分发网络）、GSLB 设备（Global Server Load Balance，全局负载均衡）
* 需要特别关注任务分配器的状态管理，故障处理，这些在网状的网络模型中非常的困难。
![](多台任务分配系统的复杂度.png)  


#### 2.2.2. 任务分解  
&emsp;&emsp;任务分配的方式，我们能够突破单台机器处理性能的瓶颈，但是单纯只通过任务分配的方式来扩展性能，收益会越来越低，1台机器扩充10台，性能不可能达到十倍以上，造成这种现象的主要原因是业务越来越复杂，单台机器处理的性能会越来越低。为了能够继续提升性能，如果业务更复杂，性能会更差，调用链更复杂。为了能够继续提升性能，我们需要采取第二种方式：任务分解。  
&emsp;&emsp;其核心思想为：把原来大一统但复杂的业务系统，拆分成小而简单但需要多个系统配合的业务系统，代码内部调用改为通过服务器之间的接口调用。  
&emsp;&emsp;为什么这么拆分能够提升性能呢？  
* 简单的系统更加容易做到高性能  
  通过简单的系统定位性能瓶颈更加容易
* 可以针对单个任务进行扩展  
  不需要改动整个系统，针对有瓶颈的子系统进行性能优化或者提升，可以是代码优化，也可以简单粗暴地加机器，不用修改其它的业务模块。

   
**注意： 并不是划分得越细越好，如果系统拆分得太细，为了完成某个业务，系统间的调用次数会呈指数级别上升，系统间的调用通道目前都是通过网络传输的方式，性能远比系统内的函数调用要低得多。虽然系统拆分可能在某种程度上能提升业务处理性能，但提升性能也是有限的，最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限**  

### 2.3. 小结  
高性能带来的复杂度主要体现的两方面：
* 单台计算机内部为了高性能带来的复杂度
* 二是是多台计算机集群为了高性能带来的复杂度