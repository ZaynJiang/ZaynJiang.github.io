## 1. 概述  
&emsp;&emsp;之前的文章说过架构设计的主要目的是为了解决软件系统复杂度带来的问题。有前人已经总结了，复杂度的来源一共有6个：  
* 高性能
* 高可用
* 可扩展性
* 低成本
* 安全
* 规模


## 2. 高性能  
高性能是如何给系统带来复杂性的呢？主要体现在两个方面？
* 单台计算机为了提升性能带来的复杂度
* 多台计算机做成的服务集群带来的复杂性  

这些问题怎么讲呢？

### 2.1. 单台计算机的复杂度  
&emsp;&emsp;计算机内部复杂度最关键的地方就是操作系统，操作系统和性能最相关的就是进程和线程。  
&emsp;&emsp;单台计算机的复杂度是如何增加的呢？ 这其实是一个操作系统的发展史：  
* 最早的计算机其实是没有操作系统的,只有输入、计算和输出功能,性能非常低
* 批处理操作系统应运而生，先把要执行的指令预先写下来（写到纸带、磁带、磁盘等），形成一个指令清单，批处理操作系统负责读取“任务”中的指令清单并进行处理，一次只能执行一个任务，性能有进步但cpu还是有空余闲置的。
* 发明了“进程” ，采取了分时的方式，即把 CPU 的时间分成很多片段，每个片段只能执行某个进程中的指令
* 进程通讯被设计出来，包括管道、消息队列、信号量、共享存储等。
* 多进程之间内存不能共享，且进程还是串行的，人们又发明了线程，线程是进程内部的子任务，但这些子任务都共享同一份进程数据，同时互斥锁机制被引入了。
* 以上还是一个cpu在跑
* 多核cpu被引入，实现真正意义上的多任务并行  

&emsp;&emsp;从上面可以看出，仅仅要完成一个高性能的单机软件系统，就需要了解需要考虑如多进程、多线程、进程间通信、多线程并发等技术点。  
&emsp;&emsp;并不是最新的就是最好的，也不是非此即彼的选择。在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。比如Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程。

### 2.2. 集群的复杂度    
&emsp;&emsp;业务的发展速度远远超过了硬件的发展速度，单机的性能无论如何是无法支撑的，必须采用机器集群的方式来达到高性能。   
&emsp;&emsp;然而事情往往没有这么建单，通过加机器提升性能伴随着系统的复杂度也大大的提升了。

#### 2.2.1. 任务分配
&emsp;&emsp;当服务器增加后，需要新增一个任务分配器来将请求分配至相应的服务集群上去。  
![](任务分配系统的复杂度.png)  
&emsp;&emsp;这里的任务分配器在实际生产中有：F5、交换机、LVS、Nginx、HAProxy；还可能是网关。  
任务分配器的特点为：
* 业务服务器和任务分配器需要交互，需要管理，比如连接检测、连接中断的特点
* 任务如何分配，采用何种分配算法、轮询、权重、负载均衡等。业务服务器还需要上报自己的任务状态。

当我们的任务分配器的压力上来后，任务分配器本身又会成为性能瓶颈，当业务请求达到每秒 10 万次的时候，单台任务分配器也不够用了，任务分配器本身也需要扩展为多台机器。此时任务分配器的复杂度大大提升，其特点有：
* 需要将不同的用户分配到不同的任务分配器上,常见的任务分配策略，如：DNS 轮询、智能 DNS、CDN（Content Delivery Network，内容分发网络）、GSLB 设备（Global Server Load Balance，全局负载均衡）
* 需要特别关注任务分配器的状态管理，故障处理，这些在网状的网络模型中非常的困难。
![](多台任务分配系统的复杂度.png)
  
