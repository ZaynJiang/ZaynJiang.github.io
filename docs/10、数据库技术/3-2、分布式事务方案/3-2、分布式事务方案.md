## 1. 概要
### 1.1. 何为分布式系统？
我理解就是通过网络来互相协作的不同组件组成的系统，叫做分布式系统。相比于单体系统而言，应用更容易扩展，服务职责更加分明，适合现在复杂业务场景和更大规模的访问量。分布式系统带来了一些问题，比如本文要描述的分布式事务问题、不同组件如何交互问题等。还有服务注册/配置、监控、日志等很多问题都会更加复杂。  
![](分布式事务案例.png)

这里只简单介绍了分布式系统，这是一个非常大的话题，有兴趣可以自行了解。
### 1.2. 何为分布式事务？
简单来说，就是分布式 + 事务 = 分布式事务，面对一个分布式系统，我的操作能够达到像单体应用事务一样的效果，那么这个事务就叫做分布式事务了。严格来说，事务应该具有ACID这四个特性，后面我们会对ACID进行说明。
### 1.3. 分布式算法/理论有哪些？
* CAP，在分布式系统中，一致性、可用性、分区容错性最多只能同时实现两点。
* Paxos，可以解决分布式一致性的问题
* Raft，Paxos算法的衍生，zk（ZAB），rocketmq
* 一致性hash  

一致性哈希的目的就是为了在节点数目发生改变时尽可能少的迁移数据，将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash 后会顺时针找到临接的存储节点存放。而当有节点加入或退 时，仅影响该节点在Hash环上顺时针相邻的后续节点
### 1.4. 分布式事务解决方案？
* 2PC/3PC
* 事务消息、本地消息表
* Seata框架


## 2. ACID
* 原子性（Atomicity），可以理解为一个事务内的所有操作要么都执行，要么都不执行。
* 一致性（Consistency），可以理解为数据是满足完整性约束的，也就是不会存在中间状态的数据。如转账的例子。
* 隔离性（Isolation），指的是多个事务并发执行的时候不会互相干扰，即一个事务内部的数据对于其他事务来说是隔离的。
* 持久性（Durability），指的是一个事务完成了之后数据就被永远保存下来，之后的其他操作或故障都不会对事务的结果产生影响。    

  

![](mysql隔离级别.png)
## 3. CAP理论  
![](cap理论.png)

加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标
* 一致性（Consistency）  
  写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1，用户的读操作就会得到 v1。这就叫一致性。

* 可用性（Availability）  
  用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。

* 分区容错性（Partition tolerance）  
  一般来说，分区容错无法避免，这个指标一般是总是成立的，因为两个节点总是可能无法联通的。

  

&emsp;&emsp;一致性和可用性不能同时存在，因为分区容错的原因，如果保持一致性，则需要要求g2必须保持同步到g1的数据，但是分区容错的原因，一直同步不过来，那么系统只能属于不可用状态。如果保持g2的可用状态，那么就可能造成g1，g2的数据不一致，所以不可能同时保证。  

&emsp;&emsp;网络通信不管怎么样都会有失败的可能，只能尽量提高可用性
（参考文章：http://www.ruanyifeng.com/blog/2018/07/cap.html）

## 4. 2PC 
* 准备阶段
* 提交阶段  

  

![](2pc提交模型.png)
### 4.1. 如果第二阶段失败了怎么呢？
* 提交  
  不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功，到最后真的不行只能人工介入处理。
* 回滚  
  也是不断重试，因为还没有提交，则会一直阻塞。
### 4.2. 如果第一阶段超时了？
直接当作回滚处理
### 4.3. 第一阶段成功了，还未提交，突然协调者挂了怎么办？
会一直阻塞，资源都被锁定住
### 4.4.第一阶段成功了，提交发起后，突然协调者挂了怎么办？  
&emsp;&emsp;协调者如果故障那么是不是可以做成一个高可用的集群呢，我们重新选举一个协调者，但是新的协调者并不知道哪个参与者是不是提交了，有可能未提交的参与者同时挂了，那么你去询问无法知道结果，我们可以通过记录统一的协调日志，通过日志来回溯去执行提交，但是参与者挂了，不知道他是否已经提交了，要不要往它那里发送呢。  
&emsp;&emsp;所以2PC是无法绝对保证一致性的。这里就是cap的分区容错因为一直存在，要么保持可用，要么保持一致。一般选择就是尽量保持一致，先返回，然后一直重试或者人工处理。
## 5. 3PC  
![](3pc模型.png)  
该方式如2PC图示，新增了准备阶段，其它的阶段一样，这会面临2PC相同的问题。  
它具有如下的特点：
* 这里新增了一个阶段，会进一步减小性能
* 参与者等待提交时，有超时机制，如果超时则自动提交，因为3pc认为这时大概率时提交的，但是也有可能是回滚。
* 3PC 是个纯的理论上的东西，做了一些努力工作但是效果不大，而且更复杂性能更差。
* **3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题。**（目前没理解）



> 分布式系统和分布式一致性问题
>
> 　　分布式系统，即运行在多台不同的网络计算机上的软硬件系统，并且仅通过消息传递来进行通信和协调。
> 　　分布式一致性问题，即相互独立的节点之间如何就一项决议达成一致的问题。
>
> 2PC(Two-Phase Commit 二阶段提交）
>
>  ![image-20240906105840528](image-20240906105840528.png) 
>
> 二阶段提交，是指将事务提交分成两个部分：准备阶段和提交阶段。事务的发起者称之为协调者，事务的执行者称为参与者。
>
> 阶段一：准备阶段
>
>              由协调者发起并传递带有事务信息的请求给各个参与者，询问是否可以提交事务，并等待返回结果。
>     
>              个 参与者执行事务操作，将Undo和Redo放入事务日志中（但是不提交）
>     
>               如果参与者执行成功就返回YES（可以提交事务），失败NO(不能提交事务)
>
> 阶段二：提交阶段
>
>               此阶段分两种情况：所有参与者均返回YES，有任何一个参与者返回NO
>     
>                所有参与者均反馈YES时，即提交事务。
>     
>                任何一个参与者反馈NO时，即中断事务。
>
> 提交事务：（所有参与者均反馈YES）
> 　　1、协调者向所有参与者发出正式提交事务的请求（即Commit请求）。
> 　　2、参与者执行Commit请求，并释放整个事务期间占用的资源。
> 　　3、各参与者向协调者反馈Ack完成的消息。
> 　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务提交。
>
> 中断事务：（任何一个参与者反馈NO）
> 　　1、协调者向所有参与者发出回滚请求（即Rollback请求）。
> 　　2、参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。
> 　　3、各参与者向协调者反馈Ack完成的消息。
> 　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务中断。
>
> 2PC的缺陷
>
> 　　1、同步阻塞：最大的问题即同步阻塞，即：所有参与事务的逻辑均处于阻塞状态。
> 　　2、单点：协调者存在单点问题，如果协调者出现故障，参与者将一直处于锁定状态。
> 　　3、脑裂：在阶段2中，如果只有部分参与者接收并执行了Commit请求，会导致节点数据不一致。
>
> 　　由于2PC存在如上同步阻塞、单点、脑裂问题，因此又出现了2PC的改进方案，即3PC。
>
> 3PC（Three-Phase Commit 三阶段提交协议）
>
> 　　3PC，三阶段提交协议，是2PC的改进版本，即将事务的提交过程分为CanCommit、PreCommit、do Commit三个阶段来进行处理。
>
> 阶段一：CanCommit
>
>              1、协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复。
>     
>              2、参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO。
> 阶段二：PreCommit
>
>                此阶段分为两种情况：
>     
>                 1.所有参与者均受到请求并返回YES。
>     
>                 2.有任何一个参与者返回NO，或者有任何一个参与者超时，协调者无法收到反馈，则事务中断
>
> 事务预提交：（所有参与者均反馈YES时）
> 　　1、协调者向所有参与者发出PreCommit请求，进入准备阶段。
> 　　2、参与者收到PreCommit请求后，执行事务操作，将Undo和Redo信息记入事务日志中（但不提交事务）。
> 　　3、各参与者向协调者反馈Ack响应或No响应，并等待最终指令。
>
> 中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）
> 　　1、协调者向所有参与者发出abort请求。
> 　　2、无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。
>
> 阶段3：do Commit
>
> 此阶段也存在两种情况：
> 　　1、所有参与者均反馈Ack响应，即执行真正的事务提交。
> 　　2、任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。
>
> 　　提交事务：（所有参与者均反馈Ack响应时）
> 　　1、如果协调者处于工作状态，则向所有参与者发出do Commit请求。
> 　　2、参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。
> 　　3、各参与者向协调者反馈Ack完成的消息。
> 　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务提交。
>
> 　　中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）
> 　　1、如果协调者处于工作状态，向所有参与者发出abort请求。
> 　　2、参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。
> 　　3、各参与者向协调者反馈Ack完成的消息。
> 　　4、协调者收到所有参与者反馈的Ack消息后，即完成事务中断。
>
> 　　注意：进入阶段三后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的         do Commit请求或abort请求。此时，参与者都会在等待超时之后，继续执行事务提交。
>
>  ![image-20240906105914837](image-20240906105914837.png) 

3PC的优点和缺陷

　　优点：降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务。

　　缺陷：脑裂问题依然存在，即在参与者收到PreCommit请求后等待最终指令，如果此时协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致

## 6. 本地消息表
* 将业务的执行和将消息放入本地消息表中的操作放在同一个事务中
* 事务执行成功的记录的状态为成功否则为失败
* 将后台任务定时去读取本地消息表处理
* 多次处理失败的进行人工处理
* 本地消息表其实实现的是最终一致性，容忍了数据暂时不一致的情况

## 7. TCC
Tcc详情请参考seata的分布式介绍  
![](tcc模型.png)
## 8. 消息事务（Rocketmq）
* 发送方先向broker发送半消息（消费方暂时不能收到）
* 发送方执行本地事务，执行成功则向broker commit消息否则，rollback
* 发送方提供反查消息执行情况的接口，broker超时可查发送方是否执行成功，自行commit或者rollback
* Commit的消息会发送至消费方，消费方执行事务。    

![](消息事务.png)  
&emsp;&emsp;由此可见消息事务也是最终一致性，如果消费方事务没有执行成功，则消费不了消息，要么重试，要么人工处理，重试一定次数后消息就会被放入到死信队列之中了，这也是最大努力通知型了。

## 9. 总结
&emsp;&emsp;2pc和3pc是都有可能产生阻塞和不一致风险的，本地事务表和rocketmq事务消息都是最大努力的柔性事务，可用在时效不那么敏感的业务上。tcc是属于业务侵入型，从业务的角度来避免分布式事务的问题，比如转账时制造一个冻结的中间状态。具体如何使用需要结合业务场景，服务架构具体分析，目前是没有完美的解决方案。

