## 1. 开头  
　我们知道kafka具有非常好的系统容错性，这个kafka的容错性是如何保证的呢？答案就是所有分布式系统通用的解决之道-副本机制。  
副本机制总的来说到底有什么好处呢？ 

* 数据冗余，保证了系统整体的可用性
* 提升伸缩性，我们可以通过增加硬件机器将副本进行扩展，从而提高整体的吞吐量（这里需要副本能够提供对服务）
* 提升服务性能，将副本放在就近的访问机房，从而提升吞吐量

　在这个需要指出的是kafka并没有让kafka的副本能够对外服务，所以只起到了容错的作用

## ２. 副本
　我们知道kafka的主题是由分区组成的，数据分散在不同的分区上，而副本的概念是对标于分区，其本质就是分区的拷贝，它是一个只能追加消息的提交日志。  
　当我们的副本越多，那么能够就能更好的保证系统的可用性。  
　如下图所示，就是一个kafka的副本分布图：
![](kafka的容错性.png)  
### 2.1. 副本的类型
kafka的副本有两种，一种是领导者副本，一种是追随者副本。  
![](副本角色.png)  
* 领导者副本（Leader Replica）和追随者副本（Follower Replica）。  
  在 Kafka 中，副本分成两类,每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本
* 在 Kafka 中，追随者副本是不对外提供服务的。所有的读写请求都必须发往领导者副本所在的 Broker，由该 Broker 负责处理。追随者副本不处理客户端请求，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步
* 当领导者副本挂了，基于zk，kafka会重新选举一个领导者副本，如果之前的领导这副本起来了，也只能变成追随者副本。

由由上面可知。Kafka 的追随者副本没有任何作用，不能实现扩增副本的数量从而一定程度来提升性能。

### 2.2. 领导者副本设计优点
* Read-your-writes  
能够实时的看到写入的数据，如果从跟随者副本读的话，因为是异步的，所以有可能读不到，但是已经写入了。
* Monotonic Reads（单调读）  
保证单调读一致性，如果允许追随者副本提供读服务，假设有两个跟随着副本，消费者从第一个副本读到了某数据，但是从第二副本可能异步还没有同步完成，又没有读取到数据，这就造成单调不一致读了。  
### 2.3. 实现机制  
#### 2.3.1. In-sync Replicas（ISR） 
#### 2.3.2. Unclean 领导者选举（Unclean Leader Election）

### 2.4. 小结
I