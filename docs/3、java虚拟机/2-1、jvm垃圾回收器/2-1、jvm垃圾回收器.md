## 1. 概述

前面已经介绍了响应的回收算法，分为标记和清理阶段，标记有计数和引用跟踪的方法，java自身提供的垃圾回收器有很多种，有：

* 串行垃圾回收器（+UseSerialGC）

  会停止当前应用进程，回收垃圾，停顿时间久，吞吐量大，响应时间长

* 并行GC（+UseParallelGC）  

  是多个线程同时执行串行回收算法（多核），也会使应用停顿，吞吐量大，响应时间长，用户体验差

* cms gc(+UseConcMarkSweepGC)

  应用和垃圾回收多个线程并发执行，吞吐量相对小，响应时间短，用户体验好

* G1(+UseG1GC -XX:MaxGCPauseMillis=30)  

   并发 + 并行回收 + 标记管理

* ZGC/Shenandoah GC    

  很先进

PS：

* 并行（parallel)

  指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

* 并发（Concurrent）

  指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替进行），用户程序在继续镜像，而垃圾收集程序运行于另一个CPU上。

## 2. 回收算法

之前也分析回收算法，有多种算法，标记清理、标记复制清理、标记整理算法等，但是如何进行标记的呢？主要有两种标记算法： 

### 2.1. 标记算法

#### 2.1.1. 引用计数

给对象添加一个计数器，每当有地方引用它计数器就+1，反之引用失效时就-1，那么计数器值为0的对象就是可以回收的对象，但是有一个问题就是循环引用的话无法解决

#### 2.1.2. 可达性分析(引用跟踪算法)

对于现在的虚拟机来说，主要用的算法是可达性分析算法

* 定义GC ROOTS根对象集合
* 通过GC ROOTS向下搜索，搜索的过程走过的路径称作引用链
* 如果某个对象到GC ROOTS没有任何引用链，那么就是对象不可达，是可以被回收的对象
* 不可达对象需要进行两次标记，第一次发现没有引用链相连，会被第一次标记
  * 如果需要执行finalize()方法，之后这个对象会被放进队列中等待执行finalize()
  * 如果在finalize()中成功和引用链上的其他对象关联，就会被移出可回收对象集合。（但是不建议使用finalize()方法  



### 2.2. 分代假说

有这么一个假说：

* 绝大多数对象都是朝生夕死的

* 熬过越多次垃圾回收的对象越难死亡

​	就产生了现在我们常见的年轻代和老年代

​	年轻代放死的快的对象。每次年轻代内存不够我们就触发MinorGC，以后还有存活的对象我们就根据经历过MinorGC次数和动态年龄判断来决定是否晋升老年代。老年代则存放老不死的对象，这里GC称之为OldGC，现在也有很多人把他叫做FullGC，实际上这并不准确，FullGC应该泛指年轻代和老年代的的GC

### 2.3. 记忆集

​	假如我们进行MinorGC，会不会有对象被老年代引用着，进行OldGC也可能会有对象被年轻代引用着，如果是的话，那我们进行MinorGC的时候不光要管GC Roots，还有再去遍历老年代，这个性能问题就很大。于是就有了这个假说

* 跨代引用相对于同代引用来说仅占极少数

​	当我们进行young gc时，我们的gc roots除了常见的栈引用、静态变量、常量、锁对象、class对象这些常见的之外，如果老年代有对象引用了我们的新生代对象，那么老年代的对象也应该加入gc roots的范围中，但是如果每次进行young gc我们都需要扫描一次老年代的话，那我们进行垃圾回收的代价实在是太大了，因此我们引入了一种叫做记忆集的抽象数据结构来记录这种引用关系

![](垃圾回收记忆集.png) 

​	记忆集是一种用于记录从非收集区域指向收集区域的指针集合的数据结构，假如所有的老年代对象都有指针指向了新生代，那么我们需要维护整个老年代大小的记忆集，毫无疑问这种方法是不可取的。因此我们引入了卡表的数据结构

#### 2.3.1.  卡表

​	卡表实际上就是记忆集的一种实现方式。

​	对于HotSpot虚拟机来说，卡表的实现方式就是一个字节数组。

​	卡表就是映射了一块块的内存地址，这些内存地址块称为**卡页**。如果该区域中有引用指向了待回收区域的对象，卡表数组对应的元素将被置为1，没有则置为0；

​	从代码可以看出每个卡页的大小就是2^9=512kb。如果转换为16进制，数组的0，1号元素就映射为0x0000～0x01FF(0-511)、0x0200～0x03FF(512-1023)内存地址的卡页。


![image-20220304143834782](卡表示意图.png)

**卡表使用原理：**

* 只要一个卡页内的对象存在一个或者多个跨代对象指针，就将该位置的卡表数组元素修改为1，表示这个位置为脏，没有则为0。

* 在GC的时候，就直接把值为1对应的卡页对象指针加入GC Roots一起扫描即可。

* 我们就不需要去在发生MinorGC的时候扫描整个老年代了，性能得到了极大的提升 

**如何标记脏页：**

​	卡表的数组元素要修改成1，也就是脏的状态，对于HotSpot来说是通过写屏障来实现的，就是在其他分代引用了当前分代的对象时候，在对引用进行赋值的时候进行更新，更新的方式类似AOP的切面思想：

```
void oop_field_store(oop* field, oop new_value) { 
    // 引用字段赋值操作
    *field = new_value;
    // 写后屏障，在这里完成卡表状态更新 
    post_write_barrier(field, new_value);
}
```

**伪共享问题：**

​	假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节），也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，即将卡表更新的逻辑变为以下代码所示

​	我们可以使用`-XX:+UseCondCardMark`，代表是否开启卡表更新的判断，没有被标记过才标记为脏

```
if (CARD_TABLE [this address >> 9] != 0) 
   CARD_TABLE [this address >> 9] = 0;
```

**小结：**

​	具体行为是将老年代堆内存空间分为一个个相等的小区间，每一个区间被称为Card Page，每个Card Page在Dirty Card表中会有一个对应的bit位标识其状态，如果一个对象的引用关系改变，写屏障逻辑就会将其所在的Card Page就会被标记位Dirty。注意Dirty标记是不是标记在对象上面的，而是标记到对象所在的Card Page上面。扫描时是扫描Card Page中的所有对象。一个Card Page可能不只有一个对象，那么并发情况一个Card Page的多个对象发生改变，那么都需要对Dirty Card表的同一位进行标记修改，这时间就会发生伪共享（false sharding：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享）的问题。为了解决这个问题，JDK1.7加入一个参数-XX:+UseCondCardMark来控制是否进行有条件的写屏障，开启时就会判断目标Card Page是否已经被标记为Dirty，如果是就不再重复进行标记了。

**注意：**

​	引用关系更新是指老年代对象对老年代对象引用更新，新生代对老年代新的引用并不算引用更新

​	需要标记的是引用对象所在的Card而不是被引用对象，比如老年代中新增A->B,那么标记在A的Card，而不是标记在B的Card。原因是A引用B，扫描A所在Card时如果A是存活节点那么B也就是存活节点，A是待回收节点B也是待回收节点。如果标记在B上，那么就会出现只知道B被别人引用了，但是引用他的是一个存活节点还是死亡节点却无法判断

### 2.3. 三色标记

​	卡表解决了跨代收集和根节点枚举的性能问题。而有了这些措施实际上枚举根节点这个过程造成的STW停顿已经属于可控范围。

​	GC Roots开始遍历，怎么才能高效的标记这些对象，这就是三色标记法的作用了。因为如果堆内的对象越多，那么显然标记产生的停顿时间就越长。

CMS举例：

* 初始标记

  标记GC ROOT能关联到的对象，这一步需要STW，但是停顿的时间很短。

* 并发标记

  从GCRoots的直接关联对象开始遍历整个对象图的过程，这个时间会比较长，但是现在是可以和用户线程并发执行的，这个效率的问题就是三色标记关注的问题。

所以三色标记主要是解决和用户线程并发的时候标记的问题。

#### 2.3.1. 标记过程

三色标记法中，把从GC Roots开始遍历的对象标记为以下三种颜色：

* 白色，在刚开始遍历的时候，所有的对象都是白色的

  ![](三色标记初始阶段.png) 

  

* 灰色，被垃圾回收器扫描过，但是至少还有一个引用没有被扫描

  A、E对象被扫描到变成灰色，B、C对象开始被扫描变成灰色

* 黑色，被垃圾回收器扫描过，并且这个对象的引用也全部都被扫描过，是安全存活的对象

  B、C他们的引用也被扫描完成后自己也就都变成了黑色

  A、E对象的引用也都被扫描，A、E对象变成黑色

  最后剩下的E、F节点就是可以被回收的对象了

![](三色标记整体过程.png) 

#### 2.3.2. 三色标记问题

三色标记并发标记的时候，有两种情况：

* 有些对象在开始阶段是村存活，但是后来又变成垃圾了。应该要清理的对象标记成存活，这样本次GC就无法清理这个对象，这个被称作为浮动垃圾，解决方案就是等下次GC的时候再清理

* 如果把存活对象标记成需要清理，那么就有点麻烦了，这样你的程序就该出问题了

  只有同时满足两个条件才会发生这种对象消失的问题：

  * 插入了一条或者多条黑色到白色对象的引用
  * 删除了全部从灰色到白色对象的引用

  **例子：**

  ![](三色标记标记错误问题1.png) 

  * 假设A扫描完，刚好C成为灰色
  * 此时C->D的引用删除，同时A->D新增了引用（同时满足两个条件了吧）
  * 这样本来按照顺序接下来D应该会变成黑色(黑色对象不应该被清理)
  * 但是由于C->D没有引用了，A已经成为了黑色对象，他不会再被重新扫描了
  * 即便新增了A->D的引用，D也只能成为白色对象，最终被无情地清理

**解决方案：**

​	针对这个问题也有两种解决方案：**增量更新**和**原始快照**，如果对应到垃圾回收器的话，CMS使用的是增量更新，而像G1则是使用原始快照。

* 增量更新

  会把这些新插入的引用记录下来，扫描结束之后，再以黑色对象为根重新扫描一次。这样看起来不就是增量更新吗，新插入的记录再扫一次！

* 原始快照

  破坏第二个条件，他把这个要删除的引用记录下来，扫描结束之后，以灰色对象为根重新扫描一次。所以就像是快照一样，不管你删没删，其实最终还是会按照之前的关系重新来一次

#### 
