## 1. 概述

前面已经介绍了响应的回收算法，分为标记和清理阶段，标记有计数和引用跟踪的方法，java自身提供的垃圾回收器有很多种，有：

* 串行垃圾回收器（+UseSerialGC）

  会停止当前应用进程，回收垃圾，停顿时间久，吞吐量大，响应时间长

* 并行GC（+UseParallelGC）  

  是多个线程同时执行串行回收算法（多核），也会使应用停顿，吞吐量大，响应时间长，用户体验差

* cms gc(+UseConcMarkSweepGC)

  应用和垃圾回收多个线程并发执行，吞吐量相对小，响应时间短，用户体验好

* G1(+UseG1GC -XX:MaxGCPauseMillis=30)  

   并发 + 并行回收 + 标记管理

* ZGC/Shenandoah GC    

  很先进



PS：

* 并行（parallel)

  指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

* 并发（Concurrent）

  指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替进行），用户程序在继续镜像，而垃圾收集程序运行于另一个CPU上。





## 2. 回收算法

之前也分析回收算法，有多种算法，标记清理、标记复制清理、标记整理算法等，但是如何进行标记的呢？主要有两种标记算法： 

### 2.1. 引用计数

给对象添加一个计数器，每当有地方引用它计数器就+1，反之引用失效时就-1，那么计数器值为0的对象就是可以回收的对象，但是有一个问题就是循环引用的话无法解决

### 2.2. 可达性分析(引用跟踪算法)

对于现在的虚拟机来说，主要用的算法是可达性分析算法

* 定义GC ROOTS根对象集合
* 通过GC ROOTS向下搜索，搜索的过程走过的路径称作引用链
* 如果某个对象到GC ROOTS没有任何引用链，那么就是对象不可达，是可以被回收的对象
* 不可达对象需要进行两次标记，第一次发现没有引用链相连，会被第一次标记
  * 如果需要执行finalize()方法，之后这个对象会被放进队列中等待执行finalize()
  * 如果在finalize()中成功和引用链上的其他对象关联，就会被移出可回收对象集合。（但是不建议使用finalize()方法
