## 1. 概要

​	我们知道mysql基本的存储单位是页，页中有多条行记录，也有不同类型的页，即使我们访问某个页中的一条数据时，也会把所属页的数据都加载到内存之中。这样后续的读取就不用到表空间io读取数据了。Mysql的缓存部分就是bufferpool。

## 2. 事务的隔离级别

### 2.1. 为什么会有隔离级别

当同一条记录，多个客户端同时访问的时候，就需要隔离级别了，一个事务在访问的时候，另一个事务应该排队。但是直接隔离就会导致性能不高。所以就有了事务的隔离级别了。

### 2.2. Mysql的事务问题

* 脏写

​        Update table set name = “xxx1” where uid = 1;

​		Update table set name = “xxx2” where uid = 1;rollback;

​		如何两条语句同时执行，则有可能第一条语句被回滚了。但是它的客户端确实已经提交成功了

* 脏读

​		一个事务读到了另一个未提交事务修改过的数据，那么这就是脏读

* 不可重复读

​			一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最		新值，那就意味着发生了 不可重复读。意思就是，第一个事务可以读到其它事务的最新值，这种现象被称为不可重复读。

​		举例：

​				有一个大事务，要执行很长时间；另外有一堆小事务，很快就执行完成。

​				大事务来回查一个数据

​				一堆小事务串行改这个数据，改完之后提交成功。

​				大事务虽然读到的也是小事务提交之后的内容，但是这个数据经常被小事务改来改去。

​				想避免不可重复读，可以给加共享锁（即读锁），加了共享锁之后，任何事务就不得加排他锁（即写锁）了，这样就完美解决了				不可重复读的问题。

​				设置共享读锁也就是隔离级别提高到 REPETABLE_READ 可重读，这也是 MySQL 的默认隔离级别。

​				至于危害也很简单，程序里面一堆 if 怎样再怎样，每次读的东西都不一样，你到底想怎样

* 幻读

​			一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询		时，能把另一个事务插入的记录也读出来。

​			幻读只是重点强调了读取到了之前读取没有获取到的记录

### 2.3. 标准的隔离级别

​	上面的的问题严重性可以来排个序，有些是很严重的，有些是不那么严重的问题严重性从大到小排序：

​	脏写>脏读>不可重复读>幻读

为了解决上面的问题，又能兼顾一定的性能。所以就设定了隔离级别

- 未提交读，可能出现脏读，不可重复读、幻读
- 已提交读，可能出现不可重复读、幻读
- 可重复读，可能出现幻读
- 可串行化，都不会发生

脏写在mysql内部都解决掉了，这几种隔离级别都不会发生。

### 2.4. Mysql隔离级别

​	不同的数据库产品对隔离级别的支持不一样，oracle支持已提交读和串行化，mysql支持全部的四种，但是高版本已经解决了可重复读可能出现幻读的问题，且它的默认隔离级别为可重复读。Mysql可以通过配置参数或者session去更改它的隔离级别。具体的方式可以参考相应的文档。

## 3. Mvcc原理

## 4. 锁