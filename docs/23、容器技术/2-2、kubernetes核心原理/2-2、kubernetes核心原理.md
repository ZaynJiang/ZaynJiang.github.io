## 2. pod

POD的直议是豆荚，豆荚中的一个或者多个豆属于同一个家庭，共享一个物理豆荚（可以共享调度、网络、存储，以及安全），每个豆虽然有自己的空间，但是由于之间的缝隙，可以近距离无缝沟通（Linux Namespace相关的属性。

Pod的定义为：

实际上是在扮演传统基础设施里“虚拟机”的角色；而容器，则是这个虚拟机里运行的用户程序

我们可以把整个虚拟机想象成为一个 Pod，把这些进程分别做成容器镜像，把有顺序关系的容器，定义为 Init Container。然后进行编排

总的来说容器是进程，而一个pod可以包含多个容器，比如我们使用war包和tomcat做一个pod，将war包做成初始化容器，将war包复制到一个目录，而tomcat有也可以做一个容器然后就可以使用这个目录的war包进行web服务了。又比如我们的日志搜集和应用分别放到一个容器里，但是日志收集容器可以从公共目录里读取日志发送。

这里依托于可以这几个容器可以共享目录。这个借助于Infra 容器实现的。Infra 容器永远都是第一个被创建的容器，而其他用户定义的容器，则通过 Join Network Namespace 的方式，与 Infra 容器关联在一起。

这样，一个 Volume 对应的宿主机目录对于 Pod 来说就只有一个，Pod 里的容器只要声明挂载这个 Volume，就一定可以共享这个 Volume 对应的宿主机目录

## 3. API对象

## 4. StatefulSet

StatefulSet 其实是一种特殊的 Deployment，只不过这个“Deployment”的每个 Pod 实例的名字里，都携带了一个唯一并且固定的编号。这个编号的顺序，固定了 Pod 的拓扑关系；这个编号对应的 DNS 记录，固定了 Pod 的访问方式；这个编号对应的 PV，绑定了 Pod 与持久化存储的关系。所以，当 Pod 被删除重建时，这些“状态”都会保持不变

pod的状态

Pod 状态是 Ready，实际上不能提供服务的可能原因

* 程序本身有 bug，本来应该返回 200，但因为代码问题，返回的是500
* 程序因为内存问题，已经僵死，但进程还在，但无响应
* Dockerfile 写的不规范，应用程序不是主进程，那么主进程出了什么问题都无法发现
* 程序出现死循环

### 4.1. 拓扑状态

### 4.2. 存储状态

### 4.3. mysql主从案例

PS：一个容器里显然没办法管理两个常驻进程，因为容器是单进程的意思，所以数据复制操作要用sidecar容器来处理，而不用mysql主容器来一并解决。

将数据复制操作和启动mysql服务一并写到同一个sh -c后面，这样算两个进程。

### 4.4.  小结

StatefulSet 已经不能解决它的部署问题就可以使用Operator了

## 4. 控制器

## 5. 水平扩展

金丝雀部署：优先发布一台或少量机器升级，等验证无误后再更新其他机器。优点是用户影响范围小，不足之处是要额外控制如何做自动更新。
蓝绿部署：2组机器，蓝代表当前的V1版本，绿代表已经升级完成的V2版本。通过LB将流量全部导入V2完成升级部署。优点是切换快速，缺点是影响全部用户