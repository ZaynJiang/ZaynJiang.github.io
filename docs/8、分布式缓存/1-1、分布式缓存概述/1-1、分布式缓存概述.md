## 1. 数据的分类
按照变化频率，我们将数据做了一个分类
* 静态数据，基本不变
* 准静态数据，变化程度变化较小，比如组织架构，省份编码
* 中间状态数据，计算的中间状态数据  

按使用频率
* 热数据
* 读写比很大的数据   
  
这些数据都可以使用缓存技术  

## 2. 什么是缓存
&emsp;&emsp;为了加速访问速度，存放的临时性的冗余数据。缓存在应用程序内存里的，叫做本地缓存，存放在外部的，叫做外部缓存。本质是通过冗余的空间来换取时间。这样来提升访问的信息。缓存就是用来加速程序对数据的访问  

### 2.1. 缓存的例子
* Cpu如何从磁盘中读取数据很慢，所以有了内存内存的速度还是没有cpu快，所有有了cpu缓存
* 网络传输的buffer  

  
在计算机世界中到处都充斥着缓存

### 2.2. 加载时机
* 程序启动时全量加载
* 懒加载
  * 同步，使用时如果缓存没有从源里拿取，放到缓存中，然后返回
  * 异步，只从缓存拿取，两个策略处理没有的情况
    * 没有发起异步拿取
    * 另外的机制维护缓存数据，可以定时或者其它的触发
### 2.3. 不建议使用缓存的数据
变化频率大，一致性要求又高，这种数据需要保证很强的一致性，变化频率大实现难度也很大，需要加上事务。
### 2.4.缓存的效果
* 读写比，写越多，维护成本很高，读写比越大，说明使用缓存的价值可能就越高
* 命中率，只有被命中的数据才是有意义的缓存
### 2.5. 使用缓存考量指标
* 性能
* 一致性
* 成本
### 2.6. 使用缓存不当导致的问题
* 预热缓存会耗费资源，可能启动应用时很慢
* 比如是内存资源，会占用一定的内存资源，如果使用不当可能会耗尽所有的资源，如果淘汰策略不合理，旧的数据清理不掉，命中率低。
### 2.7. Java应用的本地缓存
* 自定义Map
* Hibernate、mybatis都有cache
* Guava缓存
* Spring cache(注解，spel)，使用了aop
  
本地缓存的缺点
* 集群不共享缓存数据
* Jvm内存大影响gc
* 缓存数据处理，占用cpu资源
### 2.8.远程缓存
* Redis
* Memcached
* Hazelcast/Ignite内存网格


## 3. 缓存的策略
缓存在使用的时候需要考虑其容量问题，需要将命中率低的数据过期掉过期策略有：
* fifo、lru
* 固定时间
* 业务时间加权
## 4. 使用缓存可能会遇到什么问题
### 4.1. 缓存穿透，大量请求没有走缓存，直接到数据库,而数据库也没有该数据
解决：
* 缓存空值
* Bloom过滤或RoaringBitmap 判断KEY是否存在，增加校验接口
* 完全以缓存为准
### 4.2. 缓存击穿，在缓存失效的时候，大量并发请求这个key，偶然的
解决：
* 加互斥锁，即缓存没有数据时从原始数据拿时，加上互斥锁，只允许一个线程拿，没拿到锁的等待一段时间再从缓存中拿数据。
* 完全以缓存为准
* 设置热点数据永不过期
### 4.3. 缓存雪崩
缓存中大量的数据都过期了，导致原始数据源接收请求过大，可能会导致数据压力过大。  
分析：  
* 更新策略同一时间过期
* 缓存服务器宕机
* 等等    
      
解决：
* 过期时间不要同一时间
* 热点数据永不过期
* 热点数据分散不同的机器
* 缓存数据库高可用，主从复制，多副本
* 熔断限流，对系统负载能力控制
